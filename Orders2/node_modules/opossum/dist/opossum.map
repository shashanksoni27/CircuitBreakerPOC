{"version":3,"sources":["webpack://circuitBreaker/webpack/universalModuleDefinition","webpack://circuitBreaker/webpack/bootstrap","webpack://circuitBreaker/./index.js","webpack://circuitBreaker/./lib/circuit.js","webpack://circuitBreaker/./lib/hystrix-formatter.js","webpack://circuitBreaker/./lib/hystrix-stats.js","webpack://circuitBreaker/./lib/prometheus-metrics.js","webpack://circuitBreaker/./lib/promisify.js","webpack://circuitBreaker/./lib/semaphore.js","webpack://circuitBreaker/./lib/status.js","webpack://circuitBreaker/./node_modules/bintrees/index.js","webpack://circuitBreaker/./node_modules/bintrees/lib/bintree.js","webpack://circuitBreaker/./node_modules/bintrees/lib/rbtree.js","webpack://circuitBreaker/./node_modules/bintrees/lib/treebase.js","webpack://circuitBreaker/./node_modules/prom-client/index.js","webpack://circuitBreaker/./node_modules/prom-client/lib/bucketGenerators.js","webpack://circuitBreaker/./node_modules/prom-client/lib/cluster.js","webpack://circuitBreaker/./node_modules/prom-client/lib/counter.js","webpack://circuitBreaker/./node_modules/prom-client/lib/defaultMetrics.js","webpack://circuitBreaker/./node_modules/prom-client/lib/gauge.js","webpack://circuitBreaker/./node_modules/prom-client/lib/histogram.js","webpack://circuitBreaker/./node_modules/prom-client/lib/metricAggregators.js","webpack://circuitBreaker/./node_modules/prom-client/lib/metrics/eventLoopLag.js","webpack://circuitBreaker/./node_modules/prom-client/lib/metrics/heapSizeAndUsed.js","webpack://circuitBreaker/./node_modules/prom-client/lib/metrics/heapSpacesSizeAndUsed.js","webpack://circuitBreaker/./node_modules/prom-client/lib/metrics/helpers/safeMemoryUsage.js","webpack://circuitBreaker/./node_modules/prom-client/lib/metrics/osMemoryHeap.js","webpack://circuitBreaker/./node_modules/prom-client/lib/metrics/osMemoryHeapLinux.js","webpack://circuitBreaker/./node_modules/prom-client/lib/metrics/processCpuTotal.js","webpack://circuitBreaker/./node_modules/prom-client/lib/metrics/processHandles.js","webpack://circuitBreaker/./node_modules/prom-client/lib/metrics/processMaxFileDescriptors.js","webpack://circuitBreaker/./node_modules/prom-client/lib/metrics/processOpenFileDescriptors.js","webpack://circuitBreaker/./node_modules/prom-client/lib/metrics/processRequests.js","webpack://circuitBreaker/./node_modules/prom-client/lib/metrics/processStartTime.js","webpack://circuitBreaker/./node_modules/prom-client/lib/metrics/version.js","webpack://circuitBreaker/./node_modules/prom-client/lib/pushgateway.js","webpack://circuitBreaker/./node_modules/prom-client/lib/registry.js","webpack://circuitBreaker/./node_modules/prom-client/lib/summary.js","webpack://circuitBreaker/./node_modules/prom-client/lib/timeWindowQuantiles.js","webpack://circuitBreaker/./node_modules/prom-client/lib/util.js","webpack://circuitBreaker/./node_modules/prom-client/lib/validation.js","webpack://circuitBreaker/./node_modules/tdigest/tdigest.js","webpack://circuitBreaker/external \"cluster\"","webpack://circuitBreaker/external \"events\"","webpack://circuitBreaker/external \"fs\"","webpack://circuitBreaker/external \"http\"","webpack://circuitBreaker/external \"https\"","webpack://circuitBreaker/external \"process\"","webpack://circuitBreaker/external \"stream\"","webpack://circuitBreaker/external \"url\"","webpack://circuitBreaker/external \"util\"","webpack://circuitBreaker/external \"v8\""],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFa;;AAEb,uBAAuB,mBAAO,CAAC,uCAAe;AAC9C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,qBAAqB;AACnC;AACA,WAAW,SAAS,qCAAqC;AACzD,WAAW,OAAO,0BAA0B;AAC5C,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA,YAAY,eAAe,kBAAkB,qBAAqB;AAClE;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAO,CAAC,2CAAiB;;AAE7C;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAO,CAAC,mDAAqB;AACxC;AACA,CAAC;;AAED;AACA;AACA;;;;;;;;;;;;;AClHa;;AAEb,qBAAqB,mBAAO,CAAC,sBAAQ;AACrC,eAAe,mBAAO,CAAC,iCAAU;AACjC,qBAAqB,mBAAO,CAAC,+CAAiB;AAC9C,kBAAkB,mBAAO,CAAC,uCAAa;AACvC;AACA;AACA,sBAAsB,mBAAO,CAAC,yDAAsB;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA,WAAW,SAAS,qCAAqC;AACzD,WAAW,OAAO,0BAA0B;AAC5C,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,aAAa,UAAU;AACzC,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,qBAAqB;AAChE;AACA;AACA;AACA,aAAa,0BAA0B;AACvC;AACA,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,IAAI;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,qBAAqB;AAClE;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,IAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,+BAA+B;AAC/B,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB;AACA;AACA,eAAe;AACf;AACA;AACA,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,IAAI;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;;;;;;;;;;;;ACtpBa;;AAEb,8BAA8B,qBAAqB;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACjFa;;AAEb,OAAO,sBAAsB,GAAG,mBAAO,CAAC,sBAAQ;AAChD,kBAAkB,mBAAO,CAAC,uDAAqB;;AAE/C;AACA;AACA;AACA;AACA,6BAA6B,iCAAiC;AAC9D;AACA,CAAC;;AAED;;AAEA;AACA,uCAAuC,qBAAqB;AAC5D,iDAAiD;AACjD;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,cAAc,eAAe;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;;AC9Ea;;AAEb,eAAe,mBAAO,CAAC,wDAAa;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kCAAkC;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,wBAAwB;;AAEtD;AACA;AACA,iBAAiB,OAAO,EAAE,UAAU;AACpC,gCAAgC,aAAa,aAAa,UAAU;AACpE,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACnDa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;ACda;;AAEb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,mDAAmD,QAAQ;AAC3D;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrDa;;AAEb;AACA;AACA;AACA;;AAEA,qBAAqB,mBAAO,CAAC,sBAAQ;;AAErC;AACA,wCAAwC,qBAAqB;AAC7D,2CAA2C;AAC3C;AACA;AACA,wDAAwD;AACxD;AACA;AACA,IAAI,qBAAqB;AACzB,uCAAuC,qBAAqB;AAC5D;AACA,4CAA4C,qBAAqB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,KAAK,oDAAoD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,mBAAmB;;AAEtC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC1LA;AACA,YAAY,mBAAO,CAAC,2DAAc;AAClC,aAAa,mBAAO,CAAC,6DAAe;AACpC;;;;;;;;;;;;;ACFA,eAAe,mBAAO,CAAC,2DAAY;;AAEnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA,iBAAiB;AACjB,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;ACzGA,eAAe,mBAAO,CAAC,2DAAY;;AAEnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;;AAEA;AACA,sBAAsB;AACtB,uBAAuB;AACvB,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA,iBAAiB;AACjB,kBAAkB;AAClB,qBAAqB;AACrB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACxNA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;ACrOA;AACA;AACA;AACA;;AAEa;;AAEb,mBAAmB,mBAAO,CAAC,kEAAgB;AAC3C,mBAAmB,mBAAO,CAAC,kEAAgB;AAC3C,sBAAsB,mBAAO,CAAC,kEAAgB;;AAE9C,kBAAkB,mBAAO,CAAC,gEAAe;AACzC,gBAAgB,mBAAO,CAAC,4DAAa;AACrC,oBAAoB,mBAAO,CAAC,oEAAiB;AAC7C,kBAAkB,mBAAO,CAAC,gEAAe;AACzC,sBAAsB,mBAAO,CAAC,wEAAmB;;AAEjD,wBAAwB,mBAAO,CAAC,kFAAwB;AACxD,6BAA6B,mBAAO,CAAC,kFAAwB;;AAE7D,gCAAgC,mBAAO,CAAC,8EAAsB;;AAE9D,sBAAsB,mBAAO,CAAC,oFAAyB;AACvD,6BAA6B,mBAAO,CAAC,gEAAe;;;;;;;;;;;;;ACvBvC;;AAEb;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/Ba;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,mBAAO,CAAC,wBAAS;AACjC,iBAAiB,mBAAO,CAAC,8DAAY;AACrC,OAAO,UAAU,GAAG,mBAAO,CAAC,sDAAQ;AACpC,OAAO,cAAc,GAAG,mBAAO,CAAC,gFAAqB;;AAErD;AACA;;AAEA;AACA,mBAAmB;AACnB;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD;AACjD,YAAY,UAAU;AACtB,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,YAAY,yBAAyB;AACrC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,kDAAkD,WAAW;AAC7D;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,EAAE;AACF;;AAEA;;;;;;;;;;;;;AChMA;AACA;AACA;AACa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,OAAO,iBAAiB,GAAG,mBAAO,CAAC,8DAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,sDAAQ;;AAEpB;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,kEAAc;;AAE1B;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,cAAc;AAC1B,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;AACA,uDAAuD,mBAAmB;AAC1E;AACA;AACA;AACA,gDAAgD,uBAAuB;AACvE;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,mBAAmB,4BAA4B;AAC/C;AACA;AACA;;AAEA;;;;;;;;;;;;;ACnLa;;AAEb,wBAAwB,mBAAO,CAAC,4FAA2B;AAC3D,yBAAyB,mBAAO,CAAC,8FAA4B;AAC7D,qBAAqB,mBAAO,CAAC,sFAAwB;AACrD,mCAAmC,mBAAO,CAAC,kHAAsC;AACjF,kCAAkC,mBAAO,CAAC,gHAAqC;AAC/E,qBAAqB,mBAAO,CAAC,sFAAwB;AACrD,uBAAuB,mBAAO,CAAC,0FAA0B;AACzD,wBAAwB,mBAAO,CAAC,4FAA2B;AAC3D,wBAAwB,mBAAO,CAAC,4FAA2B;AAC3D,8BAA8B,mBAAO,CAAC,wGAAiC;AACvE,gBAAgB,mBAAO,CAAC,4EAAmB;AAC3C,OAAO,iBAAiB,GAAG,mBAAO,CAAC,8DAAY;AAC/C,OAAO,8CAA8C,GAAG,mBAAO,CAAC,sDAAQ;;AAExE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB;;AAEA,mCAAmC,iBAAiB;;AAEpD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;AC9EA;AACA;AACA;AACa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,OAAO,iBAAiB,GAAG,mBAAO,CAAC,8DAAY;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,sDAAQ;AACpB;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,kEAAc;;AAE1B;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,cAAc;AAC1B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,cAAc;AAC1B,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,cAAc;AAC1B,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,SAAS;AACvB;AACA;AACA;AACA,WAAW;AACX,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uDAAuD,mBAAmB;AAC1E;AACA;AACA;AACA,gDAAgD,uBAAuB;AACvE;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4BAA4B,OAAO;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACvQA;AACA;AACA;AACa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,uBAAuB,mBAAO,CAAC,8DAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,sDAAQ;AACpB;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,kEAAc;;AAE1B;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,sBAAsB;AAClC,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG,IAAI;;AAEP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB,OAAO;AACP,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,cAAc;AACd;AACA;AACA,oDAAoD;AACpD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,SAAS;AACvB;AACA;AACA;AACA,UAAU;AACV,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC,kCAAkC;AACtE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,2CAA2C,eAAe;AAC1D;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,2CAA2C,eAAe;AAC1D,8CAA8C,eAAe;AAC7D,gDAAgD,eAAe;AAC/D;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AClUa;;AAEb,OAAO,sBAAsB,GAAG,mBAAO,CAAC,sDAAQ;;AAEhD;AACA;AACA,WAAW,SAAS;AACpB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB,GAAG,IAAI;AAC5C,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU,WAAW;AAClC;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChFa;;AAEb,cAAc,mBAAO,CAAC,yDAAU;;AAEhC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC9Ba;;AAEb,cAAc,mBAAO,CAAC,yDAAU;AAChC,wBAAwB,mBAAO,CAAC,oGAA2B;;AAE3D;AACA;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9Da;;AAEb,cAAc,mBAAO,CAAC,yDAAU;AAChC;;AAEA;AACA,MAAM,mBAAO,CAAC,cAAI;AAClB,CAAC;AACD;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,0DAA0D,WAAW;AACrE,CAAC;;AAED,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,oCAAoC,WAAW;AAC/C;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA,YAAY;AACZ,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,mBAAmB;AACxC,oBAAoB,mBAAmB;AACvC;AACA,KAAK,mBAAmB;AACxB;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC3Ea;;AAEb;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;ACba;;AAEb,cAAc,mBAAO,CAAC,yDAAU;AAChC,qBAAqB,mBAAO,CAAC,wFAAqB;AAClD,wBAAwB,mBAAO,CAAC,oGAA2B;;AAE3D;;AAEA,8CAA8C;AAC9C;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACnCa;;AAEb,cAAc,mBAAO,CAAC,yDAAU;AAChC,WAAW,mBAAO,CAAC,cAAI;;AAEvB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA,uCAAuC;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxEa;;AAEb,gBAAgB,mBAAO,CAAC,6DAAY;AACpC;AACA;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrDa;;AAEb,cAAc,mBAAO,CAAC,yDAAU;;AAEhC;;AAEA,uCAAuC;AACvC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACzBa;;AAEb,cAAc,mBAAO,CAAC,yDAAU;AAChC,WAAW,mBAAO,CAAC,cAAI;;AAEvB;;AAEA,uCAAuC;AACvC;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;;;;;;;;;;;;;ACvCa;;AAEb,cAAc,mBAAO,CAAC,yDAAU;AAChC,WAAW,mBAAO,CAAC,cAAI;AACvB,gBAAgB,mBAAO,CAAC,wBAAS;;AAEjC;;AAEA,uCAAuC;AACvC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;;;;;;;;;;;;ACjCa;;AAEb,cAAc,mBAAO,CAAC,yDAAU;;AAEhC;;AAEA,uCAAuC;AACvC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACzBa;;AAEb,cAAc,mBAAO,CAAC,yDAAU;AAChC;;AAEA;;AAEA,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC3Ba;;AAEb,cAAc,mBAAO,CAAC,yDAAU;AAChC;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACvCa;;AAEb,YAAY,mBAAO,CAAC,gBAAK;AACzB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,cAAc,mBAAO,CAAC,oBAAO;AAC7B,OAAO,iBAAiB,GAAG,mBAAO,CAAC,8DAAY;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe,eAAe;AAC/C;AACA,GAAG,EAAE,6BAA6B;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA,EAAE;;AAEF;AACA,mCAAmC,oBAAoB;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wBAAwB,GAAG,mCAAmC;AAC5E;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACjGa;AACb,OAAO,mBAAmB,GAAG,mBAAO,CAAC,sDAAQ;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;AACA,yBAAyB,KAAK,GAAG,wBAAwB;AACzD,yBAAyB,KAAK,GAAG,UAAU;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,IAAI,IAAI,kCAAkC;AAC3D;;AAEA;AACA;AACA,oBAAoB,EAAE,wCAAwC;AAC9D;;AAEA,iBAAiB,WAAW,GAAG,4BAA4B;AAC3D;AACA,gBAAgB,cAAc;AAC9B;AACA,gBAAgB,YAAY;AAC5B;;AAEA,YAAY,KAAK,IAAI,KAAK,IAAI,OAAO;AACrC;;AAEA;AACA;;AAEA;AACA,iBAAiB,+CAA+C;AAChE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,cAAc;AAC5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,eAAe;AACpC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACzJA;AACA;AACA;AACa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,OAAO,iBAAiB,GAAG,mBAAO,CAAC,8DAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,sDAAQ;AACpB;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,kEAAc;AAC1B,4BAA4B,mBAAO,CAAC,oFAAuB;;AAE3D;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,sBAAsB;AAClC,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,cAAc;AACd;AACA;AACA,oDAAoD;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,SAAS;AACvB;AACA;AACA;AACA,UAAU;AACV,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,uBAAuB;AACjD;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC,kCAAkC;AACtE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC3Ra;;AAEb,OAAO,UAAU,GAAG,mBAAO,CAAC,kDAAS;;AAErC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC7Da;;AAEb;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF,YAAY,MAAM;AAClB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE,IAAI;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA,OAAO,cAAc;AACrB,aAAa,QAAQ,GAAG,gBAAgB;AACxC;AACA,YAAY,QAAQ,GAAG,gBAAgB;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+FAA+F,YAAY,QAAQ,EAAE;AACrH;AACA;;AAEA;AACA;AACA;AACA,YAAY,EAAE;AACd,YAAY,EAAE;AACd,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACpIa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;;AAE3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,MAAM,yCAAyC;AACnE;AACA,MAAM;AACN;AACA;AACA,EAAE;AACF;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAO,CAAC,kDAAU;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA,6BAA6B;AAC7B,yCAAyC,gBAAgB,EAAE;AAC3D,KAAK;AACL,yCAAyC,cAAc,mBAAmB,EAAE,EAAE;AAC9E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO,EAAE;AACnD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,oCAAoC;AACpC,KAAK;AACL,yCAAyC;AACzC,KAAK;AACL,+CAA+C;AAC/C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO,EAAE;AACnD,4BAA4B;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,eAAe,EAAE;AAC3D;AACA,4BAA4B;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AC3YA,oC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,+B;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,kC;;;;;;;;;;;ACAA,oC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,+B","file":"opossum.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"circuitBreaker\"] = factory();\n\telse\n\t\troot[\"circuitBreaker\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./index.js\");\n","'use strict';\n\nconst CircuitBreaker = require('./lib/circuit');\nconst circuits = [];\n\nconst defaults = {\n  timeout: 10000, // 10 seconds\n  errorThresholdPercentage: 50,\n  resetTimeout: 30000 // 30 seconds\n};\n\n/**\n * Creates a {@link CircuitBreaker} instance capable of executing `action`.\n *\n * @param {Function} action The action to fire for this {@link CircuitBreaker}\n * @param {Object} options Options for the {@link CircuitBreaker}\n * @param {Number} options.timeout The time in milliseconds that action should\n * be allowed to execute before timing out. Default 10000 (10 seconds)\n * @param {Number} options.maxFailures (Deprecated) The number of times the\n * circuit can fail before opening. Default 10.\n * @param {Number} options.resetTimeout The time in milliseconds to wait before\n * setting the breaker to `halfOpen` state, and trying the action again.\n * Default: 30000 (30 seconds)\n * @param {Number} options.rollingCountTimeout Sets the duration of the\n * statistical rolling window, in milliseconds. This is how long Opossum keeps\n * metrics for the circuit breaker to use and for publishing. Default: 10000\n * @param {Number} options.rollingCountBuckets Sets the number of buckets the\n * rolling statistical window is divided into. So, if\n * options.rollingCountTimeout is 10000, and options.rollingCountBuckets is 10,\n * then the statistical window will be 1000 1 second snapshots in the\n * statistical window. Default: 10\n * @param {String} options.name the circuit name to use when reporting stats.\n * Default: the name of the function this circuit controls.\n * @param {boolean} options.rollingPercentilesEnabled This property indicates\n * whether execution latencies should be tracked and calculated as percentiles.\n * If they are disabled, all summary statistics (mean, percentiles) are\n * returned as -1. Default: false\n * @param {Number} options.capacity the number of concurrent requests allowed.\n * If the number currently executing function calls is equal to\n * options.capacity, further calls to `fire()` are rejected until at least one\n * of the current requests completes. Default: `Number.MAX_SAFE_INTEGER`.\n * @param {Number} options.errorThresholdPercentage the error percentage at\n * which to open the circuit and start short-circuiting requests to fallback.\n * Default: 50\n * @param {boolean} options.enabled whether this circuit is enabled upon\n * construction. Default: true\n * @param {boolean} options.allowWarmUp determines whether to allow failures\n * without opening the circuit during a brief warmup period (this is the\n * `rollingCountDuration` property). Default: false\n * allow before enabling the circuit. This can help in situations where no\n * matter what your `errorThresholdPercentage` is, if the first execution\n * times out or fails, the circuit immediately opens. Default: 0\n * @param {Number} options.volumeThreshold the minimum number of requests within\n * the rolling statistical window that must exist before the circuit breaker\n * can open. This is similar to `options.allowWarmUp` in that no matter how many\n * failures there are, if the number of requests within the statistical window\n * does not exceed this threshold, the circuit will remain closed. Default: 0\n * @param {Function} options.errorFilter an optional function that will be\n * called when the circuit's function fails (returns a rejected Promise). If\n * this function returns truthy, the circuit's failure statistics will not be\n * incremented. This is useful, for example, when you don't want HTTP 404 to\n * trip the circuit, but still want to handle it as a failure case.\n\n * @return {CircuitBreaker} a newly created {@link CircuitBreaker} instance\n */\nfunction factory (action, options) {\n  const circuit = new CircuitBreaker(action,\n    Object.assign({}, defaults, options));\n  circuits.push(circuit);\n  return circuit;\n}\n\n/**\n * Given a function that receives a callback as its last argument,\n * and which executes that function, passing as parameters `err` and `result`,\n * creates an action that returns a promise which resolves when the function's\n * callback is executed.\n * @function factory.promisify\n *\n * @param {Function} action A Node.js-like asynchronous function\n * @example\n *     const fs = require('fs');\n *     const readFilePromised = circuitBreaker.promisify(fs.readFile);\n *     const breaker = circuitBreaker(readFilePromised);\n */\nfactory.promisify = require('./lib/promisify');\n\n/**\n * Get the Prometheus metrics for all circuits.\n * @function factory.metrics\n * @return {String} the metrics for all circuits\n */\nfactory.metrics = function metrics() {\n  // Just get the metrics for the last circuit that was created\n  // since prom-client is additive\n  const lastCircuit = circuits[circuits.length - 1];\n  if (lastCircuit && lastCircuit.metrics)\n    return lastCircuit.metrics.metrics;\n}\n\nlet warningIssued = false;\nObject.defineProperty(factory, 'stats', {\n  get: _ => {\n    if (!warningIssued) {\n      warningIssued = true;\n      console.warn(`WARNING: Hystrics stats are deprecated\n      See: https://github.com/Netflix/Hystrix#dashboard`)\n    }\n    return require('./lib/hystrix-stats').stream;\n  }\n});\n\nmodule.exports = exports = factory;\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = factory;\n","'use strict';\n\nconst EventEmitter = require('events');\nconst Status = require('./status');\nconst HystrixStats = require('./hystrix-stats');\nconst Semaphore = require('./semaphore');\nlet PrometheusMetrics;\nif (!process.env.WEB) {\n  PrometheusMetrics = require('./prometheus-metrics');\n}\n\nconst STATE = Symbol('state');\nconst OPEN = Symbol('open');\nconst CLOSED = Symbol('closed');\nconst HALF_OPEN = Symbol('half-open');\nconst PENDING_CLOSE = Symbol('pending-close');\nconst SHUTDOWN = Symbol('shutdown');\nconst FALLBACK_FUNCTION = Symbol('fallback');\nconst STATUS = Symbol('status');\nconst NAME = Symbol('name');\nconst GROUP = Symbol('group');\nconst HYSTRIX_STATS = Symbol('hystrix-stats');\nconst PROMETHEUS_METRICS = Symbol('prometheus-metrics');\nconst CACHE = new WeakMap();\nconst ENABLED = Symbol('Enabled');\nconst WARMING_UP = Symbol('warming-up');\nconst VOLUME_THRESHOLD = Symbol('volume-threshold');\nconst deprecation = `options.maxFailures is deprecated. \\\nPlease use options.errorThresholdPercentage`;\n\nlet warningIssued = false;\n\n\n/**\n * Constructs a {@link CircuitBreaker}.\n *\n * @class CircuitBreaker\n * @extends EventEmitter\n * @param {Function} action The action to fire for this {@link CircuitBreaker}\n * @param {Object} options Options for the {@link CircuitBreaker}\n * @param {Number} options.timeout The time in milliseconds that action should\n * be allowed to execute before timing out. Default 10000 (10 seconds)\n * @param {Number} options.maxFailures (Deprecated) The number of times the\n * circuit can fail before opening. Default 10.\n * @param {Number} options.resetTimeout The time in milliseconds to wait before\n * setting the breaker to `halfOpen` state, and trying the action again.\n * Default: 30000 (30 seconds)\n * @param {Number} options.rollingCountTimeout Sets the duration of the\n * statistical rolling window, in milliseconds. This is how long Opossum keeps\n * metrics for the circuit breaker to use and for publishing. Default: 10000\n * @param {Number} options.rollingCountBuckets Sets the number of buckets the\n * rolling statistical window is divided into. So, if\n * options.rollingCountTimeout is 10000, and options.rollingCountBuckets is 10,\n * then the statistical window will be 1000 1 second snapshots in the\n * statistical window. Default: 10\n * @param {String} options.name the circuit name to use when reporting stats.\n * Default: the name of the function this circuit controls.\n * @param {boolean} options.rollingPercentilesEnabled This property indicates\n * whether execution latencies should be tracked and calculated as percentiles.\n * If they are disabled, all summary statistics (mean, percentiles) are\n * returned as -1. Default: false\n * @param {Number} options.capacity the number of concurrent requests allowed.\n * If the number currently executing function calls is equal to\n * options.capacity, further calls to `fire()` are rejected until at least one\n * of the current requests completes. Default: `Number.MAX_SAFE_INTEGER`.\n * @param {Number} options.errorThresholdPercentage the error percentage at\n * which to open the circuit and start short-circuiting requests to fallback.\n * Default: 50\n * @param {boolean} options.enabled whether this circuit is enabled upon\n * construction. Default: true\n * @param {boolean} options.allowWarmUp determines whether to allow failures\n * without opening the circuit during a brief warmup period (this is the\n * `rollingCountDuration` property). Default: false\n * allow before enabling the circuit. This can help in situations where no\n * matter what your `errorThresholdPercentage` is, if the first execution\n * times out or fails, the circuit immediately opens. Default: 0\n * @param {Number} options.volumeThreshold the minimum number of requests within\n * the rolling statistical window that must exist before the circuit breaker\n * can open. This is similar to `options.allowWarmUp` in that no matter how many\n * failures there are, if the number of requests within the statistical window\n * does not exceed this threshold, the circuit will remain closed. Default: 0\n * @param {Function} options.errorFilter an optional function that will be\n * called when the circuit's function fails (returns a rejected Promise). If\n * this function returns truthy, the circuit's failure statistics will not be\n * incremented. This is useful, for example, when you don't want HTTP 404 to\n * trip the circuit, but still want to handle it as a failure case.\n *\n * @fires CircuitBreaker#halfOpen\n * @fires CircuitBreaker#close\n * @fires CircuitBreaker#open\n * @fires CircuitBreaker#fire\n * @fires CircuitBreaker#cacheHit\n * @fires CircuitBreaker#cacheMiss\n * @fires CircuitBreaker#reject\n * @fires CircuitBreaker#timeout\n * @fires CircuitBreaker#success\n * @fires CircuitBreaker#semaphore-locked\n * @fires CircuitBreaker#health-check-failed\n * @fires CircuitBreaker#fallback\n * @fires CircuitBreaker#failure\n */\nclass CircuitBreaker extends EventEmitter {\n  constructor (action, options) {\n    super();\n    this.options = options;\n    this.options.rollingCountTimeout = options.rollingCountTimeout || 10000;\n    this.options.rollingCountBuckets = options.rollingCountBuckets || 10;\n    this.options.rollingPercentilesEnabled =\n      options.rollingPercentilesEnabled !== false;\n    this.options.capacity = Number.isInteger(options.capacity)\n      ? options.capacity : Number.MAX_SAFE_INTEGER;\n    this.options.errorFilter = options.errorFilter || (_ => false);\n\n    this.semaphore = new Semaphore(this.options.capacity);\n\n    this[VOLUME_THRESHOLD] = Number.isInteger(options.volumeThreshold)\n      ? options.volumeThreshold : 0;\n    this[WARMING_UP] = options.allowWarmUp === true;\n    this[STATUS] = new Status(this.options);\n    this[STATE] = CLOSED;\n    this[FALLBACK_FUNCTION] = null;\n    this[PENDING_CLOSE] = false;\n    this[NAME] = options.name || action.name || nextName();\n    this[GROUP] = options.group || this[NAME];\n    this[ENABLED] = options.enabled !== false;\n\n    if (this[WARMING_UP]) {\n      const timer = setTimeout(_ => (this[WARMING_UP] = false),\n        this.options.rollingCountTimeout);\n      if (typeof timer.unref === 'function') {\n        timer.unref();\n      }\n    }\n\n    if (typeof action !== 'function') {\n      this.action = _ => Promise.resolve(action);\n    } else this.action = action;\n\n    if (options.maxFailures) console.error(deprecation);\n\n    const increment = property =>\n      (result, runTime) => this[STATUS].increment(property, runTime);\n\n    this.on('success', increment('successes'));\n    this.on('failure', increment('failures'));\n    this.on('fallback', increment('fallbacks'));\n    this.on('timeout', increment('timeouts'));\n    this.on('fire', increment('fires'));\n    this.on('reject', increment('rejects'));\n    this.on('cacheHit', increment('cacheHits'));\n    this.on('cacheMiss', increment('cacheMisses'));\n    this.on('open', _ => this[STATUS].open());\n    this.on('close', _ => this[STATUS].close());\n    this.on('semaphoreLocked', increment('semaphoreRejections'));\n\n    /**\n     * Emitted after `options.resetTimeout` has elapsed, allowing for\n     * a single attempt to call the service again. If that attempt is\n     * successful, the circuit will be closed. Otherwise it remains open.\n     *\n     * @event CircuitBreaker#halfOpen\n     * @type {Number} how long the circuit remained open\n     */\n\n    function _startTimer (circuit) {\n      return _ => {\n        const timer = setTimeout(() => {\n          circuit[STATE] = HALF_OPEN;\n          circuit[PENDING_CLOSE] = true;\n          circuit.emit('halfOpen', circuit.options.resetTimeout);\n        }, circuit.options.resetTimeout);\n        if (typeof timer.unref === 'function') {\n          timer.unref();\n        }\n      };\n    }\n\n    this.on('open', _startTimer(this));\n    this.on('success', _ => this.close());\n    if (this.options.cache) {\n      CACHE.set(this, undefined);\n    }\n\n    // Register with the hystrix stats listener\n    this[HYSTRIX_STATS] = new HystrixStats(this);\n\n    // Add Prometheus metrics if not running in a web env\n    if (PrometheusMetrics && options.usePrometheus) {\n      this[PROMETHEUS_METRICS] = new PrometheusMetrics(this);\n    }\n  }\n\n  /**\n   * Closes the breaker, allowing the action to execute again\n   * @fires CircuitBreaker#close\n   * @returns {void}\n   */\n  close () {\n    this[PENDING_CLOSE] = false;\n    if (this[STATE] !== CLOSED) {\n      this[STATE] = CLOSED;\n      /**\n       * Emitted when the breaker is reset allowing the action to execute again\n       * @event CircuitBreaker#close\n       */\n      this.emit('close');\n    }\n  }\n\n  /**\n   * Opens the breaker. Each time the breaker is fired while the circuit is\n   * opened, a failed Promise is returned, or if any fallback function\n   * has been provided, it is invoked.\n   * @fires CircuitBreaker#open\n   * @returns {void}\n   */\n  open () {\n    this[PENDING_CLOSE] = false;\n    if (this[STATE] !== OPEN) {\n      this[STATE] = OPEN;\n      /**\n       * Emitted when the breaker opens because the action has\n       * failed more than `options.maxFailures` number of times.\n       * @event CircuitBreaker#open\n       */\n      this.emit('open');\n    }\n  }\n\n  /**\n   * Shuts down this circuit breaker. All subsequent calls to the\n   * circuit will fail, returning a rejected promise.\n   * @returns {void}\n   */\n  shutdown () {\n    this.disable();\n    this.removeAllListeners();\n    this.status.shutdown();\n    this.hystrixStats.shutdown();\n    this.metrics && this.metrics.clear();\n    this[STATE] = SHUTDOWN;\n  }\n\n  /**\n   * Determines if the circuit has been shutdown.\n   * @type {Boolean}\n   */\n  get isShutdown () {\n    return this[STATE] === SHUTDOWN;\n  }\n\n  /**\n   * Gets the name of this circuit\n   * @type {String}\n   */\n  get name () {\n    return this[NAME];\n  }\n\n  /**\n   * Gets the name of this circuit group\n   * @type {String}\n   */\n  get group () {\n    return this[GROUP];\n  }\n\n  /**\n   * Gets whether this cicruit is in the `pendingClosed` state\n   * @type {Boolean}\n   */\n  get pendingClose () {\n    return this[PENDING_CLOSE];\n  }\n\n  /**\n   * True if the circuit is currently closed. False otherwise.\n   * @type {Boolean}\n   */\n  get closed () {\n    return this[STATE] === CLOSED;\n  }\n\n  /**\n   * True if the circuit is currently opened. False otherwise.\n   * @type {Boolean}\n   */\n  get opened () {\n    return this[STATE] === OPEN;\n  }\n\n  /**\n   * True if the circuit is currently half opened. False otherwise.\n   * @type {Boolean}\n   */\n  get halfOpen () {\n    return this[STATE] === HALF_OPEN;\n  }\n\n  /**\n   * The current {@link Status} of this {@link CircuitBreaker}\n   * @type {Status}\n   */\n  get status () {\n    return this[STATUS];\n  }\n\n  /**\n   * Get the current stats for the circuit.\n   * @see Status#stats\n   * @type {Object}\n   */\n  get stats () {\n    return this[STATUS].stats;\n  }\n\n  /**\n   * Get the hystrixStats.\n   * @type {HystrixStats}\n   */\n  get hystrixStats () {\n    if (!warningIssued) {\n      warningIssued = true;\n      console.warn(`WARNING: Hystrics stats are deprecated\n      See: https://github.com/Netflix/Hystrix#dashboard`)\n    }\n    return this[HYSTRIX_STATS];\n  }\n\n  /**\n   * Get the prometheus metrics for this circuit\n   * @type {PrometheusMetrics}\n   */\n  get metrics () {\n    return this[PROMETHEUS_METRICS];\n  }\n\n  /**\n   * Gets whether the circuit is enabled or not\n   * @type {Boolean}\n   */\n  get enabled () {\n    return this[ENABLED];\n  }\n\n  /**\n   * Gets whether the circuit is currently in warm up phase\n   * @type {Boolean}\n   */\n  get warmUp () {\n    return this[WARMING_UP];\n  }\n\n  /**\n   * Gets the volume threshold for this circuit\n   * @type {Boolean}\n   */\n  get volumeThreshold () {\n    return this[VOLUME_THRESHOLD];\n  }\n\n  /**\n   * Provide a fallback function for this {@link CircuitBreaker}. This\n   * function will be executed when the circuit is `fire`d and fails.\n   * It will always be preceded by a `failure` event, and `breaker.fire` returns\n   * a rejected Promise.\n   * @param {Function | CircuitBreaker} func the fallback function to execute\n   * when the breaker has opened or when a timeout or error occurs.\n   * @return {CircuitBreaker} this\n   */\n  fallback (func) {\n    let fb = func;\n    if (func instanceof CircuitBreaker) {\n      fb = function () {\n        return func.fire.apply(func, arguments);\n      };\n    }\n    this[FALLBACK_FUNCTION] = fb;\n    return this;\n  }\n\n  /**\n   * Execute the action for this circuit. If the action fails or times out, the\n   * returned promise will be rejected. If the action succeeds, the promise will\n   * resolve with the resolved value from action. If a fallback function was\n   * provided, it will be invoked in the event of any failure or timeout.\n   *\n   * @return {Promise<any>} promise resolves with the circuit function's return\n   * value on success or is rejected on failure of the action.\n   *\n   * @fires CircuitBreaker#failure\n   * @fires CircuitBreaker#fallback\n   * @fires CircuitBreaker#fire\n   * @fires CircuitBreaker#reject\n   * @fires CircuitBreaker#success\n   * @fires CircuitBreaker#timeout\n   * @fires CircuitBreaker#semaphoreLocked\n   */\n  fire () {\n    if (this.isShutdown) {\n      const err = new Error('The circuit has been shutdown.');\n      err.code = 'ESHUTDOWN';\n      return Promise.reject(err);\n    }\n    const args = Array.prototype.slice.call(arguments);\n\n    /**\n     * Emitted when the circuit breaker action is executed\n     * @event CircuitBreaker#fire\n     * @type {any} the arguments passed to the fired fuction\n     */\n    this.emit('fire', args);\n\n    if (CACHE.get(this) !== undefined) {\n      /**\n       * Emitted when the circuit breaker is using the cache\n       * and finds a value.\n       * @event CircuitBreaker#cacheHit\n       */\n      this.emit('cacheHit');\n      return CACHE.get(this);\n    } else if (this.options.cache) {\n      /**\n       * Emitted when the circuit breaker does not find a value in\n       * the cache, but the cache option is enabled.\n       * @event CircuitBreaker#cacheMiss\n       */\n      this.emit('cacheMiss');\n    }\n\n    if (!this[ENABLED]) {\n      const result = this.action.apply(this.action, args);\n      return (typeof result.then === 'function')\n        ? result\n        : Promise.resolve(result);\n    }\n\n    if (!this.closed && !this.pendingClose) {\n      /**\n       * Emitted when the circuit breaker is open and failing fast\n       * @event CircuitBreaker#reject\n       * @type {Error}\n       */\n      const error = new Error('Breaker is open');\n      error.code = 'EOPENBREAKER';\n\n      this.emit('reject', error);\n\n      return fallback(this, error, args) ||\n        Promise.reject(error);\n    }\n    this[PENDING_CLOSE] = false;\n\n    let timeout;\n    let timeoutError = false;\n    return new Promise((resolve, reject) => {\n      const latencyStartTime = Date.now();\n      if (this.semaphore.test()) {\n        if (this.options.timeout) {\n          timeout = setTimeout(\n            () => {\n              timeoutError = true;\n              const error =\n                new Error(`Timed out after ${this.options.timeout}ms`);\n              error.code = 'ETIMEDOUT';\n              /**\n               * Emitted when the circuit breaker action takes longer than\n               * `options.timeout`\n               * @event CircuitBreaker#timeout\n               * @type {Error}\n               */\n              const latency = Date.now() - latencyStartTime;\n              this.semaphore.release();\n              this.emit('timeout', error, latency, args);\n              resolve(handleError(\n                error, this, timeout, args, latency, resolve, reject));\n            }, this.options.timeout);\n        }\n\n        try {\n          const result = this.action.apply(this.action, args);\n          const promise = (typeof result.then === 'function')\n            ? result\n            : Promise.resolve(result);\n\n          promise.then(result => {\n            if (!timeoutError) {\n              clearTimeout(timeout);\n              /**\n               * Emitted when the circuit breaker action succeeds\n               * @event CircuitBreaker#success\n               * @type {any} the return value from the circuit\n               */\n              this.emit('success', result, (Date.now() - latencyStartTime));\n              this.semaphore.release();\n              resolve(result);\n              if (this.options.cache) {\n                CACHE.set(this, promise);\n              }\n            }\n          })\n            .catch(error => {\n              if (!timeoutError) {\n                this.semaphore.release();\n                const latencyEndTime = Date.now() - latencyStartTime;\n                handleError(\n                  error, this, timeout, args, latencyEndTime, resolve, reject);\n              }\n            });\n        } catch (error) {\n          this.semaphore.release();\n          const latency = Date.now() - latencyStartTime;\n          handleError(error, this, timeout, args, latency, resolve, reject);\n        }\n      } else {\n        const latency = Date.now() - latencyStartTime;\n        const err = new Error('Semaphore locked');\n        err.code = 'ESEMLOCKED';\n        /**\n         * Emitted when the rate limit has been reached and there\n         * are no more locks to be obtained.\n         * @event CircuitBreaker#semaphoreLocked\n         * @type {Error}\n         */\n        this.emit('semaphoreLocked', err, latency);\n        handleError(err, this, timeout, args, latency, resolve, reject);\n      }\n    });\n  }\n\n  /**\n   * Clears the cache of this {@link CircuitBreaker}\n   * @returns {void}\n   */\n  clearCache () {\n    CACHE.set(this, undefined);\n  }\n\n  /**\n   * Provide a health check function to be called periodically. The function\n   * should return a Promise. If the promise is rejected the circuit will open.\n   * This is in addition to the existing circuit behavior as defined by\n   * `options.errorThresholdPercentage` in the constructor. For example, if the\n   * health check function provided here always returns a resolved promise, the\n   * circuit can still trip and open if there are failures exceeding the\n   * configured threshold. The health check function is executed within the\n   * circuit breaker's execution context, so `this` within the function is the\n   * circuit breaker itself.\n   *\n   * @param {Function} func a health check function which returns a promise.\n   * @param {Number} [interval] the amount of time between calls to the health\n   * check function. Default: 5000 (5 seconds)\n   *\n   * @returns {void}\n   *\n   * @fires CircuitBreaker#healthCheckFailed\n   * @throws {TypeError} if `interval` is supplied but not a number\n   */\n  healthCheck (func, interval) {\n    interval = interval || 5000;\n    if (typeof func !== 'function') {\n      throw new TypeError('Health check function must be a function');\n    }\n    if (isNaN(interval)) {\n      throw new TypeError('Health check interval must be a number');\n    }\n\n    const check = _ => {\n      func.apply(this).catch(e => {\n        /**\n         * Emitted with the user-supplied health check function\n         * returns a rejected promise.\n         * @event CircuitBreaker#healthCheckFailed\n         * @type {Error}\n         */\n        this.emit('healthCheckFailed', e);\n        this.open();\n      });\n    };\n\n    const timer = setInterval(check, interval);\n    if (typeof timer.unref === 'function') {\n      timer.unref();\n    }\n\n    check();\n  }\n\n  /**\n   * Enables this circuit. If the circuit is the  disabled\n   * state, it will be re-enabled. If not, this is essentially\n   * a noop.\n   * @returns {void}\n   */\n  enable () {\n    this[ENABLED] = true;\n  }\n\n  /**\n   * Disables this circuit, causing all calls to the circuit's function\n   * to be executed without circuit or fallback protection.\n   * @returns {void}\n   */\n  disable () {\n    this[ENABLED] = false;\n  }\n}\n\nfunction handleError (error, circuit, timeout, args, latency, resolve, reject) {\n  clearTimeout(timeout);\n  fail(circuit, error, args, latency);\n  const fb = fallback(circuit, error, args);\n  if (fb) resolve(fb);\n  else reject(error);\n}\n\nfunction fallback (circuit, err, args) {\n  if (circuit[FALLBACK_FUNCTION]) {\n    const result =\n      circuit[FALLBACK_FUNCTION]\n        .apply(circuit[FALLBACK_FUNCTION], [...args, err]);\n    /**\n     * Emitted when the circuit breaker executes a fallback function\n     * @event CircuitBreaker#fallback\n     * @type {any} the return value of the fallback function\n     */\n    circuit.emit('fallback', result, err);\n    if (result instanceof Promise) return result;\n    return Promise.resolve(result);\n  }\n}\n\nfunction fail (circuit, err, args, latency) {\n  if (circuit.options.errorFilter(err)) return;\n\n  /**\n   * Emitted when the circuit breaker action fails\n   * @event CircuitBreaker#failure\n   * @type {Error}\n   */\n  circuit.emit('failure', err, latency, args);\n  if (circuit.warmUp) return;\n\n  // check stats to see if the circuit should be opened\n  const stats = circuit.stats;\n  if ((stats.fires < circuit.volumeThreshold) && !circuit.halfOpen) return;\n  const errorRate = stats.failures / stats.fires * 100;\n  if (errorRate > circuit.options.errorThresholdPercentage ||\n    stats.failures >= circuit.options.maxFailures ||\n    circuit.halfOpen) {\n    circuit.open();\n  }\n}\n\n// http://stackoverflow.com/a/2117523\nconst nextName = () =>\n  'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n\nmodule.exports = exports = CircuitBreaker;\n","'use strict';\n\n/* eslint max-len: [\"error\", { \"ignoreUrls\": true }] */\n\n// Data reference:\n// https://github.com/Netflix/Hystrix/wiki/Metrics-and-Monitoring#metrics-publisher\n// A function to map our stats data to the hystrix format\n// returns JSON\nfunction hystrixFormatter (stats) {\n  return {\n    type: 'HystrixCommand',\n    name: stats.name,\n    group: stats.group,\n    currentTime: Date.now(),\n    isCircuitBreakerOpen: !stats.closed,\n    errorPercentage:\n      stats.fires === 0 ? 0 : (stats.failures / stats.fires) * 100,\n    errorCount: stats.failures,\n    requestCount: stats.fires,\n    rollingCountBadRequests: stats.failures,\n    rollingCountCollapsedRequests: 0,\n    rollingCountEmit: stats.fires,\n    rollingCountExceptionsThrown: 0,\n    rollingCountFailure: stats.failures,\n    rollingCountFallbackEmit: stats.fallbacks,\n    rollingCountFallbackFailure: 0,\n    rollingCountFallbackMissing: 0,\n    rollingCountFallbackRejection: 0,\n    rollingCountFallbackSuccess: 0,\n    rollingCountResponsesFromCache: stats.cacheHits,\n    rollingCountSemaphoreRejected: stats.semaphoreRejections,\n    rollingCountShortCircuited: stats.rejects,\n    rollingCountSuccess: stats.successes,\n    rollingCountThreadPoolRejected: 0,\n    rollingCountTimeout: stats.timeouts,\n    currentConcurrentExecutionCount: 0,\n    rollingMaxConcurrentExecutionCount: 0,\n    // TODO: calculate these latency values\n    latencyExecute_mean: stats.latencyMean || 0,\n    latencyExecute: percentiles(stats),\n    // Whats the difference between execute and total?\n    latencyTotal_mean: stats.latencyMean,\n    latencyTotal: percentiles(stats),\n    propertyValue_circuitBreakerRequestVolumeThreshold: 5,\n    propertyValue_circuitBreakerSleepWindowInMilliseconds:\n      stats.options.resetTimeout,\n    propertyValue_circuitBreakerErrorThresholdPercentage:\n      stats.options.errorThresholdPercentage,\n    propertyValue_circuitBreakerForceOpen: false,\n    propertyValue_circuitBreakerForceClosed: false,\n    propertyValue_circuitBreakerEnabled: true,\n    propertyValue_executionIsolationStrategy: 'THREAD',\n    propertyValue_executionIsolationThreadTimeoutInMilliseconds: 300,\n    propertyValue_executionTimeoutInMilliseconds: stats.options.timeout,\n    propertyValue_executionIsolationThreadInterruptOnTimeout: true,\n    propertyValue_executionIsolationThreadPoolKeyOverride: null,\n    propertyValue_executionIsolationSemaphoreMaxConcurrentRequests:\n      stats.options.capacity,\n    propertyValue_fallbackIsolationSemaphoreMaxConcurrentRequests:\n      stats.options.capacity,\n    propertyValue_metricsRollingStatisticalWindowInMilliseconds: 10000,\n    propertyValue_requestCacheEnabled: stats.options.cache || false,\n    propertyValue_requestLogEnabled: true,\n    reportingHosts: 1\n  };\n}\n\nfunction percentiles (stats) {\n  return {\n    0: stats.percentiles['0'],\n    25: stats.percentiles['0.25'],\n    50: stats.percentiles['0.5'],\n    75: stats.percentiles['0.75'],\n    90: stats.percentiles['0.9'],\n    95: stats.percentiles['0.95'],\n    99: stats.percentiles['0.99'],\n    99.5: stats.percentiles['0.995'],\n    100: stats.percentiles['1']\n  };\n}\n\nmodule.exports = exports = hystrixFormatter;\n","'use strict';\n\nconst { Transform, Readable } = require('stream');\nconst formatter = require('./hystrix-formatter');\n\n// use a single hystrix stream for all circuits\nconst hystrixStream = new Transform({\n  objectMode: true,\n  transform (stats, encoding, cb) {\n    return cb(null, `data: ${JSON.stringify(formatter(stats))}\\n\\n`);\n  }\n});\n\nhystrixStream.resume();\n\n/**\n * Stream Hystrix Metrics for a given {@link CircuitBreaker}.\n * A HystrixStats instance is created for every {@link CircuitBreaker}\n * and does not typically need to be created by a user.\n *\n * A HystrixStats instance will listen for all events on the\n * {@link Status#snapshot}\n * and format the data to the proper Hystrix format.\n * Making it easy to construct an Event Stream for a client\n *\n * @class HystrixStats\n * @example\n * const circuit = circuitBreaker(fs.readFile, {});\n *\n * circuit.hystrixStats.getHystrixStream().pipe(response);\n * @param {CircuitBreaker} the circuit breaker\n * @see CircuitBreaker#hystrixStats\n */\nclass HystrixStats {\n  constructor (circuit) {\n    this._readableStream = new Readable({\n      objectMode: true,\n      read () {}\n    });\n\n    // Listen for the stats's snapshot event\n    circuit.status.on('snapshot', function snapshotListener (stats) {\n      // when we get a snapshot push it onto the stream\n      this._readableStream.push(\n        Object.assign({},\n          {\n            name: circuit.name,\n            closed: circuit.closed,\n            group: circuit.group,\n            options: circuit.options\n          }, stats));\n    }.bind(this));\n\n    this._readableStream.resume();\n    this._readableStream.pipe(hystrixStream);\n  }\n\n  /**\n    A convenience function that returns the hystrixStream\n    @returns {ReadableStream} the statistics stream\n  */\n  getHystrixStream () {\n    return hystrixStream;\n  }\n\n  /**\n   * Shuts down this instance, freeing memory.\n   * When a circuit is shutdown, it should call shutdown() on\n   * its HystrixStats instance to avoid memory leaks.\n   * @returns {void}\n   */\n  shutdown () {\n    this._readableStream.unpipe(hystrixStream);\n  }\n}\n\nHystrixStats.stream = hystrixStream;\n\nmodule.exports = exports = HystrixStats;\n","'use strict';\n\nconst client = require('prom-client');\n\n// The current tests has circuit names like:\n// 'circuit one' (with blank space) and others like\n// 3beb8f49-62c0-46e0-b458-dcd4a62d0f48.\n// So to avoid \"Error: Invalid metric name\" we are changing the\n// circuit name to pass the tests.\n// More details:\n// https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels\nfunction normalizePrefix(prefixName) {\n  return `circuit_${prefixName.replace(/[ |-]/g, '_')}_`;\n}\n\nclass PrometheusMetrics {\n  constructor (circuit) {\n    this.circuit = circuit;\n    this._client = client;\n    this.counters = [];\n    const prefix = normalizePrefix(this.circuit.name);\n\n    this.interval = this._client\n      .collectDefaultMetrics({ prefix, timeout: 5000 });\n\n    for (let eventName of this.circuit.eventNames()) {\n      const counter = new this._client.Counter({\n        name: `${prefix}${eventName}`,\n        help: `A count of the ${circuit.name} circuit's ${eventName} event`\n      });\n      this.circuit.on(eventName, _ => {\n        counter.inc();\n      });\n      this.counters.push(counter);\n    }\n  }\n\n  clear () {\n    clearInterval(this.interval);\n    this._client.register.clear();\n  }\n\n  get metrics () {\n    return this._client.register.metrics();\n  }\n\n  get client () {\n    return this._client;\n  }\n}\n\nmodule.exports = PrometheusMetrics;\n","'use strict';\n\nmodule.exports = exports = function promisify (func) {\n  return function promisifiedFunction () {\n    return new Promise((resolve, reject) => {\n      const cb = (err, result) => {\n        if (err) reject(err);\n        resolve(result);\n      };\n      const args = Array.prototype.slice.call(arguments);\n      args.push(cb);\n      func.apply(func, args);\n    });\n  };\n};\n","'use strict';\n\nmodule.exports = exports = semaphore;\n\nfunction semaphore (count) {\n  const resolvers = [];\n  let counter = count;\n\n  let sem = {\n    take,\n    release,\n    test\n  };\n\n  Object.defineProperty(sem, 'count', {\n    get: _ => counter,\n    enumerable: true\n  });\n\n  return sem;\n\n  function take (timeout) {\n    if (counter > 0) {\n      --counter;\n      return Promise.resolve(release);\n    }\n    return new Promise((resolve, reject) => {\n      resolvers.push(_ => {\n        --counter;\n        resolve(release);\n      });\n      if (timeout) {\n        setTimeout(_ => {\n          resolvers.shift();\n          const err = new Error(`Timed out after ${timeout}ms`);\n          err.code = 'ETIMEDOUT';\n          reject(err);\n        }, timeout);\n      }\n    });\n  }\n\n  function release () {\n    counter++;\n    if (resolvers.length > 0) {\n      resolvers.shift()();\n    }\n  }\n\n  function test () {\n    if (counter < 1) return false;\n    return take() && true;\n  }\n}\n","'use strict';\n\nconst WINDOW = Symbol('window');\nconst BUCKETS = Symbol('buckets');\nconst TIMEOUT = Symbol('timeout');\nconst PERCENTILES = Symbol('percentiles');\n\nconst EventEmitter = require('events').EventEmitter;\n\n/**\n * Tracks execution status for a given {@link CircuitBreaker}.\n * A Status instance is created for every {@link CircuitBreaker}\n * and does not typically need to be created by a user.\n *\n * A Status instance will listen for all events on the {@link CircuitBreaker}\n * and track them in a rolling statistical window. The window duration is\n * determined by the `rollingCountTimeout` option provided to the\n * {@link CircuitBreaker}. The window consists of an array of Objects,\n * each representing the counts for a {@link CircuitBreaker}'s events.\n *\n * The array's length is determined by the {@link CircuitBreaker}'s\n * `rollingCountBuckets` option. The duration of each slice of the window\n * is determined by dividing the `rollingCountTimeout` by\n * `rollingCountBuckets`.\n *\n * @class Status\n * @extends EventEmitter\n * @param {Object} options for the status window\n * @param {Number} options.rollingCountBuckets number of buckets in the window\n * @param {Number} options.rollingCountTimeout the duration of the window\n * @param {Boolean} options.rollingPercentilesEnabled whether to calculate\n * percentiles\n * @example\n * // Creates a 1 second window consisting of ten time slices,\n * // each 100ms long.\n * const circuit = circuitBreaker(fs.readFile,\n *  { rollingCountBuckets: 10, rollingCountTimeout: 1000});\n *\n * // get the cumulative statistics for the last second\n * circuit.status.stats;\n *\n * // get the array of 10, 1 second time slices for the last second\n * circuit.status.window;\n * @fires Status#snapshot\n * @see CircuitBreaker#status\n */\nclass Status extends EventEmitter {\n  constructor (options) {\n    super();\n\n    // Set up our statistical rolling window\n    this[BUCKETS] = options.rollingCountBuckets;\n    this[TIMEOUT] = options.rollingCountTimeout;\n    this[WINDOW] = new Array(this[BUCKETS]);\n    this[PERCENTILES] = [0.0, 0.25, 0.5, 0.75, 0.9, 0.95, 0.99, 0.995, 1];\n\n    // Default this value to true\n    this.rollingPercentilesEnabled = options.rollingPercentilesEnabled;\n\n    // prime the window with buckets\n    for (let i = 0; i < this[BUCKETS]; i++) this[WINDOW][i] = bucket();\n\n    // rotate the buckets periodically\n    const bucketInterval = Math.floor(this[TIMEOUT] / this[BUCKETS]);\n    let interval = setInterval(nextBucket(this[WINDOW]), bucketInterval);\n\n    // No unref() in the browser\n    if (typeof interval.unref === 'function') interval.unref();\n\n    /**\n     * Emitted at each time-slice. Listeners for this\n     * event will receive a cumulative snapshot of the current status window.\n     * @event Status#snapshot\n     * @type {Object}\n     */\n    interval = setInterval(_ => this.emit('snapshot', this.stats),\n      bucketInterval);\n    if (typeof interval.unref === 'function') interval.unref();\n  }\n\n  /**\n   * Get the cumulative stats for the current window\n   * @type {Object}\n   */\n  get stats () {\n    const totals = this[WINDOW].reduce((acc, val) => {\n      if (!val) { return acc; }\n      Object.keys(acc).forEach(key => {\n        if (key !== 'latencyTimes' && key !== 'percentiles') {\n          (acc[key] += val[key] || 0);\n        }\n      });\n\n      if (this.rollingPercentilesEnabled) {\n        acc.latencyTimes.push.apply(acc.latencyTimes, val.latencyTimes || []);\n      }\n      return acc;\n    }, bucket());\n\n    if (this.rollingPercentilesEnabled) {\n      // Sort the latencyTimes\n      totals.latencyTimes.sort((a, b) => a - b);\n\n      // Get the mean latency\n      // Mean = sum of all values in the array/length of array\n      if (totals.latencyTimes.length) {\n        totals.latencyMean =\n          (totals\n            .latencyTimes\n            .reduce((a, b) => a + b, 0)) / totals.latencyTimes.length;\n      } else {\n        totals.latencyMean = 0;\n      }\n\n      // Calculate Percentiles\n      this[PERCENTILES].forEach(percentile => {\n        totals.percentiles[percentile] =\n          calculatePercentile(percentile, totals.latencyTimes);\n      });\n    } else {\n      totals.latencyMean = -1;\n      this[PERCENTILES].forEach(percentile => {\n        totals.percentiles[percentile] = -1;\n      });\n    }\n\n    return totals;\n  }\n\n  /**\n   * Gets the stats window as an array of time-sliced objects.\n   * @type {Array}\n   */\n  get window () {\n    return this[WINDOW].slice();\n  }\n\n  increment (property, latencyRunTime) {\n    this[WINDOW][0][property]++;\n    if (property === 'successes' ||\n        property === 'failures' ||\n        property === 'timeouts') {\n      this[WINDOW][0].latencyTimes.push(latencyRunTime || 0);\n    }\n  }\n\n  open () {\n    this[WINDOW][0].isCircuitBreakerOpen = true;\n  }\n\n  close () {\n    this[WINDOW][0].isCircuitBreakerOpen = false;\n  }\n\n  shutdown () {\n    this.removeAllListeners();\n  }\n}\n\nconst nextBucket = window => _ => {\n  window.pop();\n  window.unshift(bucket());\n};\n\nconst bucket = _ => ({\n  failures: 0,\n  fallbacks: 0,\n  successes: 0,\n  rejects: 0,\n  fires: 0,\n  timeouts: 0,\n  cacheHits: 0,\n  cacheMisses: 0,\n  semaphoreRejections: 0,\n  percentiles: {},\n  latencyTimes: []\n});\n\nfunction calculatePercentile (percentile, arr) {\n  if (percentile === 0) {\n    return arr[0] || 0;\n  }\n  const idx = Math.ceil(percentile * arr.length);\n  return arr[idx - 1] || 0;\n}\n\nmodule.exports = exports = Status;\n","module.exports = {\n    RBTree: require('./lib/rbtree'),\n    BinTree: require('./lib/bintree')\n};\n","\nvar TreeBase = require('./treebase');\n\nfunction Node(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n}\n\nNode.prototype.get_child = function(dir) {\n    return dir ? this.right : this.left;\n};\n\nNode.prototype.set_child = function(dir, val) {\n    if(dir) {\n        this.right = val;\n    }\n    else {\n        this.left = val;\n    }\n};\n\nfunction BinTree(comparator) {\n    this._root = null;\n    this._comparator = comparator;\n    this.size = 0;\n}\n\nBinTree.prototype = new TreeBase();\n\n// returns true if inserted, false if duplicate\nBinTree.prototype.insert = function(data) {\n    if(this._root === null) {\n        // empty tree\n        this._root = new Node(data);\n        this.size++;\n        return true;\n    }\n\n    var dir = 0;\n\n    // setup\n    var p = null; // parent\n    var node = this._root;\n\n    // search down\n    while(true) {\n        if(node === null) {\n            // insert new node at the bottom\n            node = new Node(data);\n            p.set_child(dir, node);\n            ret = true;\n            this.size++;\n            return true;\n        }\n\n        // stop if found\n        if(this._comparator(node.data, data) === 0) {\n            return false;\n        }\n\n        dir = this._comparator(node.data, data) < 0;\n\n        // update helpers\n        p = node;\n        node = node.get_child(dir);\n    }\n};\n\n// returns true if removed, false if not found\nBinTree.prototype.remove = function(data) {\n    if(this._root === null) {\n        return false;\n    }\n\n    var head = new Node(undefined); // fake tree root\n    var node = head;\n    node.right = this._root;\n    var p = null; // parent\n    var found = null; // found item\n    var dir = 1;\n\n    while(node.get_child(dir) !== null) {\n        p = node;\n        node = node.get_child(dir);\n        var cmp = this._comparator(data, node.data);\n        dir = cmp > 0;\n\n        if(cmp === 0) {\n            found = node;\n        }\n    }\n\n    if(found !== null) {\n        found.data = node.data;\n        p.set_child(p.right === node, node.get_child(node.left === null));\n\n        this._root = head.right;\n        this.size--;\n        return true;\n    }\n    else {\n        return false;\n    }\n};\n\nmodule.exports = BinTree;\n\n","\nvar TreeBase = require('./treebase');\n\nfunction Node(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n    this.red = true;\n}\n\nNode.prototype.get_child = function(dir) {\n    return dir ? this.right : this.left;\n};\n\nNode.prototype.set_child = function(dir, val) {\n    if(dir) {\n        this.right = val;\n    }\n    else {\n        this.left = val;\n    }\n};\n\nfunction RBTree(comparator) {\n    this._root = null;\n    this._comparator = comparator;\n    this.size = 0;\n}\n\nRBTree.prototype = new TreeBase();\n\n// returns true if inserted, false if duplicate\nRBTree.prototype.insert = function(data) {\n    var ret = false;\n\n    if(this._root === null) {\n        // empty tree\n        this._root = new Node(data);\n        ret = true;\n        this.size++;\n    }\n    else {\n        var head = new Node(undefined); // fake tree root\n\n        var dir = 0;\n        var last = 0;\n\n        // setup\n        var gp = null; // grandparent\n        var ggp = head; // grand-grand-parent\n        var p = null; // parent\n        var node = this._root;\n        ggp.right = this._root;\n\n        // search down\n        while(true) {\n            if(node === null) {\n                // insert new node at the bottom\n                node = new Node(data);\n                p.set_child(dir, node);\n                ret = true;\n                this.size++;\n            }\n            else if(is_red(node.left) && is_red(node.right)) {\n                // color flip\n                node.red = true;\n                node.left.red = false;\n                node.right.red = false;\n            }\n\n            // fix red violation\n            if(is_red(node) && is_red(p)) {\n                var dir2 = ggp.right === gp;\n\n                if(node === p.get_child(last)) {\n                    ggp.set_child(dir2, single_rotate(gp, !last));\n                }\n                else {\n                    ggp.set_child(dir2, double_rotate(gp, !last));\n                }\n            }\n\n            var cmp = this._comparator(node.data, data);\n\n            // stop if found\n            if(cmp === 0) {\n                break;\n            }\n\n            last = dir;\n            dir = cmp < 0;\n\n            // update helpers\n            if(gp !== null) {\n                ggp = gp;\n            }\n            gp = p;\n            p = node;\n            node = node.get_child(dir);\n        }\n\n        // update root\n        this._root = head.right;\n    }\n\n    // make root black\n    this._root.red = false;\n\n    return ret;\n};\n\n// returns true if removed, false if not found\nRBTree.prototype.remove = function(data) {\n    if(this._root === null) {\n        return false;\n    }\n\n    var head = new Node(undefined); // fake tree root\n    var node = head;\n    node.right = this._root;\n    var p = null; // parent\n    var gp = null; // grand parent\n    var found = null; // found item\n    var dir = 1;\n\n    while(node.get_child(dir) !== null) {\n        var last = dir;\n\n        // update helpers\n        gp = p;\n        p = node;\n        node = node.get_child(dir);\n\n        var cmp = this._comparator(data, node.data);\n\n        dir = cmp > 0;\n\n        // save found node\n        if(cmp === 0) {\n            found = node;\n        }\n\n        // push the red node down\n        if(!is_red(node) && !is_red(node.get_child(dir))) {\n            if(is_red(node.get_child(!dir))) {\n                var sr = single_rotate(node, dir);\n                p.set_child(last, sr);\n                p = sr;\n            }\n            else if(!is_red(node.get_child(!dir))) {\n                var sibling = p.get_child(!last);\n                if(sibling !== null) {\n                    if(!is_red(sibling.get_child(!last)) && !is_red(sibling.get_child(last))) {\n                        // color flip\n                        p.red = false;\n                        sibling.red = true;\n                        node.red = true;\n                    }\n                    else {\n                        var dir2 = gp.right === p;\n\n                        if(is_red(sibling.get_child(last))) {\n                            gp.set_child(dir2, double_rotate(p, last));\n                        }\n                        else if(is_red(sibling.get_child(!last))) {\n                            gp.set_child(dir2, single_rotate(p, last));\n                        }\n\n                        // ensure correct coloring\n                        var gpc = gp.get_child(dir2);\n                        gpc.red = true;\n                        node.red = true;\n                        gpc.left.red = false;\n                        gpc.right.red = false;\n                    }\n                }\n            }\n        }\n    }\n\n    // replace and remove if found\n    if(found !== null) {\n        found.data = node.data;\n        p.set_child(p.right === node, node.get_child(node.left === null));\n        this.size--;\n    }\n\n    // update root and make it black\n    this._root = head.right;\n    if(this._root !== null) {\n        this._root.red = false;\n    }\n\n    return found !== null;\n};\n\nfunction is_red(node) {\n    return node !== null && node.red;\n}\n\nfunction single_rotate(root, dir) {\n    var save = root.get_child(!dir);\n\n    root.set_child(!dir, save.get_child(dir));\n    save.set_child(dir, root);\n\n    root.red = true;\n    save.red = false;\n\n    return save;\n}\n\nfunction double_rotate(root, dir) {\n    root.set_child(!dir, single_rotate(root.get_child(!dir), !dir));\n    return single_rotate(root, dir);\n}\n\nmodule.exports = RBTree;\n","\nfunction TreeBase() {}\n\n// removes all nodes from the tree\nTreeBase.prototype.clear = function() {\n    this._root = null;\n    this.size = 0;\n};\n\n// returns node data if found, null otherwise\nTreeBase.prototype.find = function(data) {\n    var res = this._root;\n\n    while(res !== null) {\n        var c = this._comparator(data, res.data);\n        if(c === 0) {\n            return res.data;\n        }\n        else {\n            res = res.get_child(c > 0);\n        }\n    }\n\n    return null;\n};\n\n// returns iterator to node if found, null otherwise\nTreeBase.prototype.findIter = function(data) {\n    var res = this._root;\n    var iter = this.iterator();\n\n    while(res !== null) {\n        var c = this._comparator(data, res.data);\n        if(c === 0) {\n            iter._cursor = res;\n            return iter;\n        }\n        else {\n            iter._ancestors.push(res);\n            res = res.get_child(c > 0);\n        }\n    }\n\n    return null;\n};\n\n// Returns an iterator to the tree node at or immediately after the item\nTreeBase.prototype.lowerBound = function(item) {\n    var cur = this._root;\n    var iter = this.iterator();\n    var cmp = this._comparator;\n\n    while(cur !== null) {\n        var c = cmp(item, cur.data);\n        if(c === 0) {\n            iter._cursor = cur;\n            return iter;\n        }\n        iter._ancestors.push(cur);\n        cur = cur.get_child(c > 0);\n    }\n\n    for(var i=iter._ancestors.length - 1; i >= 0; --i) {\n        cur = iter._ancestors[i];\n        if(cmp(item, cur.data) < 0) {\n            iter._cursor = cur;\n            iter._ancestors.length = i;\n            return iter;\n        }\n    }\n\n    iter._ancestors.length = 0;\n    return iter;\n};\n\n// Returns an iterator to the tree node immediately after the item\nTreeBase.prototype.upperBound = function(item) {\n    var iter = this.lowerBound(item);\n    var cmp = this._comparator;\n\n    while(iter.data() !== null && cmp(iter.data(), item) === 0) {\n        iter.next();\n    }\n\n    return iter;\n};\n\n// returns null if tree is empty\nTreeBase.prototype.min = function() {\n    var res = this._root;\n    if(res === null) {\n        return null;\n    }\n\n    while(res.left !== null) {\n        res = res.left;\n    }\n\n    return res.data;\n};\n\n// returns null if tree is empty\nTreeBase.prototype.max = function() {\n    var res = this._root;\n    if(res === null) {\n        return null;\n    }\n\n    while(res.right !== null) {\n        res = res.right;\n    }\n\n    return res.data;\n};\n\n// returns a null iterator\n// call next() or prev() to point to an element\nTreeBase.prototype.iterator = function() {\n    return new Iterator(this);\n};\n\n// calls cb on each node's data, in order\nTreeBase.prototype.each = function(cb) {\n    var it=this.iterator(), data;\n    while((data = it.next()) !== null) {\n        cb(data);\n    }\n};\n\n// calls cb on each node's data, in reverse order\nTreeBase.prototype.reach = function(cb) {\n    var it=this.iterator(), data;\n    while((data = it.prev()) !== null) {\n        cb(data);\n    }\n};\n\n\nfunction Iterator(tree) {\n    this._tree = tree;\n    this._ancestors = [];\n    this._cursor = null;\n}\n\nIterator.prototype.data = function() {\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\n// if null-iterator, returns first node\n// otherwise, returns next node\nIterator.prototype.next = function() {\n    if(this._cursor === null) {\n        var root = this._tree._root;\n        if(root !== null) {\n            this._minNode(root);\n        }\n    }\n    else {\n        if(this._cursor.right === null) {\n            // no greater node in subtree, go up to parent\n            // if coming from a right child, continue up the stack\n            var save;\n            do {\n                save = this._cursor;\n                if(this._ancestors.length) {\n                    this._cursor = this._ancestors.pop();\n                }\n                else {\n                    this._cursor = null;\n                    break;\n                }\n            } while(this._cursor.right === save);\n        }\n        else {\n            // get the next node from the subtree\n            this._ancestors.push(this._cursor);\n            this._minNode(this._cursor.right);\n        }\n    }\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\n// if null-iterator, returns last node\n// otherwise, returns previous node\nIterator.prototype.prev = function() {\n    if(this._cursor === null) {\n        var root = this._tree._root;\n        if(root !== null) {\n            this._maxNode(root);\n        }\n    }\n    else {\n        if(this._cursor.left === null) {\n            var save;\n            do {\n                save = this._cursor;\n                if(this._ancestors.length) {\n                    this._cursor = this._ancestors.pop();\n                }\n                else {\n                    this._cursor = null;\n                    break;\n                }\n            } while(this._cursor.left === save);\n        }\n        else {\n            this._ancestors.push(this._cursor);\n            this._maxNode(this._cursor.left);\n        }\n    }\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\nIterator.prototype._minNode = function(start) {\n    while(start.left !== null) {\n        this._ancestors.push(start);\n        start = start.left;\n    }\n    this._cursor = start;\n};\n\nIterator.prototype._maxNode = function(start) {\n    while(start.right !== null) {\n        this._ancestors.push(start);\n        start = start.right;\n    }\n    this._cursor = start;\n};\n\nmodule.exports = TreeBase;\n\n","/**\n * Prometheus client\n * @module Prometheus client\n */\n\n'use strict';\n\nexports.register = require('./lib/registry').globalRegistry;\nexports.Registry = require('./lib/registry');\nexports.contentType = require('./lib/registry').globalRegistry.contentType;\n\nexports.Counter = require('./lib/counter');\nexports.Gauge = require('./lib/gauge');\nexports.Histogram = require('./lib/histogram');\nexports.Summary = require('./lib/summary');\nexports.Pushgateway = require('./lib/pushgateway');\n\nexports.linearBuckets = require('./lib/bucketGenerators').linearBuckets;\nexports.exponentialBuckets = require('./lib/bucketGenerators').exponentialBuckets;\n\nexports.collectDefaultMetrics = require('./lib/defaultMetrics');\n\nexports.aggregators = require('./lib/metricAggregators').aggregators;\nexports.AggregatorRegistry = require('./lib/cluster');\n","'use strict';\n\nexports.linearBuckets = (start, width, count) => {\n\tif (count < 1) {\n\t\tthrow new Error('Linear buckets needs a positive count');\n\t}\n\n\tconst buckets = new Array(count);\n\tfor (let i = 0; i < count; i++) {\n\t\tbuckets[i] = start;\n\t\tstart += width;\n\t}\n\treturn buckets;\n};\n\nexports.exponentialBuckets = (start, factor, count) => {\n\tif (start <= 0) {\n\t\tthrow new Error('Exponential buckets needs a positive start');\n\t}\n\tif (count < 1) {\n\t\tthrow new Error('Exponential buckets needs a positive count');\n\t}\n\tif (factor <= 1) {\n\t\tthrow new Error('Exponential buckets needs a factor greater than 1');\n\t}\n\tconst buckets = new Array(count);\n\tfor (let i = 0; i < count; i++) {\n\t\tbuckets[i] = start;\n\t\tstart *= factor;\n\t}\n\treturn buckets;\n};\n","'use strict';\n\n/**\n * Extends the Registry class with a `clusterMetrics` method that returns\n * aggregated metrics for all workers.\n *\n * In cluster workers, listens for and responds to requests for metrics by the\n * cluster master.\n */\n\nconst cluster = require('cluster');\nconst Registry = require('./registry');\nconst { Grouper } = require('./util');\nconst { aggregators } = require('./metricAggregators');\n\nconst GET_METRICS_REQ = 'prom-client:getMetricsReq';\nconst GET_METRICS_RES = 'prom-client:getMetricsRes';\n\nlet registries = [Registry.globalRegistry];\nlet requestCtr = 0; // Concurrency control\nlet listenersAdded = false;\nconst requests = new Map(); // Pending requests for workers' local metrics.\n\nclass AggregatorRegistry extends Registry {\n\tconstructor() {\n\t\tsuper();\n\t\taddListeners();\n\t}\n\n\t/**\n\t * Gets aggregated metrics for all workers. The optional callback and\n\t * returned Promise resolve with the same value; either may be used.\n\t * @param {Function?} callback (err, metrics) => any\n\t * @return {Promise<string>} Promise that resolves with the aggregated\n\t *   metrics.\n\t */\n\tclusterMetrics(callback) {\n\t\tconst requestId = requestCtr++;\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tfunction done(err, result) {\n\t\t\t\t// Don't resolve/reject the promise if a callback is provided\n\t\t\t\tif (typeof callback === 'function') {\n\t\t\t\t\tcallback(err, result);\n\t\t\t\t} else {\n\t\t\t\t\tif (err) reject(err);\n\t\t\t\t\telse resolve(result);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst request = {\n\t\t\t\tresponses: [],\n\t\t\t\tpending: 0,\n\t\t\t\tdone,\n\t\t\t\terrorTimeout: setTimeout(() => {\n\t\t\t\t\trequest.failed = true;\n\t\t\t\t\tconst err = new Error('Operation timed out.');\n\t\t\t\t\trequest.done(err);\n\t\t\t\t}, 5000),\n\t\t\t\tfailed: false\n\t\t\t};\n\t\t\trequests.set(requestId, request);\n\n\t\t\tconst message = {\n\t\t\t\ttype: GET_METRICS_REQ,\n\t\t\t\trequestId\n\t\t\t};\n\n\t\t\tfor (const id in cluster.workers) {\n\t\t\t\t// If the worker exits abruptly, it may still be in the workers\n\t\t\t\t// list but not able to communicate.\n\t\t\t\tif (cluster.workers[id].isConnected()) {\n\t\t\t\t\tcluster.workers[id].send(message);\n\t\t\t\t\trequest.pending++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (request.pending === 0) {\n\t\t\t\t// No workers were up\n\t\t\t\tclearTimeout(request.errorTimeout);\n\t\t\t\tprocess.nextTick(() => done(null, ''));\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Creates a new Registry instance from an array of metrics that were\n\t * created by `registry.getMetricsAsJSON()`. Metrics are aggregated using\n\t * the method specified by their `aggregator` property, or by summation if\n\t * `aggregator` is undefined.\n\t * @param {Array} metricsArr Array of metrics, each of which created by\n\t *   `registry.getMetricsAsJSON()`.\n\t * @return {Registry} aggregated registry.\n\t */\n\tstatic aggregate(metricsArr) {\n\t\tconst aggregatedRegistry = new Registry();\n\t\tconst metricsByName = new Grouper();\n\n\t\t// Gather by name\n\t\tmetricsArr.forEach(metrics => {\n\t\t\tmetrics.forEach(metric => {\n\t\t\t\tmetricsByName.add(metric.name, metric);\n\t\t\t});\n\t\t});\n\n\t\t// Aggregate gathered metrics.\n\t\tmetricsByName.forEach(metrics => {\n\t\t\tconst aggregatorName = metrics[0].aggregator;\n\t\t\tconst aggregatorFn = aggregators[aggregatorName];\n\t\t\tif (typeof aggregatorFn !== 'function') {\n\t\t\t\tthrow new Error(`'${aggregatorName}' is not a defined aggregator.`);\n\t\t\t}\n\t\t\tconst aggregatedMetric = aggregatorFn(metrics);\n\t\t\t// NB: The 'omit' aggregator returns undefined.\n\t\t\tif (aggregatedMetric) {\n\t\t\t\tconst aggregatedMetricWrapper = Object.assign(\n\t\t\t\t\t{\n\t\t\t\t\t\tget: () => aggregatedMetric\n\t\t\t\t\t},\n\t\t\t\t\taggregatedMetric\n\t\t\t\t);\n\t\t\t\taggregatedRegistry.registerMetric(aggregatedMetricWrapper);\n\t\t\t}\n\t\t});\n\n\t\treturn aggregatedRegistry;\n\t}\n\n\t/**\n\t * Sets the registry or registries to be aggregated. Call from workers to\n\t * use a registry/registries other than the default global registry.\n\t * @param {Array<Registry>|Registry} regs Registry or registries to be\n\t *   aggregated.\n\t * @return {void}\n\t */\n\tstatic setRegistries(regs) {\n\t\tif (!Array.isArray(regs)) regs = [regs];\n\t\tregs.forEach(reg => {\n\t\t\tif (!(reg instanceof Registry)) {\n\t\t\t\tthrow new TypeError(`Expected Registry, got ${typeof reg}`);\n\t\t\t}\n\t\t});\n\t\tregistries = regs;\n\t}\n}\n\n/**\n * Adds event listeners for cluster aggregation. Idempotent (safe to call more\n * than once).\n * @return {void}\n */\nfunction addListeners() {\n\tif (listenersAdded) return;\n\tlistenersAdded = true;\n\n\tif (cluster.isMaster) {\n\t\t// Listen for worker responses to requests for local metrics\n\t\tcluster.on('message', (worker, message) => {\n\t\t\tif (message.type === GET_METRICS_RES) {\n\t\t\t\tconst request = requests.get(message.requestId);\n\t\t\t\tmessage.metrics.forEach(registry => request.responses.push(registry));\n\t\t\t\trequest.pending--;\n\n\t\t\t\tif (request.pending === 0) {\n\t\t\t\t\t// finalize\n\t\t\t\t\trequests.delete(message.requestId);\n\t\t\t\t\tclearTimeout(request.errorTimeout);\n\n\t\t\t\t\tif (request.failed) return; // Callback already run with Error.\n\n\t\t\t\t\tconst registry = AggregatorRegistry.aggregate(request.responses);\n\t\t\t\t\tconst promString = registry.metrics();\n\t\t\t\t\trequest.done(null, promString);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n\nif (cluster.isWorker) {\n\t// Respond to master's requests for worker's local metrics.\n\tprocess.on('message', message => {\n\t\tif (message.type === GET_METRICS_REQ) {\n\t\t\tprocess.send({\n\t\t\t\ttype: GET_METRICS_RES,\n\t\t\t\trequestId: message.requestId,\n\t\t\t\tmetrics: registries.map(r => r.getMetricsAsJSON())\n\t\t\t});\n\t\t}\n\t});\n}\n\nmodule.exports = AggregatorRegistry;\n","/**\n * Counter metric\n */\n'use strict';\n\nconst util = require('util');\nconst { globalRegistry } = require('./registry');\nconst type = 'counter';\nconst {\n\tisDate,\n\tgetPropertiesFromObj,\n\thashObject,\n\tisObject,\n\tprintDeprecationObjectConstructor,\n\tgetLabels,\n\tremoveLabels\n} = require('./util');\n\nconst {\n\tvalidateLabel,\n\tvalidateMetricName,\n\tvalidateLabelName\n} = require('./validation');\n\nclass Counter {\n\t/**\n\t * Counter\n\t * @param {string} name - Name of the metric\n\t * @param {string} help - Help description for the metric\n\t * @param {Array.<string>} labels - Labels\n\t */\n\tconstructor(name, help, labels) {\n\t\tlet config;\n\t\tif (isObject(name)) {\n\t\t\tconfig = Object.assign(\n\t\t\t\t{\n\t\t\t\t\tlabelNames: []\n\t\t\t\t},\n\t\t\t\tname\n\t\t\t);\n\n\t\t\tif (!config.registers) {\n\t\t\t\tconfig.registers = [globalRegistry];\n\t\t\t}\n\t\t} else {\n\t\t\tprintDeprecationObjectConstructor();\n\n\t\t\tconfig = {\n\t\t\t\tname,\n\t\t\t\thelp,\n\t\t\t\tlabelNames: labels,\n\t\t\t\tregisters: [globalRegistry]\n\t\t\t};\n\t\t}\n\n\t\tif (!config.help) {\n\t\t\tthrow new Error('Missing mandatory help parameter');\n\t\t}\n\t\tif (!config.name) {\n\t\t\tthrow new Error('Missing mandatory name parameter');\n\t\t}\n\t\tif (!validateMetricName(config.name)) {\n\t\t\tthrow new Error('Invalid metric name');\n\t\t}\n\n\t\tif (!validateLabelName(config.labelNames)) {\n\t\t\tthrow new Error('Invalid label name');\n\t\t}\n\n\t\tthis.name = config.name;\n\n\t\tthis.labelNames = config.labelNames || [];\n\n\t\tthis.reset();\n\n\t\tthis.help = config.help;\n\t\tthis.aggregator = config.aggregator || 'sum';\n\n\t\tconfig.registers.forEach(registryInstance =>\n\t\t\tregistryInstance.registerMetric(this)\n\t\t);\n\t}\n\n\t/**\n\t * Increment counter\n\t * @param {object} labels - What label you want to be incremented\n\t * @param {Number} value - Value to increment, if omitted increment with 1\n\t * @param {(Number|Date)} timestamp - Timestamp to set the counter to\n\t * @returns {void}\n\t */\n\tinc(labels, value, timestamp) {\n\t\tif (!isObject(labels)) {\n\t\t\treturn inc.call(this, null)(labels, value);\n\t\t}\n\n\t\tconst hash = hashObject(labels);\n\t\treturn inc.call(this, labels, hash)(value, timestamp);\n\t}\n\n\t/**\n\t * Reset counter\n\t * @returns {void}\n\t */\n\treset() {\n\t\treturn reset.call(this);\n\t}\n\n\tget() {\n\t\treturn {\n\t\t\thelp: this.help,\n\t\t\tname: this.name,\n\t\t\ttype,\n\t\t\tvalues: getPropertiesFromObj(this.hashMap),\n\t\t\taggregator: this.aggregator\n\t\t};\n\t}\n\n\tlabels() {\n\t\tconst labels = getLabels(this.labelNames, arguments) || {};\n\t\tconst hash = hashObject(labels);\n\t\tvalidateLabel(this.labelNames, labels);\n\t\treturn {\n\t\t\tinc: inc.call(this, labels, hash)\n\t\t};\n\t}\n\n\tremove() {\n\t\tconst labels = getLabels(this.labelNames, arguments) || {};\n\t\treturn removeLabels.call(this, this.hashMap, labels);\n\t}\n}\n\nconst reset = function() {\n\tthis.hashMap = {};\n\n\tif (this.labelNames.length === 0) {\n\t\tthis.hashMap = setValue({}, 0);\n\t}\n};\n\nconst inc = function(labels, hash) {\n\treturn (value, timestamp) => {\n\t\tif (value && !Number.isFinite(value)) {\n\t\t\tthrow new TypeError(`Value is not a valid number: ${util.format(value)}`);\n\t\t}\n\t\tif (timestamp && !isDate(timestamp) && !Number.isFinite(timestamp)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t`Timestamp is not a valid date or number: ${util.format(timestamp)}`\n\t\t\t);\n\t\t}\n\t\tif (value < 0) {\n\t\t\tthrow new Error('It is not possible to decrease a counter');\n\t\t}\n\n\t\tlabels = labels || {};\n\t\tvalidateLabel(this.labelNames, labels);\n\n\t\tconst incValue = value === null || value === undefined ? 1 : value;\n\n\t\tthis.hashMap = setValue(this.hashMap, incValue, timestamp, labels, hash);\n\t};\n};\n\nfunction setValue(hashMap, value, timestamp, labels, hash) {\n\thash = hash || '';\n\ttimestamp = isDate(timestamp)\n\t\t? timestamp.valueOf()\n\t\t: Number.isFinite(timestamp)\n\t\t? timestamp\n\t\t: undefined;\n\tif (hashMap[hash]) {\n\t\thashMap[hash].value += value;\n\t\thashMap[hash].timestamp = timestamp;\n\t} else {\n\t\thashMap[hash] = { value, labels: labels || {}, timestamp };\n\t}\n\treturn hashMap;\n}\n\nmodule.exports = Counter;\n","'use strict';\n\nconst processCpuTotal = require('./metrics/processCpuTotal');\nconst processStartTime = require('./metrics/processStartTime');\nconst osMemoryHeap = require('./metrics/osMemoryHeap');\nconst processOpenFileDescriptors = require('./metrics/processOpenFileDescriptors');\nconst processMaxFileDescriptors = require('./metrics/processMaxFileDescriptors');\nconst eventLoopLag = require('./metrics/eventLoopLag');\nconst processHandles = require('./metrics/processHandles');\nconst processRequests = require('./metrics/processRequests');\nconst heapSizeAndUsed = require('./metrics/heapSizeAndUsed');\nconst heapSpacesSizeAndUsed = require('./metrics/heapSpacesSizeAndUsed');\nconst version = require('./metrics/version');\nconst { globalRegistry } = require('./registry');\nconst { printDeprecationCollectDefaultMetricsNumber } = require('./util');\n\nconst metrics = {\n\tprocessCpuTotal,\n\tprocessStartTime,\n\tosMemoryHeap,\n\tprocessOpenFileDescriptors,\n\tprocessMaxFileDescriptors,\n\teventLoopLag,\n\tprocessHandles,\n\tprocessRequests,\n\theapSizeAndUsed,\n\theapSpacesSizeAndUsed,\n\tversion\n};\nconst metricsList = Object.keys(metrics);\n\nlet existingInterval = null;\n// This is used to ensure the program throws on duplicate metrics during first run\n// We might want to consider not supporting running the default metrics function more than once\nlet init = true;\n\nmodule.exports = function startDefaultMetrics(config) {\n\tlet normalizedConfig = config;\n\tif (typeof config === 'number') {\n\t\tprintDeprecationCollectDefaultMetricsNumber(config);\n\n\t\tnormalizedConfig = { timeout: config };\n\t}\n\n\tnormalizedConfig = Object.assign({ timeout: 10000 }, normalizedConfig);\n\n\tif (existingInterval !== null) {\n\t\tclearInterval(existingInterval);\n\t}\n\n\tconst initialisedMetrics = metricsList.map(metric => {\n\t\tconst defaultMetric = metrics[metric];\n\t\tif (!init) {\n\t\t\tdefaultMetric.metricNames.map(\n\t\t\t\tglobalRegistry.removeSingleMetric,\n\t\t\t\tglobalRegistry\n\t\t\t);\n\t\t}\n\n\t\treturn defaultMetric(normalizedConfig.register, config);\n\t});\n\n\tfunction updateAllMetrics() {\n\t\tinitialisedMetrics.forEach(metric => metric.call());\n\t}\n\n\tupdateAllMetrics();\n\n\texistingInterval = setInterval(\n\t\tupdateAllMetrics,\n\t\tnormalizedConfig.timeout\n\t).unref();\n\n\tinit = false;\n\n\treturn existingInterval;\n};\n\nmodule.exports.metricsList = metricsList;\n","/**\n * Gauge metric\n */\n'use strict';\n\nconst util = require('util');\nconst { globalRegistry } = require('./registry');\nconst type = 'gauge';\n\nconst {\n\tisDate,\n\tsetValue,\n\tgetPropertiesFromObj,\n\tgetLabels,\n\thashObject,\n\tisObject,\n\tprintDeprecationObjectConstructor,\n\tremoveLabels\n} = require('./util');\nconst {\n\tvalidateMetricName,\n\tvalidateLabel,\n\tvalidateLabelName\n} = require('./validation');\n\nclass Gauge {\n\t/**\n\t * Gauge\n\t * @param {string} name - Name of the metric\n\t * @param {string} help - Help for the metric\n\t * @param {Array.<string>} labels - Array with strings, all label keywords supported\n\t */\n\tconstructor(name, help, labels) {\n\t\tlet config;\n\t\tif (isObject(name)) {\n\t\t\tconfig = Object.assign(\n\t\t\t\t{\n\t\t\t\t\tlabelNames: []\n\t\t\t\t},\n\t\t\t\tname\n\t\t\t);\n\n\t\t\tif (!config.registers) {\n\t\t\t\tconfig.registers = [globalRegistry];\n\t\t\t}\n\t\t} else {\n\t\t\tprintDeprecationObjectConstructor();\n\t\t\tconfig = {\n\t\t\t\tname,\n\t\t\t\thelp,\n\t\t\t\tlabelNames: labels,\n\t\t\t\tregisters: [globalRegistry]\n\t\t\t};\n\t\t}\n\n\t\tif (!config.help) {\n\t\t\tthrow new Error('Missing mandatory help parameter');\n\t\t}\n\t\tif (!config.name) {\n\t\t\tthrow new Error('Missing mandatory name parameter');\n\t\t}\n\t\tif (!validateMetricName(config.name)) {\n\t\t\tthrow new Error('Invalid metric name');\n\t\t}\n\t\tif (!validateLabelName(config.labelNames)) {\n\t\t\tthrow new Error('Invalid label name');\n\t\t}\n\n\t\tthis.name = config.name;\n\t\tthis.labelNames = config.labelNames || [];\n\t\tthis.reset();\n\t\tthis.help = config.help;\n\t\tthis.aggregator = config.aggregator || 'sum';\n\n\t\tconfig.registers.forEach(registryInstance =>\n\t\t\tregistryInstance.registerMetric(this)\n\t\t);\n\t}\n\n\t/**\n\t * Set a gauge to a value\n\t * @param {object} labels - Object with labels and their values\n\t * @param {Number} value - Value to set the gauge to, must be positive\n\t * @param {(Number|Date)} timestamp - Timestamp to set the gauge to\n\t * @returns {void}\n\t */\n\tset(labels, value, timestamp) {\n\t\tif (!isObject(labels)) {\n\t\t\treturn set.call(this, null)(labels, value);\n\t\t}\n\t\treturn set.call(this, labels)(value, timestamp);\n\t}\n\n\t/**\n\t * Reset gauge\n\t * @returns {void}\n\t */\n\treset() {\n\t\treturn reset.call(this);\n\t}\n\n\t/**\n\t * Increment a gauge value\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @param {Number} value - Value to increment - if omitted, increment with 1\n\t * @param {(Number|Date)} timestamp - Timestamp to set the gauge to\n\t * @returns {void}\n\t */\n\tinc(labels, value, timestamp) {\n\t\tinc.call(this, labels)(value, timestamp);\n\t}\n\n\t/**\n\t * Decrement a gauge value\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @param {Number} value - Value to decrement - if omitted, decrement with 1\n\t * @param {(Number|Date)} timestamp - Timestamp to set the gauge to\n\t * @returns {void}\n\t */\n\tdec(labels, value, timestamp) {\n\t\tdec.call(this, labels)(value, timestamp);\n\t}\n\n\t/**\n\t * Set the gauge to current unix epoch\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @returns {void}\n\t */\n\tsetToCurrentTime(labels) {\n\t\treturn setToCurrentTime.call(this, labels)();\n\t}\n\n\t/**\n\t * Start a timer\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @returns {function} - Invoke this function to set the duration in seconds since you started the timer.\n\t * @example\n\t * var done = gauge.startTimer();\n\t * makeXHRRequest(function(err, response) {\n\t *\tdone(); //Duration of the request will be saved\n\t * });\n\t */\n\tstartTimer(labels) {\n\t\treturn startTimer.call(this, labels)();\n\t}\n\n\tget() {\n\t\treturn {\n\t\t\thelp: this.help,\n\t\t\tname: this.name,\n\t\t\ttype,\n\t\t\tvalues: getPropertiesFromObj(this.hashMap),\n\t\t\taggregator: this.aggregator\n\t\t};\n\t}\n\n\t_getValue(labels) {\n\t\tconst hash = hashObject(labels || {});\n\t\treturn this.hashMap[hash] ? this.hashMap[hash].value : 0;\n\t}\n\n\tlabels() {\n\t\tconst labels = getLabels(this.labelNames, arguments);\n\t\treturn {\n\t\t\tinc: inc.call(this, labels),\n\t\t\tdec: dec.call(this, labels),\n\t\t\tset: set.call(this, labels),\n\t\t\tsetToCurrentTime: setToCurrentTime.call(this, labels),\n\t\t\tstartTimer: startTimer.call(this, labels)\n\t\t};\n\t}\n\n\tremove() {\n\t\tconst labels = getLabels(this.labelNames, arguments);\n\t\tremoveLabels.call(this, this.hashMap, labels);\n\t}\n}\n\nfunction setToCurrentTime(labels) {\n\treturn () => {\n\t\tconst now = Date.now() / 1000;\n\t\tif (labels === undefined) {\n\t\t\tthis.set(now);\n\t\t} else {\n\t\t\tthis.set(labels, now);\n\t\t}\n\t};\n}\n\nfunction startTimer(startLabels) {\n\treturn () => {\n\t\tconst start = process.hrtime();\n\t\treturn endLabels => {\n\t\t\tconst delta = process.hrtime(start);\n\t\t\tthis.set(\n\t\t\t\tObject.assign({}, startLabels, endLabels),\n\t\t\t\tdelta[0] + delta[1] / 1e9\n\t\t\t);\n\t\t};\n\t};\n}\n\nfunction dec(labels) {\n\treturn (value, timestamp) => {\n\t\tconst data = convertLabelsAndValues(labels, value);\n\t\tthis.set(\n\t\t\tdata.labels,\n\t\t\tthis._getValue(data.labels) - (data.value || 1),\n\t\t\ttimestamp\n\t\t);\n\t};\n}\n\nfunction inc(labels) {\n\treturn (value, timestamp) => {\n\t\tconst data = convertLabelsAndValues(labels, value);\n\t\tthis.set(\n\t\t\tdata.labels,\n\t\t\tthis._getValue(data.labels) + (data.value || 1),\n\t\t\ttimestamp\n\t\t);\n\t};\n}\n\nfunction set(labels) {\n\treturn (value, timestamp) => {\n\t\tif (typeof value !== 'number') {\n\t\t\tthrow new TypeError(`Value is not a valid number: ${util.format(value)}`);\n\t\t}\n\t\tif (timestamp && !isDate(timestamp) && !Number.isFinite(timestamp)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t`Timestamp is not a valid date or number: ${util.format(timestamp)}`\n\t\t\t);\n\t\t}\n\n\t\tlabels = labels || {};\n\n\t\tvalidateLabel(this.labelNames, labels);\n\t\tthis.hashMap = setValue(this.hashMap, value, labels, timestamp);\n\t};\n}\n\nfunction reset() {\n\tthis.hashMap = {};\n\n\tif (this.labelNames.length === 0) {\n\t\tthis.hashMap = setValue({}, 0, {});\n\t}\n}\n\nfunction convertLabelsAndValues(labels, value) {\n\tif (!isObject(labels)) {\n\t\treturn {\n\t\t\tvalue: labels,\n\t\t\tlabels: {}\n\t\t};\n\t}\n\treturn {\n\t\tlabels,\n\t\tvalue\n\t};\n}\n\nmodule.exports = Gauge;\n","/**\n * Histogram\n */\n'use strict';\n\nconst util = require('util');\nconst globalRegistry = require('./registry').globalRegistry;\nconst type = 'histogram';\nconst {\n\tgetPropertiesFromObj,\n\tgetLabels,\n\thashObject,\n\tisObject,\n\tprintDeprecationObjectConstructor,\n\tremoveLabels\n} = require('./util');\nconst {\n\tvalidateMetricName,\n\tvalidateLabel,\n\tvalidateLabelName\n} = require('./validation');\n\nclass Histogram {\n\t/**\n\t * Histogram\n\t * @param {string} name - Name of the metric\n\t * @param {string} help - Help for the metric\n\t * @param {object|Array.<string>} labelsOrConf - Either array of label names or config object as a key-value object\n\t * @param {object} conf - Configuration object\n\t */\n\tconstructor(name, help, labelsOrConf, conf) {\n\t\tlet config;\n\n\t\tif (isObject(name)) {\n\t\t\tconfig = Object.assign(\n\t\t\t\t{\n\t\t\t\t\tbuckets: [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10],\n\t\t\t\t\tlabelNames: []\n\t\t\t\t},\n\t\t\t\tname\n\t\t\t);\n\n\t\t\tif (!config.registers) {\n\t\t\t\tconfig.registers = [globalRegistry];\n\t\t\t}\n\t\t} else {\n\t\t\tlet obj;\n\t\t\tlet labels = [];\n\n\t\t\tif (Array.isArray(labelsOrConf)) {\n\t\t\t\tobj = conf || {};\n\t\t\t\tlabels = labelsOrConf;\n\t\t\t} else {\n\t\t\t\tobj = labelsOrConf || {};\n\t\t\t}\n\n\t\t\tprintDeprecationObjectConstructor();\n\n\t\t\tconfig = {\n\t\t\t\tname,\n\t\t\t\tlabelNames: labels,\n\t\t\t\thelp,\n\t\t\t\tbuckets: configureUpperbounds(obj.buckets),\n\t\t\t\tregisters: [globalRegistry]\n\t\t\t};\n\t\t}\n\t\tvalidateInput(config.name, config.help, config.labelNames);\n\n\t\tthis.name = config.name;\n\t\tthis.help = config.help;\n\t\tthis.aggregator = config.aggregator || 'sum';\n\n\t\tthis.upperBounds = config.buckets;\n\t\tthis.bucketValues = this.upperBounds.reduce((acc, upperBound) => {\n\t\t\tacc[upperBound] = 0;\n\t\t\treturn acc;\n\t\t}, {});\n\n\t\tObject.freeze(this.bucketValues);\n\t\tObject.freeze(this.upperBounds);\n\t\tthis.sum = 0;\n\t\tthis.count = 0;\n\n\t\tthis.hashMap = {};\n\t\tthis.labelNames = config.labelNames || [];\n\n\t\tif (this.labelNames.length === 0) {\n\t\t\tthis.hashMap = {\n\t\t\t\t[hashObject({})]: createBaseValues(\n\t\t\t\t\t{},\n\t\t\t\t\tObject.assign({}, this.bucketValues)\n\t\t\t\t)\n\t\t\t};\n\t\t}\n\n\t\tconfig.registers.forEach(registryInstance =>\n\t\t\tregistryInstance.registerMetric(this)\n\t\t);\n\t}\n\n\t/**\n\t * Observe a value in histogram\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @param {Number} value - Value to observe in the histogram\n\t * @returns {void}\n\t */\n\tobserve(labels, value) {\n\t\tobserve.call(this, labels === 0 ? 0 : labels || {})(value);\n\t}\n\n\tget() {\n\t\tconst data = getPropertiesFromObj(this.hashMap);\n\t\tconst values = data\n\t\t\t.map(extractBucketValuesForExport(this))\n\t\t\t.reduce(addSumAndCountForExport(this), []);\n\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\thelp: this.help,\n\t\t\ttype,\n\t\t\tvalues,\n\t\t\taggregator: this.aggregator\n\t\t};\n\t}\n\n\treset() {\n\t\tthis.sum = 0;\n\t\tthis.count = 0;\n\t\tthis.hashMap = {};\n\t}\n\n\t/**\n\t * Start a timer that could be used to logging durations\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @returns {function} - Function to invoke when you want to stop the timer and observe the duration in seconds\n\t * @example\n\t * var end = histogram.startTimer();\n\t * makeExpensiveXHRRequest(function(err, res) {\n\t *\tend(); //Observe the duration of expensiveXHRRequest\n\t * });\n\t */\n\tstartTimer(labels) {\n\t\treturn startTimer.call(this, labels)();\n\t}\n\n\tlabels() {\n\t\tconst labels = getLabels(this.labelNames, arguments);\n\t\treturn {\n\t\t\tobserve: observe.call(this, labels),\n\t\t\tstartTimer: startTimer.call(this, labels)\n\t\t};\n\t}\n\n\tremove() {\n\t\tconst labels = getLabels(this.labelNames, arguments);\n\t\tremoveLabels.call(this, this.hashMap, labels);\n\t}\n}\n\nfunction startTimer(startLabels) {\n\treturn () => {\n\t\tconst start = process.hrtime();\n\t\treturn endLabels => {\n\t\t\tconst delta = process.hrtime(start);\n\t\t\tthis.observe(\n\t\t\t\tObject.assign({}, startLabels, endLabels),\n\t\t\t\tdelta[0] + delta[1] / 1e9\n\t\t\t);\n\t\t};\n\t};\n}\nfunction validateInput(name, help, labels) {\n\tif (!help) {\n\t\tthrow new Error('Missing mandatory help parameter');\n\t}\n\tif (!name) {\n\t\tthrow new Error('Missing mandatory name parameter');\n\t}\n\n\tif (!validateMetricName(name)) {\n\t\tthrow new Error('Invalid metric name');\n\t}\n\n\tif (!validateLabelName(labels)) {\n\t\tthrow new Error('Invalid label name');\n\t}\n\n\tlabels.forEach(label => {\n\t\tif (label === 'le') {\n\t\t\tthrow new Error('le is a reserved label keyword');\n\t\t}\n\t});\n}\n\nfunction configureUpperbounds(configuredBuckets) {\n\tconst defaultBuckets = [\n\t\t0.005,\n\t\t0.01,\n\t\t0.025,\n\t\t0.05,\n\t\t0.1,\n\t\t0.25,\n\t\t0.5,\n\t\t1,\n\t\t2.5,\n\t\t5,\n\t\t10\n\t];\n\treturn [].concat(configuredBuckets || defaultBuckets).sort(sortAscending);\n}\n\nfunction sortAscending(x, y) {\n\treturn x - y;\n}\n\nfunction setValuePair(labels, value, metricName) {\n\treturn {\n\t\tlabels,\n\t\tvalue,\n\t\tmetricName\n\t};\n}\n\nfunction findBound(upperBounds, value) {\n\tfor (let i = 0; i < upperBounds.length; i++) {\n\t\tconst bound = upperBounds[i];\n\t\tif (value <= bound) {\n\t\t\treturn bound;\n\t\t}\n\t}\n\treturn -1;\n}\n\nfunction observe(labels) {\n\treturn value => {\n\t\tconst labelValuePair = convertLabelsAndValues(labels, value);\n\n\t\tvalidateLabel(this.labelNames, labelValuePair.labels);\n\t\tif (!Number.isFinite(labelValuePair.value)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t`Value is not a valid number: ${util.format(labelValuePair.value)}`\n\t\t\t);\n\t\t}\n\n\t\tconst hash = hashObject(labelValuePair.labels);\n\t\tlet valueFromMap = this.hashMap[hash];\n\t\tif (!valueFromMap) {\n\t\t\tvalueFromMap = createBaseValues(\n\t\t\t\tlabelValuePair.labels,\n\t\t\t\tObject.assign({}, this.bucketValues)\n\t\t\t);\n\t\t}\n\n\t\tconst b = findBound(this.upperBounds, labelValuePair.value);\n\n\t\tvalueFromMap.sum += labelValuePair.value;\n\t\tvalueFromMap.count += 1;\n\n\t\tif (valueFromMap.bucketValues.hasOwnProperty(b)) {\n\t\t\tvalueFromMap.bucketValues[b] += 1;\n\t\t}\n\n\t\tthis.hashMap[hash] = valueFromMap;\n\t};\n}\n\nfunction createBaseValues(labels, bucketValues) {\n\treturn {\n\t\tlabels,\n\t\tbucketValues,\n\t\tsum: 0,\n\t\tcount: 0\n\t};\n}\n\nfunction convertLabelsAndValues(labels, value) {\n\tif (!isObject(labels)) {\n\t\treturn {\n\t\t\tvalue: labels,\n\t\t\tlabels: {}\n\t\t};\n\t}\n\treturn {\n\t\tlabels,\n\t\tvalue\n\t};\n}\n\nfunction extractBucketValuesForExport(histogram) {\n\treturn bucketData => {\n\t\tconst buckets = [];\n\t\tconst bucketLabelNames = Object.keys(bucketData.labels);\n\t\tlet acc = 0;\n\t\tfor (const upperBound of histogram.upperBounds) {\n\t\t\tacc += bucketData.bucketValues[upperBound];\n\t\t\tconst lbls = { le: upperBound };\n\t\t\tfor (const labelName of bucketLabelNames) {\n\t\t\t\tlbls[labelName] = bucketData.labels[labelName];\n\t\t\t}\n\t\t\tbuckets.push(setValuePair(lbls, acc, `${histogram.name}_bucket`));\n\t\t}\n\t\treturn { buckets, data: bucketData };\n\t};\n}\n\nfunction addSumAndCountForExport(histogram) {\n\treturn (acc, d) => {\n\t\tacc.push(...d.buckets);\n\n\t\tconst infLabel = { le: '+Inf' };\n\t\tfor (const label of Object.keys(d.data.labels)) {\n\t\t\tinfLabel[label] = d.data.labels[label];\n\t\t}\n\t\tacc.push(\n\t\t\tsetValuePair(infLabel, d.data.count, `${histogram.name}_bucket`),\n\t\t\tsetValuePair(d.data.labels, d.data.sum, `${histogram.name}_sum`),\n\t\t\tsetValuePair(d.data.labels, d.data.count, `${histogram.name}_count`)\n\t\t);\n\t\treturn acc;\n\t};\n}\n\nmodule.exports = Histogram;\n","'use strict';\n\nconst { Grouper, hashObject } = require('./util');\n\n/**\n * Returns a new function that applies the `aggregatorFn` to the values.\n * @param {Function} aggregatorFn function to apply to values.\n * @return {Function} aggregator function\n */\nfunction AggregatorFactory(aggregatorFn) {\n\treturn metrics => {\n\t\tif (metrics.length === 0) return;\n\t\tconst result = {\n\t\t\thelp: metrics[0].help,\n\t\t\tname: metrics[0].name,\n\t\t\ttype: metrics[0].type,\n\t\t\tvalues: [],\n\t\t\taggregator: metrics[0].aggregator\n\t\t};\n\t\t// Gather metrics by metricName and labels.\n\t\tconst byLabels = new Grouper();\n\t\tmetrics.forEach(metric => {\n\t\t\tmetric.values.forEach(value => {\n\t\t\t\tconst key = hashObject(value.labels);\n\t\t\t\tbyLabels.add(`${value.metricName}_${key}`, value);\n\t\t\t});\n\t\t});\n\t\t// Apply aggregator function to gathered metrics.\n\t\tbyLabels.forEach(values => {\n\t\t\tif (values.length === 0) return;\n\t\t\tconst valObj = {\n\t\t\t\tvalue: aggregatorFn(values),\n\t\t\t\tlabels: values[0].labels\n\t\t\t};\n\t\t\tif (values[0].metricName) {\n\t\t\t\tvalObj.metricName = values[0].metricName;\n\t\t\t}\n\t\t\t// NB: Timestamps are omitted.\n\t\t\tresult.values.push(valObj);\n\t\t});\n\t\treturn result;\n\t};\n}\n// Export for users to define their own aggregation methods.\nexports.AggregatorFactory = AggregatorFactory;\n\n/**\n * Functions that can be used to aggregate metrics from multiple registries.\n */\nexports.aggregators = {\n\t/**\n\t * @return The sum of values.\n\t */\n\tsum: AggregatorFactory(v => v.reduce((p, c) => p + c.value, 0)),\n\t/**\n\t * @return The first value.\n\t */\n\tfirst: AggregatorFactory(v => v[0].value),\n\t/**\n\t * @return {undefined} Undefined; omits the metric.\n\t */\n\tomit: () => {},\n\t/**\n\t * @return The arithmetic mean of the values.\n\t */\n\taverage: AggregatorFactory(\n\t\tv => v.reduce((p, c) => p + c.value, 0) / v.length\n\t),\n\t/**\n\t * @return The minimum of the values.\n\t */\n\tmin: AggregatorFactory(v =>\n\t\tv.reduce((p, c) => Math.min(p, c.value), Infinity)\n\t),\n\t/**\n\t * @return The maximum of the values.\n\t */\n\tmax: AggregatorFactory(v =>\n\t\tv.reduce((p, c) => Math.max(p, c.value), -Infinity)\n\t)\n};\n","'use strict';\n\nconst Gauge = require('../gauge');\n\nconst NODEJS_EVENTLOOP_LAG = 'nodejs_eventloop_lag_seconds';\n\nfunction reportEventloopLag(start, gauge) {\n\tconst delta = process.hrtime(start);\n\tconst nanosec = delta[0] * 1e9 + delta[1];\n\tconst seconds = nanosec / 1e9;\n\n\tgauge.set(seconds, Date.now());\n}\n\nmodule.exports = (registry, config = {}) => {\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst gauge = new Gauge({\n\t\tname: namePrefix + NODEJS_EVENTLOOP_LAG,\n\t\thelp: 'Lag of event loop in seconds.',\n\t\tregisters: registry ? [registry] : undefined,\n\t\taggregator: 'average'\n\t});\n\n\treturn () => {\n\t\tconst start = process.hrtime();\n\t\tsetImmediate(reportEventloopLag, start, gauge);\n\t};\n};\n\nmodule.exports.metricNames = [NODEJS_EVENTLOOP_LAG];\n","'use strict';\n\nconst Gauge = require('../gauge');\nconst safeMemoryUsage = require('./helpers/safeMemoryUsage');\n\nconst NODEJS_HEAP_SIZE_TOTAL = 'nodejs_heap_size_total_bytes';\nconst NODEJS_HEAP_SIZE_USED = 'nodejs_heap_size_used_bytes';\nconst NODEJS_EXTERNAL_MEMORY = 'nodejs_external_memory_bytes';\n\nmodule.exports = (registry, config = {}) => {\n\tif (typeof process.memoryUsage !== 'function') {\n\t\treturn () => {};\n\t}\n\n\tconst registers = registry ? [registry] : undefined;\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst heapSizeTotal = new Gauge({\n\t\tname: namePrefix + NODEJS_HEAP_SIZE_TOTAL,\n\t\thelp: 'Process heap size from node.js in bytes.',\n\t\tregisters\n\t});\n\tconst heapSizeUsed = new Gauge({\n\t\tname: namePrefix + NODEJS_HEAP_SIZE_USED,\n\t\thelp: 'Process heap size used from node.js in bytes.',\n\t\tregisters\n\t});\n\tlet externalMemUsed;\n\n\tconst usage = safeMemoryUsage();\n\tif (usage && usage.external) {\n\t\texternalMemUsed = new Gauge({\n\t\t\tname: namePrefix + NODEJS_EXTERNAL_MEMORY,\n\t\t\thelp: 'Nodejs external memory size in bytes.',\n\t\t\tregisters\n\t\t});\n\t}\n\n\treturn () => {\n\t\t// process.memoryUsage() can throw EMFILE errors, see #67\n\t\tconst memUsage = safeMemoryUsage();\n\t\tif (memUsage) {\n\t\t\tconst now = Date.now();\n\t\t\theapSizeTotal.set(memUsage.heapTotal, now);\n\t\t\theapSizeUsed.set(memUsage.heapUsed, now);\n\t\t\tif (memUsage.external && externalMemUsed) {\n\t\t\t\texternalMemUsed.set(memUsage.external, now);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\ttotal: heapSizeTotal,\n\t\t\tused: heapSizeUsed,\n\t\t\texternal: externalMemUsed\n\t\t};\n\t};\n};\n\nmodule.exports.metricNames = [\n\tNODEJS_HEAP_SIZE_TOTAL,\n\tNODEJS_HEAP_SIZE_USED,\n\tNODEJS_EXTERNAL_MEMORY\n];\n","'use strict';\n\nconst Gauge = require('../gauge');\nlet v8;\n\ntry {\n\tv8 = require('v8');\n} catch (e) {\n\t// node version is too old\n\t// probably we can use v8-heap-space-statistics for >=node-4.0.0 and <node-6.0.0\n}\n\nconst METRICS = ['total', 'used', 'available'];\n\nconst NODEJS_HEAP_SIZE = {};\n\nMETRICS.forEach(metricType => {\n\tNODEJS_HEAP_SIZE[metricType] = `nodejs_heap_space_size_${metricType}_bytes`;\n});\n\nmodule.exports = (registry, config = {}) => {\n\tif (\n\t\ttypeof v8 === 'undefined' ||\n\t\ttypeof v8.getHeapSpaceStatistics !== 'function'\n\t) {\n\t\treturn () => {};\n\t}\n\n\tconst registers = registry ? [registry] : undefined;\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst gauges = {};\n\n\tMETRICS.forEach(metricType => {\n\t\tgauges[metricType] = new Gauge({\n\t\t\tname: namePrefix + NODEJS_HEAP_SIZE[metricType],\n\t\t\thelp: `Process heap space size ${metricType} from node.js in bytes.`,\n\t\t\tlabelNames: ['space'],\n\t\t\tregisters\n\t\t});\n\t});\n\n\treturn () => {\n\t\tconst data = {\n\t\t\ttotal: {},\n\t\t\tused: {},\n\t\t\tavailable: {}\n\t\t};\n\t\tconst now = Date.now();\n\n\t\tv8.getHeapSpaceStatistics().forEach(space => {\n\t\t\tconst spaceName = space.space_name.substr(\n\t\t\t\t0,\n\t\t\t\tspace.space_name.indexOf('_space')\n\t\t\t);\n\n\t\t\tdata.total[spaceName] = space.space_size;\n\t\t\tdata.used[spaceName] = space.space_used_size;\n\t\t\tdata.available[spaceName] = space.space_available_size;\n\n\t\t\tgauges.total.set({ space: spaceName }, space.space_size, now);\n\t\t\tgauges.used.set({ space: spaceName }, space.space_used_size, now);\n\t\t\tgauges.available.set(\n\t\t\t\t{ space: spaceName },\n\t\t\t\tspace.space_available_size,\n\t\t\t\tnow\n\t\t\t);\n\t\t});\n\n\t\treturn data;\n\t};\n};\n\nmodule.exports.metricNames = METRICS.map(\n\tmetricType => NODEJS_HEAP_SIZE[metricType]\n);\n","'use strict';\n\nfunction safeMemoryUsage() {\n\tlet memoryUsage;\n\ttry {\n\t\tmemoryUsage = process.memoryUsage();\n\t} catch (ex) {\n\t\t// empty\n\t}\n\n\treturn memoryUsage;\n}\n\nmodule.exports = safeMemoryUsage;\n","'use strict';\n\nconst Gauge = require('../gauge');\nconst linuxVariant = require('./osMemoryHeapLinux');\nconst safeMemoryUsage = require('./helpers/safeMemoryUsage');\n\nconst PROCESS_RESIDENT_MEMORY = 'process_resident_memory_bytes';\n\nfunction notLinuxVariant(registry, config = {}) {\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst residentMemGauge = new Gauge({\n\t\tname: namePrefix + PROCESS_RESIDENT_MEMORY,\n\t\thelp: 'Resident memory size in bytes.',\n\t\tregisters: registry ? [registry] : undefined\n\t});\n\n\treturn () => {\n\t\tconst memUsage = safeMemoryUsage();\n\n\t\t// I don't think the other things returned from `process.memoryUsage()` is relevant to a standard export\n\t\tif (memUsage) {\n\t\t\tresidentMemGauge.set(memUsage.rss, Date.now());\n\t\t}\n\t};\n}\n\nmodule.exports = (registry, config) =>\n\tprocess.platform === 'linux'\n\t\t? linuxVariant(registry, config)\n\t\t: notLinuxVariant(registry, config);\n\nmodule.exports.metricNames =\n\tprocess.platform === 'linux'\n\t\t? linuxVariant.metricNames\n\t\t: [PROCESS_RESIDENT_MEMORY];\n","'use strict';\n\nconst Gauge = require('../gauge');\nconst fs = require('fs');\n\nconst values = ['VmSize', 'VmRSS', 'VmData'];\n\nconst PROCESS_RESIDENT_MEMORY = 'process_resident_memory_bytes';\nconst PROCESS_VIRTUAL_MEMORY = 'process_virtual_memory_bytes';\nconst PROCESS_HEAP = 'process_heap_bytes';\n\nfunction structureOutput(input) {\n\tconst returnValue = {};\n\n\tinput\n\t\t.split('\\n')\n\t\t.filter(s => values.some(value => s.indexOf(value) === 0))\n\t\t.forEach(string => {\n\t\t\tconst split = string.split(':');\n\n\t\t\t// Get the value\n\t\t\tlet value = split[1].trim();\n\t\t\t// Remove trailing ` kb`\n\t\t\tvalue = value.substr(0, value.length - 3);\n\t\t\t// Make it into a number in bytes bytes\n\t\t\tvalue = Number(value) * 1024;\n\n\t\t\treturnValue[split[0]] = value;\n\t\t});\n\n\treturn returnValue;\n}\n\nmodule.exports = (registry, config = {}) => {\n\tconst registers = registry ? [registry] : undefined;\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst residentMemGauge = new Gauge({\n\t\tname: namePrefix + PROCESS_RESIDENT_MEMORY,\n\t\thelp: 'Resident memory size in bytes.',\n\t\tregisters\n\t});\n\tconst virtualMemGauge = new Gauge({\n\t\tname: namePrefix + PROCESS_VIRTUAL_MEMORY,\n\t\thelp: 'Virtual memory size in bytes.',\n\t\tregisters\n\t});\n\tconst heapSizeMemGauge = new Gauge({\n\t\tname: namePrefix + PROCESS_HEAP,\n\t\thelp: 'Process heap size in bytes.',\n\t\tregisters\n\t});\n\n\treturn () => {\n\t\tfs.readFile('/proc/self/status', 'utf8', (err, status) => {\n\t\t\tif (err) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst now = Date.now();\n\t\t\tconst structuredOutput = structureOutput(status);\n\n\t\t\tresidentMemGauge.set(structuredOutput.VmRSS, now);\n\t\t\tvirtualMemGauge.set(structuredOutput.VmSize, now);\n\t\t\theapSizeMemGauge.set(structuredOutput.VmData, now);\n\t\t});\n\t};\n};\n\nmodule.exports.metricNames = [\n\tPROCESS_RESIDENT_MEMORY,\n\tPROCESS_VIRTUAL_MEMORY,\n\tPROCESS_HEAP\n];\n","'use strict';\n\nconst Counter = require('../counter');\nconst PROCESS_CPU_USER_SECONDS = 'process_cpu_user_seconds_total';\nconst PROCESS_CPU_SYSTEM_SECONDS = 'process_cpu_system_seconds_total';\nconst PROCESS_CPU_SECONDS = 'process_cpu_seconds_total';\n\nmodule.exports = (registry, config = {}) => {\n\t// Don't do anything if the function doesn't exist (introduced in node@6.1.0)\n\tif (typeof process.cpuUsage !== 'function') {\n\t\treturn () => {};\n\t}\n\n\tconst registers = registry ? [registry] : undefined;\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst cpuUserUsageCounter = new Counter({\n\t\tname: namePrefix + PROCESS_CPU_USER_SECONDS,\n\t\thelp: 'Total user CPU time spent in seconds.',\n\t\tregisters\n\t});\n\tconst cpuSystemUsageCounter = new Counter({\n\t\tname: namePrefix + PROCESS_CPU_SYSTEM_SECONDS,\n\t\thelp: 'Total system CPU time spent in seconds.',\n\t\tregisters\n\t});\n\tconst cpuUsageCounter = new Counter({\n\t\tname: namePrefix + PROCESS_CPU_SECONDS,\n\t\thelp: 'Total user and system CPU time spent in seconds.',\n\t\tregisters\n\t});\n\n\tlet lastCpuUsage = process.cpuUsage();\n\n\treturn () => {\n\t\tconst cpuUsage = process.cpuUsage();\n\t\tconst now = Date.now();\n\n\t\tconst userUsageMicros = cpuUsage.user - lastCpuUsage.user;\n\t\tconst systemUsageMicros = cpuUsage.system - lastCpuUsage.system;\n\n\t\tlastCpuUsage = cpuUsage;\n\n\t\tcpuUserUsageCounter.inc(userUsageMicros / 1e6, now);\n\t\tcpuSystemUsageCounter.inc(systemUsageMicros / 1e6, now);\n\t\tcpuUsageCounter.inc((userUsageMicros + systemUsageMicros) / 1e6, now);\n\t};\n};\n\nmodule.exports.metricNames = [\n\tPROCESS_CPU_USER_SECONDS,\n\tPROCESS_CPU_SYSTEM_SECONDS,\n\tPROCESS_CPU_SECONDS\n];\n","'use strict';\n\nconst Gauge = require('../gauge');\n\nconst NODEJS_ACTIVE_HANDLES = 'nodejs_active_handles_total';\n\nmodule.exports = (registry, config = {}) => {\n\t// Don't do anything if the function is removed in later nodes (exists in node@6)\n\tif (typeof process._getActiveHandles !== 'function') {\n\t\treturn () => {};\n\t}\n\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst gauge = new Gauge({\n\t\tname: namePrefix + NODEJS_ACTIVE_HANDLES,\n\t\thelp: 'Number of active handles.',\n\t\tregisters: registry ? [registry] : undefined\n\t});\n\n\treturn () => {\n\t\tgauge.set(process._getActiveHandles().length, Date.now());\n\t};\n};\n\nmodule.exports.metricNames = [NODEJS_ACTIVE_HANDLES];\n","'use strict';\n\nconst Gauge = require('../gauge');\nconst fs = require('fs');\n\nconst PROCESS_MAX_FDS = 'process_max_fds';\n\nmodule.exports = (registry, config = {}) => {\n\tlet isSet = false;\n\n\tif (process.platform !== 'linux') {\n\t\treturn () => {};\n\t}\n\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst fileDescriptorsGauge = new Gauge({\n\t\tname: namePrefix + PROCESS_MAX_FDS,\n\t\thelp: 'Maximum number of open file descriptors.',\n\t\tregisters: registry ? [registry] : undefined\n\t});\n\n\treturn () => {\n\t\tif (isSet) {\n\t\t\treturn;\n\t\t}\n\n\t\tfs.readFile('/proc/sys/fs/file-max', 'utf8', (err, maxFds) => {\n\t\t\tif (err) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tisSet = true;\n\n\t\t\tfileDescriptorsGauge.set(Number(maxFds));\n\t\t});\n\t};\n};\n\nmodule.exports.metricNames = [PROCESS_MAX_FDS];\n","'use strict';\n\nconst Gauge = require('../gauge');\nconst fs = require('fs');\nconst process = require('process');\n\nconst PROCESS_OPEN_FDS = 'process_open_fds';\n\nmodule.exports = (registry, config = {}) => {\n\tif (process.platform !== 'linux') {\n\t\treturn () => {};\n\t}\n\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst fileDescriptorsGauge = new Gauge({\n\t\tname: namePrefix + PROCESS_OPEN_FDS,\n\t\thelp: 'Number of open file descriptors.',\n\t\tregisters: registry ? [registry] : undefined\n\t});\n\n\treturn () => {\n\t\tfs.readdir('/proc/self/fd', (err, list) => {\n\t\t\tif (err) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Minus 1, as this invocation created one\n\t\t\tfileDescriptorsGauge.set(list.length - 1, Date.now());\n\t\t});\n\t};\n};\n\nmodule.exports.metricNames = [PROCESS_OPEN_FDS];\n","'use strict';\n\nconst Gauge = require('../gauge');\n\nconst NODEJS_ACTIVE_REQUESTS = 'nodejs_active_requests_total';\n\nmodule.exports = (registry, config = {}) => {\n\t// Don't do anything if the function is removed in later nodes (exists in node@6)\n\tif (typeof process._getActiveRequests !== 'function') {\n\t\treturn () => {};\n\t}\n\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst gauge = new Gauge({\n\t\tname: namePrefix + NODEJS_ACTIVE_REQUESTS,\n\t\thelp: 'Number of active requests.',\n\t\tregisters: registry ? [registry] : undefined\n\t});\n\n\treturn () => {\n\t\tgauge.set(process._getActiveRequests().length, Date.now());\n\t};\n};\n\nmodule.exports.metricNames = [NODEJS_ACTIVE_REQUESTS];\n","'use strict';\n\nconst Gauge = require('../gauge');\nconst nowInSeconds = Math.round(Date.now() / 1000 - process.uptime());\n\nconst PROCESS_START_TIME = 'process_start_time_seconds';\n\nmodule.exports = (registry, config = {}) => {\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst cpuUserGauge = new Gauge({\n\t\tname: namePrefix + PROCESS_START_TIME,\n\t\thelp: 'Start time of the process since unix epoch in seconds.',\n\t\tregisters: registry ? [registry] : undefined,\n\t\taggregator: 'omit'\n\t});\n\tlet isSet = false;\n\n\treturn () => {\n\t\tif (isSet) {\n\t\t\treturn;\n\t\t}\n\t\tcpuUserGauge.set(nowInSeconds);\n\t\tisSet = true;\n\t};\n};\n\nmodule.exports.metricNames = [PROCESS_START_TIME];\n","'use strict';\n\nconst Gauge = require('../gauge');\nconst version = process.version;\nconst versionSegments = version\n\t.slice(1)\n\t.split('.')\n\t.map(Number);\n\nconst NODE_VERSION_INFO = 'nodejs_version_info';\n\nmodule.exports = (registry, config = {}) => {\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst nodeVersionGauge = new Gauge({\n\t\tname: namePrefix + NODE_VERSION_INFO,\n\t\thelp: 'Node.js version info.',\n\t\tlabelNames: ['version', 'major', 'minor', 'patch'],\n\t\tregisters: registry ? [registry] : undefined,\n\t\taggregator: 'first'\n\t});\n\tlet isSet = false;\n\n\treturn () => {\n\t\tif (isSet) {\n\t\t\treturn;\n\t\t}\n\t\tnodeVersionGauge\n\t\t\t.labels(\n\t\t\t\tversion,\n\t\t\t\tversionSegments[0],\n\t\t\t\tversionSegments[1],\n\t\t\t\tversionSegments[2]\n\t\t\t)\n\t\t\t.set(1);\n\t\tisSet = true;\n\t};\n};\n\nmodule.exports.metricNames = [NODE_VERSION_INFO];\n","'use strict';\n\nconst url = require('url');\nconst http = require('http');\nconst https = require('https');\nconst { globalRegistry } = require('./registry');\n\nclass Pushgateway {\n\tconstructor(gatewayUrl, options, registry) {\n\t\tif (!registry) {\n\t\t\tregistry = globalRegistry;\n\t\t}\n\t\tthis.registry = registry;\n\t\tthis.gatewayUrl = gatewayUrl;\n\t\tthis.requestOptions = Object.assign({}, options);\n\t}\n\n\tpushAdd(params, callback) {\n\t\tif (!params || !params.jobName) {\n\t\t\tthrow new Error('Missing jobName parameter');\n\t\t}\n\n\t\tuseGateway.call(this, 'POST', params.jobName, params.groupings, callback);\n\t}\n\n\tpush(params, callback) {\n\t\tif (!params || !params.jobName) {\n\t\t\tthrow new Error('Missing jobName parameter');\n\t\t}\n\n\t\tuseGateway.call(this, 'PUT', params.jobName, params.groupings, callback);\n\t}\n\n\tdelete(params, callback) {\n\t\tif (!params || !params.jobName) {\n\t\t\tthrow new Error('Missing jobName parameter');\n\t\t}\n\n\t\tuseGateway.call(this, 'DELETE', params.jobName, params.groupings, callback);\n\t}\n}\nfunction useGateway(method, job, groupings, callback) {\n\t// `URL` first added in v6.13.0\n\t// eslint-disable-next-line node/no-deprecated-api\n\tconst gatewayUrlParsed = url.parse(this.gatewayUrl);\n\tconst gatewayUrlPath =\n\t\tgatewayUrlParsed.pathname && gatewayUrlParsed.pathname !== '/'\n\t\t\t? gatewayUrlParsed.pathname\n\t\t\t: '';\n\tconst path = `${gatewayUrlPath}/metrics/job/${encodeURIComponent(\n\t\tjob\n\t)}${generateGroupings(groupings)}`;\n\n\t// eslint-disable-next-line node/no-deprecated-api\n\tconst target = url.resolve(this.gatewayUrl, path);\n\t// eslint-disable-next-line node/no-deprecated-api\n\tconst requestParams = url.parse(target);\n\tconst httpModule = isHttps(requestParams.href) ? https : http;\n\tconst options = Object.assign(requestParams, this.requestOptions, {\n\t\tmethod\n\t});\n\n\tconst req = httpModule.request(options, res => {\n\t\tlet body = '';\n\t\tres.setEncoding('utf8');\n\t\tres.on('data', chunk => {\n\t\t\tbody += chunk;\n\t\t});\n\t\tres.on('end', () => {\n\t\t\tcallback(null, res, body);\n\t\t});\n\t});\n\treq.on('error', err => {\n\t\tcallback(err);\n\t});\n\n\tif (method !== 'DELETE') {\n\t\treq.write(this.registry.metrics({ timestamps: false }));\n\t}\n\treq.end();\n}\n\nfunction generateGroupings(groupings) {\n\tif (!groupings) {\n\t\treturn '';\n\t}\n\treturn Object.keys(groupings)\n\t\t.map(\n\t\t\tkey => `/${encodeURIComponent(key)}/${encodeURIComponent(groupings[key])}`\n\t\t)\n\t\t.join('');\n}\n\nfunction isHttps(href) {\n\treturn href.search(/^https/) !== -1;\n}\n\nmodule.exports = Pushgateway;\n","'use strict';\nconst { getValueAsString } = require('./util');\n\nfunction escapeString(str) {\n\treturn str.replace(/\\n/g, '\\\\n').replace(/\\\\(?!n)/g, '\\\\\\\\');\n}\nfunction escapeLabelValue(str) {\n\tif (typeof str !== 'string') {\n\t\treturn str;\n\t}\n\treturn escapeString(str).replace(/\"/g, '\\\\\"');\n}\n\nconst defaultMetricsOpts = {\n\ttimestamps: true\n};\n\nclass Registry {\n\tconstructor() {\n\t\tthis._metrics = {};\n\t\tthis._defaultLabels = {};\n\t}\n\n\tgetMetricsAsArray() {\n\t\treturn Object.keys(this._metrics).map(this.getSingleMetric, this);\n\t}\n\n\tgetMetricAsPrometheusString(metric, conf) {\n\t\tconst opts = Object.assign({}, defaultMetricsOpts, conf);\n\t\tconst item = metric.get();\n\t\tconst name = escapeString(item.name);\n\t\tconst help = `# HELP ${name} ${escapeString(item.help)}`;\n\t\tconst type = `# TYPE ${name} ${item.type}`;\n\t\tconst defaultLabelNames = Object.keys(this._defaultLabels);\n\n\t\tlet values = '';\n\t\tfor (const val of item.values || []) {\n\t\t\tval.labels = val.labels || {};\n\t\t\tfor (const labelName of defaultLabelNames) {\n\t\t\t\tval.labels[labelName] =\n\t\t\t\t\tval.labels[labelName] || this._defaultLabels[labelName];\n\t\t\t}\n\n\t\t\tlet labels = '';\n\t\t\tfor (const key of Object.keys(val.labels)) {\n\t\t\t\tlabels += `${key}=\"${escapeLabelValue(val.labels[key])}\",`;\n\t\t\t}\n\n\t\t\tlet metricName = val.metricName || item.name;\n\t\t\tif (labels) {\n\t\t\t\tmetricName += `{${labels.substring(0, labels.length - 1)}}`;\n\t\t\t}\n\n\t\t\tlet line = `${metricName} ${getValueAsString(val.value)}`;\n\t\t\tif (opts.timestamps && val.timestamp) {\n\t\t\t\tline += ` ${val.timestamp}`;\n\t\t\t}\n\t\t\tvalues += `${line.trim()}\\n`;\n\t\t}\n\n\t\treturn `${help}\\n${type}\\n${values}`.trim();\n\t}\n\n\tmetrics(opts) {\n\t\tlet metrics = '';\n\n\t\tfor (const metric of this.getMetricsAsArray()) {\n\t\t\tmetrics += `${this.getMetricAsPrometheusString(metric, opts)}\\n\\n`;\n\t\t}\n\n\t\treturn metrics.substring(0, metrics.length - 1);\n\t}\n\n\tregisterMetric(metricFn) {\n\t\tif (\n\t\t\tthis._metrics[metricFn.name] &&\n\t\t\tthis._metrics[metricFn.name] !== metricFn\n\t\t) {\n\t\t\tthrow new Error(\n\t\t\t\t`A metric with the name ${metricFn.name} has already been registered.`\n\t\t\t);\n\t\t}\n\n\t\tthis._metrics[metricFn.name] = metricFn;\n\t}\n\n\tclear() {\n\t\tthis._metrics = {};\n\t\tthis._defaultLabels = {};\n\t}\n\n\tgetMetricsAsJSON() {\n\t\tconst metrics = [];\n\t\tconst defaultLabelNames = Object.keys(this._defaultLabels);\n\n\t\tfor (const metric of this.getMetricsAsArray()) {\n\t\t\tconst item = metric.get();\n\n\t\t\tif (item.values) {\n\t\t\t\tfor (const val of item.values) {\n\t\t\t\t\tfor (const labelName of defaultLabelNames) {\n\t\t\t\t\t\tval.labels[labelName] =\n\t\t\t\t\t\t\tval.labels[labelName] || this._defaultLabels[labelName];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmetrics.push(item);\n\t\t}\n\n\t\treturn metrics;\n\t}\n\n\tremoveSingleMetric(name) {\n\t\tdelete this._metrics[name];\n\t}\n\n\tgetSingleMetricAsString(name) {\n\t\treturn this.getMetricAsPrometheusString(this._metrics[name]);\n\t}\n\n\tgetSingleMetric(name) {\n\t\treturn this._metrics[name];\n\t}\n\n\tsetDefaultLabels(labels) {\n\t\tthis._defaultLabels = labels;\n\t}\n\n\tresetMetrics() {\n\t\tfor (const metric in this._metrics) {\n\t\t\tthis._metrics[metric].reset();\n\t\t}\n\t}\n\n\tget contentType() {\n\t\treturn 'text/plain; version=0.0.4; charset=utf-8';\n\t}\n\n\tstatic merge(registers) {\n\t\tconst mergedRegistry = new Registry();\n\n\t\tconst metricsToMerge = registers.reduce(\n\t\t\t(acc, reg) => acc.concat(reg.getMetricsAsArray()),\n\t\t\t[]\n\t\t);\n\n\t\tmetricsToMerge.forEach(mergedRegistry.registerMetric, mergedRegistry);\n\t\treturn mergedRegistry;\n\t}\n}\n\nmodule.exports = Registry;\nmodule.exports.globalRegistry = new Registry();\n","/**\n * Summary\n */\n'use strict';\n\nconst util = require('util');\nconst { globalRegistry } = require('./registry');\nconst type = 'summary';\nconst {\n\tgetPropertiesFromObj,\n\tgetLabels,\n\thashObject,\n\tisObject,\n\tprintDeprecationObjectConstructor,\n\tremoveLabels\n} = require('./util');\nconst {\n\tvalidateLabel,\n\tvalidateMetricName,\n\tvalidateLabelName\n} = require('./validation');\nconst timeWindowQuantiles = require('./timeWindowQuantiles');\n\nclass Summary {\n\t/**\n\t * Summary\n\t * @param {string} name - Name of the metric\n\t * @param {string} help - Help for the metric\n\t * @param {object|Array.<string>} labelsOrConf - Either array of label names or config object as a key-value object\n\t * @param {object} conf - Configuration object\n\t */\n\tconstructor(name, help, labelsOrConf, conf) {\n\t\tlet config;\n\t\tif (isObject(name)) {\n\t\t\tconfig = Object.assign(\n\t\t\t\t{\n\t\t\t\t\tpercentiles: [0.01, 0.05, 0.5, 0.9, 0.95, 0.99, 0.999],\n\t\t\t\t\tlabelNames: []\n\t\t\t\t},\n\t\t\t\tname\n\t\t\t);\n\n\t\t\tif (!config.registers) {\n\t\t\t\tconfig.registers = [globalRegistry];\n\t\t\t}\n\t\t} else {\n\t\t\tlet obj;\n\t\t\tlet labels = [];\n\n\t\t\tif (Array.isArray(labelsOrConf)) {\n\t\t\t\tobj = conf || {};\n\t\t\t\tlabels = labelsOrConf;\n\t\t\t} else {\n\t\t\t\tobj = labelsOrConf || {};\n\t\t\t}\n\n\t\t\tprintDeprecationObjectConstructor();\n\n\t\t\tconfig = {\n\t\t\t\tname,\n\t\t\t\thelp,\n\t\t\t\tlabelNames: labels,\n\t\t\t\tpercentiles: configurePercentiles(obj.percentiles),\n\t\t\t\tregisters: [globalRegistry],\n\t\t\t\tmaxAgeSeconds: obj.maxAgeSeconds,\n\t\t\t\tageBuckets: obj.ageBuckets\n\t\t\t};\n\t\t}\n\n\t\tvalidateInput(config.name, config.help, config.labelNames);\n\n\t\tthis.maxAgeSeconds = config.maxAgeSeconds;\n\t\tthis.ageBuckets = config.ageBuckets;\n\n\t\tthis.name = config.name;\n\t\tthis.help = config.help;\n\t\tthis.aggregator = config.aggregator || 'sum';\n\n\t\tthis.percentiles = config.percentiles;\n\t\tthis.hashMap = {};\n\t\tthis.labelNames = config.labelNames || [];\n\n\t\tif (this.labelNames.length === 0) {\n\t\t\tthis.hashMap = {\n\t\t\t\t[hashObject({})]: {\n\t\t\t\t\tlabels: {},\n\t\t\t\t\ttd: new timeWindowQuantiles(this.maxAgeSeconds, this.ageBuckets),\n\t\t\t\t\tcount: 0,\n\t\t\t\t\tsum: 0\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tconfig.registers.forEach(registryInstance =>\n\t\t\tregistryInstance.registerMetric(this)\n\t\t);\n\t}\n\n\t/**\n\t * Observe a value\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @param {Number} value - Value to observe\n\t * @returns {void}\n\t */\n\tobserve(labels, value) {\n\t\tobserve.call(this, labels === 0 ? 0 : labels || {})(value);\n\t}\n\n\tget() {\n\t\tconst data = getPropertiesFromObj(this.hashMap);\n\t\tconst values = [];\n\t\tdata.forEach(s => {\n\t\t\textractSummariesForExport(s, this.percentiles).forEach(v => {\n\t\t\t\tvalues.push(v);\n\t\t\t});\n\t\t\tvalues.push(getSumForExport(s, this));\n\t\t\tvalues.push(getCountForExport(s, this));\n\t\t});\n\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\thelp: this.help,\n\t\t\ttype,\n\t\t\tvalues,\n\t\t\taggregator: this.aggregator\n\t\t};\n\t}\n\n\treset() {\n\t\tconst data = getPropertiesFromObj(this.hashMap);\n\t\tdata.forEach(s => {\n\t\t\ts.td.reset();\n\t\t\ts.count = 0;\n\t\t\ts.sum = 0;\n\t\t});\n\t}\n\n\t/**\n\t * Start a timer that could be used to logging durations\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @returns {function} - Function to invoke when you want to stop the timer and observe the duration in seconds\n\t * @example\n\t * var end = summary.startTimer();\n\t * makeExpensiveXHRRequest(function(err, res) {\n\t *\tend(); //Observe the duration of expensiveXHRRequest\n\t * });\n\t */\n\tstartTimer(labels) {\n\t\treturn startTimer.call(this, labels)();\n\t}\n\n\tlabels() {\n\t\tconst labels = getLabels(this.labelNames, arguments);\n\t\treturn {\n\t\t\tobserve: observe.call(this, labels),\n\t\t\tstartTimer: startTimer.call(this, labels)\n\t\t};\n\t}\n\n\tremove() {\n\t\tconst labels = getLabels(this.labelNames, arguments);\n\t\tremoveLabels.call(this, this.hashMap, labels);\n\t}\n}\n\nfunction extractSummariesForExport(summaryOfLabels, percentiles) {\n\tsummaryOfLabels.td.compress();\n\n\treturn percentiles.map(percentile => {\n\t\tconst percentileValue = summaryOfLabels.td.percentile(percentile);\n\t\treturn {\n\t\t\tlabels: Object.assign({ quantile: percentile }, summaryOfLabels.labels),\n\t\t\tvalue: percentileValue ? percentileValue : 0\n\t\t};\n\t});\n}\n\nfunction getCountForExport(value, summary) {\n\treturn {\n\t\tmetricName: `${summary.name}_count`,\n\t\tlabels: value.labels,\n\t\tvalue: value.count\n\t};\n}\n\nfunction getSumForExport(value, summary) {\n\treturn {\n\t\tmetricName: `${summary.name}_sum`,\n\t\tlabels: value.labels,\n\t\tvalue: value.sum\n\t};\n}\n\nfunction startTimer(startLabels) {\n\treturn () => {\n\t\tconst start = process.hrtime();\n\t\treturn endLabels => {\n\t\t\tconst delta = process.hrtime(start);\n\t\t\tthis.observe(\n\t\t\t\tObject.assign({}, startLabels, endLabels),\n\t\t\t\tdelta[0] + delta[1] / 1e9\n\t\t\t);\n\t\t};\n\t};\n}\n\nfunction validateInput(name, help, labels) {\n\tif (!help) {\n\t\tthrow new Error('Missing mandatory help parameter');\n\t}\n\tif (!name) {\n\t\tthrow new Error('Missing mandatory name parameter');\n\t}\n\n\tif (!validateMetricName(name)) {\n\t\tthrow new Error('Invalid metric name');\n\t}\n\n\tif (!validateLabelName(labels)) {\n\t\tthrow new Error('Invalid label name');\n\t}\n\n\tlabels.forEach(label => {\n\t\tif (label === 'quantile') {\n\t\t\tthrow new Error('quantile is a reserved label keyword');\n\t\t}\n\t});\n}\n\nfunction configurePercentiles(configuredPercentiles) {\n\tconst defaultPercentiles = [0.01, 0.05, 0.5, 0.9, 0.95, 0.99, 0.999];\n\treturn []\n\t\t.concat(configuredPercentiles || defaultPercentiles)\n\t\t.sort(sortAscending);\n}\n\nfunction sortAscending(x, y) {\n\treturn x - y;\n}\n\nfunction observe(labels) {\n\treturn value => {\n\t\tconst labelValuePair = convertLabelsAndValues(labels, value);\n\n\t\tvalidateLabel(this.labelNames, this.labels);\n\t\tif (!Number.isFinite(labelValuePair.value)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t`Value is not a valid number: ${util.format(labelValuePair.value)}`\n\t\t\t);\n\t\t}\n\n\t\tconst hash = hashObject(labelValuePair.labels);\n\t\tlet summaryOfLabel = this.hashMap[hash];\n\t\tif (!summaryOfLabel) {\n\t\t\tsummaryOfLabel = {\n\t\t\t\tlabels: labelValuePair.labels,\n\t\t\t\ttd: new timeWindowQuantiles(this.maxAgeSeconds, this.ageBuckets),\n\t\t\t\tcount: 0,\n\t\t\t\tsum: 0\n\t\t\t};\n\t\t}\n\n\t\tsummaryOfLabel.td.push(labelValuePair.value);\n\t\tsummaryOfLabel.count++;\n\t\tsummaryOfLabel.sum += labelValuePair.value;\n\t\tthis.hashMap[hash] = summaryOfLabel;\n\t};\n}\n\nfunction convertLabelsAndValues(labels, value) {\n\tif (value === undefined) {\n\t\treturn {\n\t\t\tvalue: labels,\n\t\t\tlabels: {}\n\t\t};\n\t}\n\n\treturn {\n\t\tlabels,\n\t\tvalue\n\t};\n}\n\nmodule.exports = Summary;\n","'use strict';\n\nconst { TDigest } = require('tdigest');\n\nclass TimeWindowQuantiles {\n\tconstructor(maxAgeSeconds, ageBuckets) {\n\t\tthis.maxAgeSeconds = maxAgeSeconds || 0;\n\t\tthis.ageBuckets = ageBuckets || 0;\n\n\t\tthis.shouldRotate = maxAgeSeconds && ageBuckets;\n\n\t\tthis.ringBuffer = Array(ageBuckets).fill(new TDigest());\n\t\tthis.currentBuffer = 0;\n\n\t\tthis.lastRotateTimestampMillis = Date.now();\n\t\tthis.durationBetweenRotatesMillis =\n\t\t\t(maxAgeSeconds * 1000) / ageBuckets || Infinity;\n\t}\n\n\tpercentile(quantile) {\n\t\tconst bucket = rotate.call(this);\n\t\treturn bucket.percentile(quantile);\n\t}\n\n\tpush(value) {\n\t\trotate.call(this);\n\t\tthis.ringBuffer.forEach(bucket => {\n\t\t\tbucket.push(value);\n\t\t});\n\t}\n\n\treset() {\n\t\tthis.ringBuffer.forEach(bucket => {\n\t\t\tbucket.reset();\n\t\t});\n\t}\n\n\tcompress() {\n\t\tthis.ringBuffer.forEach(bucket => {\n\t\t\tbucket.compress();\n\t\t});\n\t}\n}\n\nfunction rotate() {\n\tlet timeSinceLastRotateMillis = Date.now() - this.lastRotateTimestampMillis;\n\twhile (\n\t\ttimeSinceLastRotateMillis > this.durationBetweenRotatesMillis &&\n\t\tthis.shouldRotate\n\t) {\n\t\tthis.ringBuffer[this.currentBuffer] = new TDigest();\n\n\t\tif (++this.currentBuffer >= this.ringBuffer.length) {\n\t\t\tthis.currentBuffer = 0;\n\t\t}\n\t\ttimeSinceLastRotateMillis -= this.durationBetweenRotatesMillis;\n\t\tthis.lastRotateTimestampMillis += this.durationBetweenRotatesMillis;\n\t}\n\treturn this.ringBuffer[this.currentBuffer];\n}\n\nmodule.exports = TimeWindowQuantiles;\n","'use strict';\n\nconst deprecationsEmitted = {};\n\nexports.isDate = isDate;\n\nexports.getPropertiesFromObj = function(hashMap) {\n\tconst obj = Object.keys(hashMap).map(x => hashMap[x]);\n\treturn obj;\n};\n\nexports.getValueAsString = function getValueString(value) {\n\tif (Number.isNaN(value)) {\n\t\treturn 'Nan';\n\t} else if (!Number.isFinite(value)) {\n\t\tif (value < 0) {\n\t\t\treturn '-Inf';\n\t\t} else {\n\t\t\treturn '+Inf';\n\t\t}\n\t} else {\n\t\treturn `${value}`;\n\t}\n};\n\nexports.removeLabels = function removeLabels(hashMap, labels) {\n\tconst hash = hashObject(labels);\n\tdelete hashMap[hash];\n};\n\nexports.setValue = function setValue(hashMap, value, labels, timestamp) {\n\tconst hash = hashObject(labels);\n\thashMap[hash] = {\n\t\tvalue: typeof value === 'number' ? value : 0,\n\t\tlabels: labels || {},\n\t\ttimestamp: isDate(timestamp)\n\t\t\t? timestamp.valueOf()\n\t\t\t: Number.isFinite(timestamp)\n\t\t\t? timestamp\n\t\t\t: undefined\n\t};\n\treturn hashMap;\n};\n\n// TODO: For node 6, use rest params\nexports.getLabels = function(labelNames, args) {\n\tif (labelNames.length !== args.length) {\n\t\tthrow new Error('Invalid number of arguments');\n\t}\n\n\tconst argsAsArray = Array.prototype.slice.call(args);\n\treturn labelNames.reduce((acc, label, index) => {\n\t\tacc[label] = argsAsArray[index];\n\t\treturn acc;\n\t}, {});\n};\n\nfunction hashObject(labels) {\n\t// We don't actually need a hash here. We just need a string that\n\t// is unique for each possible labels object and consistent across\n\t// calls with equivalent labels objects.\n\tlet keys = Object.keys(labels);\n\tif (keys.length === 0) {\n\t\treturn '';\n\t}\n\t// else\n\tif (keys.length > 1) {\n\t\tkeys = keys.sort(); // need consistency across calls\n\t}\n\n\tlet hash = '';\n\tlet i = 0;\n\tconst size = keys.length;\n\tfor (; i < size - 1; i++) {\n\t\thash += `${keys[i]}:${labels[keys[i]]},`;\n\t}\n\thash += `${keys[i]}:${labels[keys[i]]}`;\n\treturn hash;\n}\nexports.hashObject = hashObject;\n\nfunction isDate(obj) {\n\treturn obj instanceof Date && !isNaN(obj.valueOf());\n}\nexports.isObject = function isObject(obj) {\n\treturn obj === Object(obj);\n};\n\nfunction printDeprecation(msg) {\n\tif (deprecationsEmitted[msg]) {\n\t\treturn;\n\t}\n\n\tdeprecationsEmitted[msg] = true;\n\n\tif (process.emitWarning) {\n\t\tprocess.emitWarning(msg, 'DeprecationWarning');\n\t} else {\n\t\t// Check can be removed when we only support node@>=6\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.warn(new Error(msg));\n\t}\n}\n\nexports.printDeprecationObjectConstructor = () => {\n\tprintDeprecation(\n\t\t'prom-client - Passing a non-object to metrics constructor is deprecated'\n\t);\n};\n\nexports.printDeprecationCollectDefaultMetricsNumber = timeout => {\n\tprintDeprecation(\n\t\t`prom-client - A number to defaultMetrics is deprecated, please use \\`collectDefaultMetrics({ timeout: ${timeout} })\\`.`\n\t);\n};\n\nclass Grouper extends Map {\n\t/**\n\t * Adds the `value` to the `key`'s array of values.\n\t * @param {*} key Key to set.\n\t * @param {*} value Value to add to `key`'s array.\n\t * @returns {undefined} undefined.\n\t */\n\tadd(key, value) {\n\t\tif (this.has(key)) {\n\t\t\tthis.get(key).push(value);\n\t\t} else {\n\t\t\tthis.set(key, [value]);\n\t\t}\n\t}\n}\n\nexports.Grouper = Grouper;\n","'use strict';\n\nconst util = require('util');\n\n// These are from https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels\nconst metricRegexp = /^[a-zA-Z_:][a-zA-Z0-9_:]*$/;\nconst labelRegexp = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\n\nexports.validateMetricName = function(name) {\n\treturn metricRegexp.test(name);\n};\n\nexports.validateLabelName = function(names) {\n\tlet valid = true;\n\t(names || []).forEach(name => {\n\t\tif (!labelRegexp.test(name)) {\n\t\t\tvalid = false;\n\t\t}\n\t});\n\treturn valid;\n};\n\nexports.validateLabel = function validateLabel(savedLabels, labels) {\n\tObject.keys(labels).forEach(label => {\n\t\tif (savedLabels.indexOf(label) === -1) {\n\t\t\tthrow new Error(\n\t\t\t\t`Added label \"${label}\" is not included in initial labelset: ${util.inspect(\n\t\t\t\t\tsavedLabels\n\t\t\t\t)}`\n\t\t\t);\n\t\t}\n\t});\n};\n","//\n// TDigest:\n//\n// approximate distribution percentiles from a stream of reals\n//\nvar RBTree = require('bintrees').RBTree;\n\nfunction TDigest(delta, K, CX) {\n    // allocate a TDigest structure.\n    //\n    // delta is the compression factor, the max fraction of mass that\n    // can be owned by one centroid (bigger, up to 1.0, means more\n    // compression). delta=false switches off TDigest behavior and treats\n    // the distribution as discrete, with no merging and exact values\n    // reported.\n    //\n    // K is a size threshold that triggers recompression as the TDigest\n    // grows during input.  (Set it to 0 to disable automatic recompression)\n    //\n    // CX specifies how often to update cached cumulative totals used\n    // for quantile estimation during ingest (see cumulate()).  Set to\n    // 0 to use exact quantiles for each new point.\n    //\n    this.discrete = (delta === false);\n    this.delta = delta || 0.01;\n    this.K = (K === undefined) ? 25 : K;\n    this.CX = (CX === undefined) ? 1.1 : CX;\n    this.centroids = new RBTree(compare_centroid_means);\n    this.nreset = 0;\n    this.reset();\n}\n\nTDigest.prototype.reset = function() {\n    // prepare to digest new points.\n    //\n    this.centroids.clear();\n    this.n = 0;\n    this.nreset += 1;\n    this.last_cumulate = 0;\n};\n\nTDigest.prototype.size = function() {\n    return this.centroids.size;\n};\n\nTDigest.prototype.toArray = function(everything) {\n    // return {mean,n} of centroids as an array ordered by mean.\n    //\n    var result = [];\n    if (everything) {\n        this._cumulate(true); // be sure cumns are exact\n        this.centroids.each(function(c) { result.push(c); });\n    } else {\n        this.centroids.each(function(c) { result.push({mean:c.mean, n:c.n}); });\n    }\n    return result;\n};\n\nTDigest.prototype.summary = function() {\n    var approx = (this.discrete) ? \"exact \" : \"approximating \";\n    var s = [approx + this.n + \" samples using \" + this.size() + \" centroids\",\n             \"min = \"+this.percentile(0),\n             \"Q1  = \"+this.percentile(0.25),\n             \"Q2  = \"+this.percentile(0.5),\n             \"Q3  = \"+this.percentile(0.75),\n             \"max = \"+this.percentile(1.0)];\n    return s.join('\\n');\n};\n\nfunction compare_centroid_means(a, b) {\n    // order two centroids by mean.\n    //\n    return (a.mean > b.mean) ? 1 : (a.mean < b.mean) ? -1 : 0;\n}\n\nfunction compare_centroid_mean_cumns(a, b) {\n    // order two centroids by mean_cumn.\n    //\n    return (a.mean_cumn - b.mean_cumn);\n}\n\nTDigest.prototype.push = function(x, n) {\n    // incorporate value or array of values x, having count n into the\n    // TDigest. n defaults to 1.\n    //\n    n = n || 1;\n    x = Array.isArray(x) ? x : [x];\n    for (var i = 0 ; i < x.length ; i++) {\n        this._digest(x[i], n);\n    }\n};\n\nTDigest.prototype.push_centroid = function(c) {\n    // incorporate centroid or array of centroids c\n    //\n    c = Array.isArray(c) ? c : [c];\n    for (var i = 0 ; i < c.length ; i++) {\n        this._digest(c[i].mean, c[i].n);\n    }\n};\n\nTDigest.prototype._cumulate = function(exact) {\n    // update cumulative counts for each centroid\n    //\n    // exact: falsey means only cumulate after sufficient\n    // growth. During ingest, these counts are used as quantile\n    // estimates, and they work well even when somewhat out of\n    // date. (this is a departure from the publication, you may set CX\n    // to 0 to disable).\n    //\n    if (this.n === this.last_cumulate ||\n        !exact && this.CX && this.CX > (this.n / this.last_cumulate)) {\n        return;\n    }\n    var cumn = 0;\n    var self = this;\n    this.centroids.each(function(c) {\n        c.mean_cumn = cumn + c.n / 2; // half of n at the mean\n        cumn = c.cumn = cumn + c.n;\n    });\n    this.n = this.last_cumulate = cumn;\n};\n\nTDigest.prototype.find_nearest = function(x) {\n    // find the centroid closest to x. The assumption of\n    // unique means and a unique nearest centroid departs from the\n    // paper, see _digest() below\n    //\n    if (this.size() === 0) {\n        return null;\n    }\n    var iter = this.centroids.lowerBound({mean:x}); // x <= iter || iter==null\n    var c = (iter.data() === null) ? iter.prev() : iter.data();\n    if (c.mean === x || this.discrete) {\n        return c; // c is either x or a neighbor (discrete: no distance func)\n    }\n    var prev = iter.prev();\n    if (prev && Math.abs(prev.mean - x) < Math.abs(c.mean - x)) {\n        return prev;\n    } else {\n        return c;\n    }\n};\n\nTDigest.prototype._new_centroid = function(x, n, cumn) {\n    // create and insert a new centroid into the digest (don't update\n    // cumulatives).\n    //\n    var c = {mean:x, n:n, cumn:cumn};\n    this.centroids.insert(c);\n    this.n += n;\n    return c;\n};\n\nTDigest.prototype._addweight = function(nearest, x, n) {\n    // add weight at location x to nearest centroid.  adding x to\n    // nearest will not shift its relative position in the tree and\n    // require reinsertion.\n    //\n    if (x !== nearest.mean) {\n        nearest.mean += n * (x - nearest.mean) / (nearest.n + n);\n    }\n    nearest.cumn += n;\n    nearest.mean_cumn += n / 2;\n    nearest.n += n;\n    this.n += n;\n};\n\nTDigest.prototype._digest = function(x, n) {\n    // incorporate value x, having count n into the TDigest.\n    //\n    var min = this.centroids.min();\n    var max = this.centroids.max();\n    var nearest = this.find_nearest(x);\n    if (nearest && nearest.mean === x) {\n        // accumulate exact matches into the centroid without\n        // limit. this is a departure from the paper, made so\n        // centroids remain unique and code can be simple.\n        this._addweight(nearest, x, n);\n    } else if (nearest === min) {\n        this._new_centroid(x, n, 0); // new point around min boundary\n    } else if (nearest === max ) {\n        this._new_centroid(x, n, this.n); // new point around max boundary\n    } else if (this.discrete) {\n        this._new_centroid(x, n, nearest.cumn); // never merge\n    } else {\n        // conider a merge based on nearest centroid's capacity. if\n        // there's not room for all of n, don't bother merging any of\n        // it into nearest, as we'll have to make a new centroid\n        // anyway for the remainder (departure from the paper).\n        var p = nearest.mean_cumn / this.n;\n        var max_n = Math.floor(4 * this.n * this.delta * p * (1 - p));\n        if (max_n - nearest.n >= n) {\n            this._addweight(nearest, x, n);\n        } else {\n            this._new_centroid(x, n, nearest.cumn);\n        }\n    }\n    this._cumulate(false);\n    if (!this.discrete && this.K && this.size() > this.K / this.delta) {\n        // re-process the centroids and hope for some compression.\n        this.compress();\n    }\n};\n\nTDigest.prototype.bound_mean = function(x) {\n    // find centroids lower and upper such that lower.mean < x <\n    // upper.mean or lower.mean === x === upper.mean. Don't call\n    // this for x out of bounds.\n    //\n    var iter = this.centroids.upperBound({mean:x}); // x < iter\n    var lower = iter.prev();      // lower <= x\n    var upper = (lower.mean === x) ? lower : iter.next();\n    return [lower, upper];\n};\n\nTDigest.prototype.p_rank = function(x_or_xlist) {\n    // return approximate percentile-ranks (0..1) for data value x.\n    // or list of x.  calculated according to\n    // https://en.wikipedia.org/wiki/Percentile_rank\n    //\n    // (Note that in continuous mode, boundary sample values will\n    // report half their centroid weight inward from 0/1 as the\n    // percentile-rank. X values outside the observed range return\n    // 0/1)\n    //\n    // this triggers cumulate() if cumn's are out of date.\n    //\n    var xs = Array.isArray(x_or_xlist) ? x_or_xlist : [x_or_xlist];\n    var ps = xs.map(this._p_rank, this);\n    return Array.isArray(x_or_xlist) ? ps : ps[0];\n};\n\nTDigest.prototype._p_rank = function(x) {\n    if (this.size() === 0) {\n        return undefined;\n    } else if (x < this.centroids.min().mean) {\n        return 0.0;\n    } else if (x > this.centroids.max().mean) {\n        return 1.0;\n    }\n    // find centroids that bracket x and interpolate x's cumn from\n    // their cumn's.\n    this._cumulate(true); // be sure cumns are exact\n    var bound = this.bound_mean(x);\n    var lower = bound[0], upper = bound[1];\n    if (this.discrete) {\n        return lower.cumn / this.n;\n    } else {\n        var cumn = lower.mean_cumn;\n        if (lower !== upper) {\n            cumn += (x - lower.mean) * (upper.mean_cumn - lower.mean_cumn) / (upper.mean - lower.mean);\n        }\n        return cumn / this.n;\n    }\n};\n\nTDigest.prototype.bound_mean_cumn = function(cumn) {\n    // find centroids lower and upper such that lower.mean_cumn < x <\n    // upper.mean_cumn or lower.mean_cumn === x === upper.mean_cumn. Don't call\n    // this for cumn out of bounds.\n    //\n    // XXX because mean and mean_cumn give rise to the same sort order\n    // (up to identical means), use the mean rbtree for our search.\n    this.centroids._comparator = compare_centroid_mean_cumns;\n    var iter = this.centroids.upperBound({mean_cumn:cumn}); // cumn < iter\n    this.centroids._comparator = compare_centroid_means;\n    var lower = iter.prev();      // lower <= cumn\n    var upper = (lower && lower.mean_cumn === cumn) ? lower : iter.next();\n    return [lower, upper];\n};\n\nTDigest.prototype.percentile = function(p_or_plist) {\n    // for percentage p (0..1), or for each p in a list of ps, return\n    // the smallest data value q at which at least p percent of the\n    // observations <= q.\n    //\n    // for discrete distributions, this selects q using the Nearest\n    // Rank Method\n    // (https://en.wikipedia.org/wiki/Percentile#The_Nearest_Rank_method)\n    // (in scipy, same as percentile(...., interpolation='higher')\n    //\n    // for continuous distributions, interpolates data values between\n    // count-weighted bracketing means.\n    //\n    // this triggers cumulate() if cumn's are out of date.\n    //\n    var ps = Array.isArray(p_or_plist) ? p_or_plist : [p_or_plist];\n    var qs = ps.map(this._percentile, this);\n    return Array.isArray(p_or_plist) ? qs : qs[0];\n};\n\nTDigest.prototype._percentile = function(p) {\n    if (this.size() === 0) {\n        return undefined;\n    }\n    this._cumulate(true); // be sure cumns are exact\n    var min = this.centroids.min();\n    var max = this.centroids.max();\n    var h = this.n * p;\n    var bound = this.bound_mean_cumn(h);\n    var lower = bound[0], upper = bound[1];\n\n    if (upper === lower || lower === null || upper === null) {\n        return (lower || upper).mean;\n    } else if (!this.discrete) {\n        return lower.mean + (h - lower.mean_cumn) * (upper.mean - lower.mean) / (upper.mean_cumn - lower.mean_cumn);\n    } else if (h <= lower.cumn) {\n        return lower.mean;\n    } else {\n        return upper.mean;\n    }\n};\n\nfunction pop_random(choices) {\n    // remove and return an item randomly chosen from the array of choices\n    // (mutates choices)\n    //\n    var idx = Math.floor(Math.random() * choices.length);\n    return choices.splice(idx, 1)[0];\n}\n\nTDigest.prototype.compress = function() {\n    // TDigests experience worst case compression (none) when input\n    // increases monotonically.  Improve on any bad luck by\n    // reconsuming digest centroids as if they were weighted points\n    // while shuffling their order (and hope for the best).\n    //\n    if (this.compressing) {\n        return;\n    }\n    var points = this.toArray();\n    this.reset();\n    this.compressing = true;\n    while (points.length > 0) {\n        this.push_centroid(pop_random(points));\n    }\n    this._cumulate(true);\n    this.compressing = false;\n};\n\nfunction Digest(config) {\n    // allocate a distribution digest structure. This is an extension\n    // of a TDigest structure that starts in exact histogram (discrete)\n    // mode, and automatically switches to TDigest mode for large\n    // samples that appear to be from a continuous distribution.\n    //\n    this.config = config || {};\n    this.mode = this.config.mode || 'auto'; // disc, cont, auto\n    TDigest.call(this, this.mode === 'cont' ? config.delta : false);\n    this.digest_ratio = this.config.ratio || 0.9;\n    this.digest_thresh = this.config.thresh || 1000;\n    this.n_unique = 0;\n}\nDigest.prototype = Object.create(TDigest.prototype);\nDigest.prototype.constructor = Digest;\n\nDigest.prototype.push = function(x_or_xlist) {\n    TDigest.prototype.push.call(this, x_or_xlist);\n    this.check_continuous();\n};\n\nDigest.prototype._new_centroid = function(x, n, cumn) {\n    this.n_unique += 1;\n    TDigest.prototype._new_centroid.call(this, x, n, cumn);\n};\n\nDigest.prototype._addweight = function(nearest, x, n) {\n    if (nearest.n === 1) {\n        this.n_unique -= 1;\n    }\n    TDigest.prototype._addweight.call(this, nearest, x, n);\n};\n\nDigest.prototype.check_continuous = function() {\n    // while in 'auto' mode, if there are many unique elements, assume\n    // they are from a continuous distribution and switch to 'cont'\n    // mode (tdigest behavior). Return true on transition from\n    // disctete to continuous.\n    if (this.mode !== 'auto' || this.size() < this.digest_thresh) {\n        return false;\n    }\n    if (this.n_unique / this.size() > this.digest_ratio) {\n        this.mode = 'cont';\n        this.discrete = false;\n        this.delta = this.config.delta || 0.01;\n        this.compress();\n        return true;\n    }\n    return false;\n};\n\nmodule.exports = {\n    'TDigest': TDigest,\n    'Digest': Digest\n};\n","module.exports = require(\"cluster\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"http\");","module.exports = require(\"https\");","module.exports = require(\"process\");","module.exports = require(\"stream\");","module.exports = require(\"url\");","module.exports = require(\"util\");","module.exports = require(\"v8\");"],"sourceRoot":""}