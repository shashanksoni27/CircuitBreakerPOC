{"version":3,"sources":["webpack://circuitBreaker/webpack/universalModuleDefinition","webpack://circuitBreaker/webpack/bootstrap","webpack://circuitBreaker/./node_modules/prom-client/lib/gauge.js","webpack://circuitBreaker/./node_modules/prom-client/lib/registry.js","webpack://circuitBreaker/./node_modules/prom-client/lib/util.js","webpack://circuitBreaker/external \"util\"","webpack://circuitBreaker/./node_modules/prom-client/lib/validation.js","webpack://circuitBreaker/external \"fs\"","webpack://circuitBreaker/external \"events\"","webpack://circuitBreaker/./lib/hystrix-stats.js","webpack://circuitBreaker/./node_modules/prom-client/lib/counter.js","webpack://circuitBreaker/./node_modules/bintrees/lib/treebase.js","webpack://circuitBreaker/./node_modules/prom-client/lib/bucketGenerators.js","webpack://circuitBreaker/./node_modules/prom-client/lib/metrics/helpers/safeMemoryUsage.js","webpack://circuitBreaker/./node_modules/prom-client/lib/metricAggregators.js","webpack://circuitBreaker/./index.js","webpack://circuitBreaker/./lib/circuit.js","webpack://circuitBreaker/./lib/status.js","webpack://circuitBreaker/external \"stream\"","webpack://circuitBreaker/./lib/hystrix-formatter.js","webpack://circuitBreaker/./lib/semaphore.js","webpack://circuitBreaker/./lib/prometheus-metrics.js","webpack://circuitBreaker/./node_modules/prom-client/index.js","webpack://circuitBreaker/./node_modules/prom-client/lib/histogram.js","webpack://circuitBreaker/./node_modules/prom-client/lib/summary.js","webpack://circuitBreaker/./node_modules/prom-client/lib/timeWindowQuantiles.js","webpack://circuitBreaker/./node_modules/tdigest/tdigest.js","webpack://circuitBreaker/./node_modules/bintrees/index.js","webpack://circuitBreaker/./node_modules/bintrees/lib/rbtree.js","webpack://circuitBreaker/./node_modules/bintrees/lib/bintree.js","webpack://circuitBreaker/./node_modules/prom-client/lib/pushgateway.js","webpack://circuitBreaker/external \"url\"","webpack://circuitBreaker/external \"http\"","webpack://circuitBreaker/external \"https\"","webpack://circuitBreaker/./node_modules/prom-client/lib/defaultMetrics.js","webpack://circuitBreaker/./node_modules/prom-client/lib/metrics/processCpuTotal.js","webpack://circuitBreaker/./node_modules/prom-client/lib/metrics/processStartTime.js","webpack://circuitBreaker/./node_modules/prom-client/lib/metrics/osMemoryHeap.js","webpack://circuitBreaker/./node_modules/prom-client/lib/metrics/osMemoryHeapLinux.js","webpack://circuitBreaker/./node_modules/prom-client/lib/metrics/processOpenFileDescriptors.js","webpack://circuitBreaker/external \"process\"","webpack://circuitBreaker/./node_modules/prom-client/lib/metrics/processMaxFileDescriptors.js","webpack://circuitBreaker/./node_modules/prom-client/lib/metrics/eventLoopLag.js","webpack://circuitBreaker/./node_modules/prom-client/lib/metrics/processHandles.js","webpack://circuitBreaker/./node_modules/prom-client/lib/metrics/processRequests.js","webpack://circuitBreaker/./node_modules/prom-client/lib/metrics/heapSizeAndUsed.js","webpack://circuitBreaker/./node_modules/prom-client/lib/metrics/heapSpacesSizeAndUsed.js","webpack://circuitBreaker/external \"v8\"","webpack://circuitBreaker/./node_modules/prom-client/lib/metrics/version.js","webpack://circuitBreaker/./node_modules/prom-client/lib/cluster.js","webpack://circuitBreaker/external \"cluster\"","webpack://circuitBreaker/./lib/promisify.js"],"names":["root","factory","exports","module","define","amd","global","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","util","globalRegistry","type","isDate","setValue","getPropertiesFromObj","getLabels","hashObject","isObject","printDeprecationObjectConstructor","removeLabels","validateMetricName","validateLabel","validateLabelName","setToCurrentTime","labels","now","Date","undefined","this","set","startTimer","startLabels","start","process","hrtime","endLabels","delta","assign","dec","timestamp","data","convertLabelsAndValues","_getValue","inc","TypeError","format","Number","isFinite","labelNames","hashMap","[object Object]","help","config","registers","Error","reset","aggregator","forEach","registryInstance","registerMetric","length","values","hash","arguments","getValueAsString","escapeString","str","replace","defaultMetricsOpts","timestamps","Registry","_metrics","_defaultLabels","keys","map","getSingleMetric","metric","conf","opts","item","defaultLabelNames","val","labelName","metricName","substring","line","trim","metrics","getMetricsAsArray","getMetricAsPrometheusString","metricFn","push","contentType","mergedRegistry","reduce","acc","reg","concat","deprecationsEmitted","sort","size","obj","isNaN","valueOf","printDeprecation","msg","emitWarning","console","warn","x","args","argsAsArray","Array","slice","label","index","printDeprecationCollectDefaultMetricsNumber","timeout","Grouper","Map","has","require","metricRegexp","labelRegexp","test","names","valid","savedLabels","indexOf","inspect","Transform","Readable","formatter","hystrixStream","objectMode","transform","stats","encoding","cb","JSON","stringify","resume","HystrixStats","circuit","_readableStream","status","on","closed","group","options","pipe","unpipe","stream","incValue","TreeBase","Iterator","tree","_tree","_ancestors","_cursor","clear","_root","find","res","_comparator","get_child","findIter","iter","iterator","lowerBound","cur","cmp","upperBound","next","min","left","max","right","each","it","reach","prev","_minNode","save","pop","_maxNode","linearBuckets","width","count","buckets","exponentialBuckets","factor","memoryUsage","ex","AggregatorFactory","aggregatorFn","result","byLabels","add","valObj","aggregators","sum","v","first","omit","average","Math","Infinity","CircuitBreaker","circuits","defaults","errorThresholdPercentage","resetTimeout","action","promisify","lastCircuit","warningIssued","_","default","EventEmitter","Status","Semaphore","PrometheusMetrics","env","WEB","STATE","OPEN","CLOSED","HALF_OPEN","PENDING_CLOSE","SHUTDOWN","FALLBACK_FUNCTION","STATUS","NAME","GROUP","HYSTRIX_STATS","PROMETHEUS_METRICS","CACHE","WeakMap","ENABLED","WARMING_UP","VOLUME_THRESHOLD","deprecation","super","rollingCountTimeout","rollingCountBuckets","rollingPercentilesEnabled","capacity","isInteger","MAX_SAFE_INTEGER","errorFilter","semaphore","volumeThreshold","allowWarmUp","nextName","enabled","timer","setTimeout","unref","Promise","resolve","maxFailures","error","increment","runTime","open","close","emit","cache","usePrometheus","disable","removeAllListeners","shutdown","hystrixStats","isShutdown","pendingClose","opened","halfOpen","warmUp","func","fb","fire","apply","err","code","reject","then","fallback","timeoutError","latencyStartTime","latency","release","handleError","promise","clearTimeout","catch","latencyEndTime","interval","check","e","setInterval","fires","failures","fail","random","toString","WINDOW","BUCKETS","TIMEOUT","PERCENTILES","nextBucket","window","unshift","bucket","fallbacks","successes","rejects","timeouts","cacheHits","cacheMisses","semaphoreRejections","percentiles","latencyTimes","bucketInterval","floor","totals","a","b","latencyMean","percentile","arr","idx","ceil","calculatePercentile","latencyRunTime","isCircuitBreakerOpen","0","25","50","75","90","95","99","99.5","100","currentTime","errorPercentage","errorCount","requestCount","rollingCountBadRequests","rollingCountCollapsedRequests","rollingCountEmit","rollingCountExceptionsThrown","rollingCountFailure","rollingCountFallbackEmit","rollingCountFallbackFailure","rollingCountFallbackMissing","rollingCountFallbackRejection","rollingCountFallbackSuccess","rollingCountResponsesFromCache","rollingCountSemaphoreRejected","rollingCountShortCircuited","rollingCountSuccess","rollingCountThreadPoolRejected","currentConcurrentExecutionCount","rollingMaxConcurrentExecutionCount","latencyExecute_mean","latencyExecute","latencyTotal_mean","latencyTotal","propertyValue_circuitBreakerRequestVolumeThreshold","propertyValue_circuitBreakerSleepWindowInMilliseconds","propertyValue_circuitBreakerErrorThresholdPercentage","propertyValue_circuitBreakerForceOpen","propertyValue_circuitBreakerForceClosed","propertyValue_circuitBreakerEnabled","propertyValue_executionIsolationStrategy","propertyValue_executionIsolationThreadTimeoutInMilliseconds","propertyValue_executionTimeoutInMilliseconds","propertyValue_executionIsolationThreadInterruptOnTimeout","propertyValue_executionIsolationThreadPoolKeyOverride","propertyValue_executionIsolationSemaphoreMaxConcurrentRequests","propertyValue_fallbackIsolationSemaphoreMaxConcurrentRequests","propertyValue_metricsRollingStatisticalWindowInMilliseconds","propertyValue_requestCacheEnabled","propertyValue_requestLogEnabled","reportingHosts","resolvers","counter","sem","take","shift","client","_client","counters","prefix","collectDefaultMetrics","eventName","eventNames","Counter","clearInterval","register","Gauge","Histogram","Summary","Pushgateway","AggregatorRegistry","observe","sortAscending","y","setValuePair","labelValuePair","valueFromMap","createBaseValues","bucketValues","upperBounds","bound","findBound","labelsOrConf","isArray","configuredBuckets","validateInput","freeze","histogram","bucketData","bucketLabelNames","lbls","le","infLabel","addSumAndCountForExport","timeWindowQuantiles","summaryOfLabel","td","maxAgeSeconds","ageBuckets","configuredPercentiles","summaryOfLabels","compress","percentileValue","quantile","extractSummariesForExport","summary","getSumForExport","getCountForExport","TDigest","rotate","timeSinceLastRotateMillis","lastRotateTimestampMillis","durationBetweenRotatesMillis","shouldRotate","ringBuffer","currentBuffer","fill","RBTree","K","CX","discrete","centroids","compare_centroid_means","nreset","mean","compare_centroid_mean_cumns","mean_cumn","Digest","digest_ratio","ratio","digest_thresh","thresh","n_unique","last_cumulate","toArray","everything","_cumulate","join","_digest","push_centroid","exact","cumn","find_nearest","abs","_new_centroid","insert","_addweight","nearest","bound_mean","lower","p_rank","x_or_xlist","ps","_p_rank","upper","bound_mean_cumn","p_or_plist","qs","_percentile","h","compressing","choices","points","splice","constructor","check_continuous","BinTree","Node","red","comparator","is_red","node","single_rotate","dir","set_child","double_rotate","ret","head","last","gp","ggp","dir2","remove","found","sr","sibling","gpc","url","http","https","useGateway","method","job","groupings","callback","gatewayUrlParsed","parse","gatewayUrl","path","pathname","encodeURIComponent","generateGroupings","target","requestParams","httpModule","href","search","requestOptions","req","request","body","setEncoding","chunk","write","registry","end","params","jobName","processCpuTotal","processStartTime","osMemoryHeap","processOpenFileDescriptors","processMaxFileDescriptors","eventLoopLag","processHandles","processRequests","heapSizeAndUsed","heapSpacesSizeAndUsed","version","metricsList","existingInterval","init","normalizedConfig","initialisedMetrics","defaultMetric","metricNames","removeSingleMetric","updateAllMetrics","cpuUsage","namePrefix","cpuUserUsageCounter","cpuSystemUsageCounter","cpuUsageCounter","lastCpuUsage","userUsageMicros","user","systemUsageMicros","system","nowInSeconds","round","uptime","cpuUserGauge","isSet","linuxVariant","safeMemoryUsage","PROCESS_RESIDENT_MEMORY","platform","residentMemGauge","memUsage","rss","notLinuxVariant","fs","virtualMemGauge","heapSizeMemGauge","readFile","structuredOutput","input","returnValue","split","filter","some","string","substr","structureOutput","VmRSS","VmSize","VmData","fileDescriptorsGauge","readdir","list","maxFds","reportEventloopLag","gauge","seconds","setImmediate","_getActiveHandles","_getActiveRequests","heapSizeTotal","heapSizeUsed","externalMemUsed","usage","external","heapTotal","heapUsed","total","used","v8","METRICS","NODEJS_HEAP_SIZE","metricType","getHeapSpaceStatistics","gauges","available","space","spaceName","space_name","space_size","space_used_size","space_available_size","versionSegments","nodeVersionGauge","cluster","GET_METRICS_REQ","GET_METRICS_RES","registries","requestCtr","listenersAdded","requests","isMaster","worker","message","requestId","responses","pending","delete","errorTimeout","failed","aggregate","promString","done","addListeners","id","workers","isConnected","send","nextTick","metricsArr","aggregatedRegistry","metricsByName","aggregatorName","aggregatedMetric","aggregatedMetricWrapper","regs","isWorker","getMetricsAsJSON"],"mappings":"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","file":"opossum.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"circuitBreaker\"] = factory();\n\telse\n\t\troot[\"circuitBreaker\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 13);\n","/**\n * Gauge metric\n */\n'use strict';\n\nconst util = require('util');\nconst { globalRegistry } = require('./registry');\nconst type = 'gauge';\n\nconst {\n\tisDate,\n\tsetValue,\n\tgetPropertiesFromObj,\n\tgetLabels,\n\thashObject,\n\tisObject,\n\tprintDeprecationObjectConstructor,\n\tremoveLabels\n} = require('./util');\nconst {\n\tvalidateMetricName,\n\tvalidateLabel,\n\tvalidateLabelName\n} = require('./validation');\n\nclass Gauge {\n\t/**\n\t * Gauge\n\t * @param {string} name - Name of the metric\n\t * @param {string} help - Help for the metric\n\t * @param {Array.<string>} labels - Array with strings, all label keywords supported\n\t */\n\tconstructor(name, help, labels) {\n\t\tlet config;\n\t\tif (isObject(name)) {\n\t\t\tconfig = Object.assign(\n\t\t\t\t{\n\t\t\t\t\tlabelNames: []\n\t\t\t\t},\n\t\t\t\tname\n\t\t\t);\n\n\t\t\tif (!config.registers) {\n\t\t\t\tconfig.registers = [globalRegistry];\n\t\t\t}\n\t\t} else {\n\t\t\tprintDeprecationObjectConstructor();\n\t\t\tconfig = {\n\t\t\t\tname,\n\t\t\t\thelp,\n\t\t\t\tlabelNames: labels,\n\t\t\t\tregisters: [globalRegistry]\n\t\t\t};\n\t\t}\n\n\t\tif (!config.help) {\n\t\t\tthrow new Error('Missing mandatory help parameter');\n\t\t}\n\t\tif (!config.name) {\n\t\t\tthrow new Error('Missing mandatory name parameter');\n\t\t}\n\t\tif (!validateMetricName(config.name)) {\n\t\t\tthrow new Error('Invalid metric name');\n\t\t}\n\t\tif (!validateLabelName(config.labelNames)) {\n\t\t\tthrow new Error('Invalid label name');\n\t\t}\n\n\t\tthis.name = config.name;\n\t\tthis.labelNames = config.labelNames || [];\n\t\tthis.reset();\n\t\tthis.help = config.help;\n\t\tthis.aggregator = config.aggregator || 'sum';\n\n\t\tconfig.registers.forEach(registryInstance =>\n\t\t\tregistryInstance.registerMetric(this)\n\t\t);\n\t}\n\n\t/**\n\t * Set a gauge to a value\n\t * @param {object} labels - Object with labels and their values\n\t * @param {Number} value - Value to set the gauge to, must be positive\n\t * @param {(Number|Date)} timestamp - Timestamp to set the gauge to\n\t * @returns {void}\n\t */\n\tset(labels, value, timestamp) {\n\t\tif (!isObject(labels)) {\n\t\t\treturn set.call(this, null)(labels, value);\n\t\t}\n\t\treturn set.call(this, labels)(value, timestamp);\n\t}\n\n\t/**\n\t * Reset gauge\n\t * @returns {void}\n\t */\n\treset() {\n\t\treturn reset.call(this);\n\t}\n\n\t/**\n\t * Increment a gauge value\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @param {Number} value - Value to increment - if omitted, increment with 1\n\t * @param {(Number|Date)} timestamp - Timestamp to set the gauge to\n\t * @returns {void}\n\t */\n\tinc(labels, value, timestamp) {\n\t\tinc.call(this, labels)(value, timestamp);\n\t}\n\n\t/**\n\t * Decrement a gauge value\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @param {Number} value - Value to decrement - if omitted, decrement with 1\n\t * @param {(Number|Date)} timestamp - Timestamp to set the gauge to\n\t * @returns {void}\n\t */\n\tdec(labels, value, timestamp) {\n\t\tdec.call(this, labels)(value, timestamp);\n\t}\n\n\t/**\n\t * Set the gauge to current unix epoch\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @returns {void}\n\t */\n\tsetToCurrentTime(labels) {\n\t\treturn setToCurrentTime.call(this, labels)();\n\t}\n\n\t/**\n\t * Start a timer\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @returns {function} - Invoke this function to set the duration in seconds since you started the timer.\n\t * @example\n\t * var done = gauge.startTimer();\n\t * makeXHRRequest(function(err, response) {\n\t *\tdone(); //Duration of the request will be saved\n\t * });\n\t */\n\tstartTimer(labels) {\n\t\treturn startTimer.call(this, labels)();\n\t}\n\n\tget() {\n\t\treturn {\n\t\t\thelp: this.help,\n\t\t\tname: this.name,\n\t\t\ttype,\n\t\t\tvalues: getPropertiesFromObj(this.hashMap),\n\t\t\taggregator: this.aggregator\n\t\t};\n\t}\n\n\t_getValue(labels) {\n\t\tconst hash = hashObject(labels || {});\n\t\treturn this.hashMap[hash] ? this.hashMap[hash].value : 0;\n\t}\n\n\tlabels() {\n\t\tconst labels = getLabels(this.labelNames, arguments);\n\t\treturn {\n\t\t\tinc: inc.call(this, labels),\n\t\t\tdec: dec.call(this, labels),\n\t\t\tset: set.call(this, labels),\n\t\t\tsetToCurrentTime: setToCurrentTime.call(this, labels),\n\t\t\tstartTimer: startTimer.call(this, labels)\n\t\t};\n\t}\n\n\tremove() {\n\t\tconst labels = getLabels(this.labelNames, arguments);\n\t\tremoveLabels.call(this, this.hashMap, labels);\n\t}\n}\n\nfunction setToCurrentTime(labels) {\n\treturn () => {\n\t\tconst now = Date.now() / 1000;\n\t\tif (labels === undefined) {\n\t\t\tthis.set(now);\n\t\t} else {\n\t\t\tthis.set(labels, now);\n\t\t}\n\t};\n}\n\nfunction startTimer(startLabels) {\n\treturn () => {\n\t\tconst start = process.hrtime();\n\t\treturn endLabels => {\n\t\t\tconst delta = process.hrtime(start);\n\t\t\tthis.set(\n\t\t\t\tObject.assign({}, startLabels, endLabels),\n\t\t\t\tdelta[0] + delta[1] / 1e9\n\t\t\t);\n\t\t};\n\t};\n}\n\nfunction dec(labels) {\n\treturn (value, timestamp) => {\n\t\tconst data = convertLabelsAndValues(labels, value);\n\t\tthis.set(\n\t\t\tdata.labels,\n\t\t\tthis._getValue(data.labels) - (data.value || 1),\n\t\t\ttimestamp\n\t\t);\n\t};\n}\n\nfunction inc(labels) {\n\treturn (value, timestamp) => {\n\t\tconst data = convertLabelsAndValues(labels, value);\n\t\tthis.set(\n\t\t\tdata.labels,\n\t\t\tthis._getValue(data.labels) + (data.value || 1),\n\t\t\ttimestamp\n\t\t);\n\t};\n}\n\nfunction set(labels) {\n\treturn (value, timestamp) => {\n\t\tif (typeof value !== 'number') {\n\t\t\tthrow new TypeError(`Value is not a valid number: ${util.format(value)}`);\n\t\t}\n\t\tif (timestamp && !isDate(timestamp) && !Number.isFinite(timestamp)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t`Timestamp is not a valid date or number: ${util.format(timestamp)}`\n\t\t\t);\n\t\t}\n\n\t\tlabels = labels || {};\n\n\t\tvalidateLabel(this.labelNames, labels);\n\t\tthis.hashMap = setValue(this.hashMap, value, labels, timestamp);\n\t};\n}\n\nfunction reset() {\n\tthis.hashMap = {};\n\n\tif (this.labelNames.length === 0) {\n\t\tthis.hashMap = setValue({}, 0, {});\n\t}\n}\n\nfunction convertLabelsAndValues(labels, value) {\n\tif (!isObject(labels)) {\n\t\treturn {\n\t\t\tvalue: labels,\n\t\t\tlabels: {}\n\t\t};\n\t}\n\treturn {\n\t\tlabels,\n\t\tvalue\n\t};\n}\n\nmodule.exports = Gauge;\n","'use strict';\nconst { getValueAsString } = require('./util');\n\nfunction escapeString(str) {\n\treturn str.replace(/\\n/g, '\\\\n').replace(/\\\\(?!n)/g, '\\\\\\\\');\n}\nfunction escapeLabelValue(str) {\n\tif (typeof str !== 'string') {\n\t\treturn str;\n\t}\n\treturn escapeString(str).replace(/\"/g, '\\\\\"');\n}\n\nconst defaultMetricsOpts = {\n\ttimestamps: true\n};\n\nclass Registry {\n\tconstructor() {\n\t\tthis._metrics = {};\n\t\tthis._defaultLabels = {};\n\t}\n\n\tgetMetricsAsArray() {\n\t\treturn Object.keys(this._metrics).map(this.getSingleMetric, this);\n\t}\n\n\tgetMetricAsPrometheusString(metric, conf) {\n\t\tconst opts = Object.assign({}, defaultMetricsOpts, conf);\n\t\tconst item = metric.get();\n\t\tconst name = escapeString(item.name);\n\t\tconst help = `# HELP ${name} ${escapeString(item.help)}`;\n\t\tconst type = `# TYPE ${name} ${item.type}`;\n\t\tconst defaultLabelNames = Object.keys(this._defaultLabels);\n\n\t\tlet values = '';\n\t\tfor (const val of item.values || []) {\n\t\t\tval.labels = val.labels || {};\n\t\t\tfor (const labelName of defaultLabelNames) {\n\t\t\t\tval.labels[labelName] =\n\t\t\t\t\tval.labels[labelName] || this._defaultLabels[labelName];\n\t\t\t}\n\n\t\t\tlet labels = '';\n\t\t\tfor (const key of Object.keys(val.labels)) {\n\t\t\t\tlabels += `${key}=\"${escapeLabelValue(val.labels[key])}\",`;\n\t\t\t}\n\n\t\t\tlet metricName = val.metricName || item.name;\n\t\t\tif (labels) {\n\t\t\t\tmetricName += `{${labels.substring(0, labels.length - 1)}}`;\n\t\t\t}\n\n\t\t\tlet line = `${metricName} ${getValueAsString(val.value)}`;\n\t\t\tif (opts.timestamps && val.timestamp) {\n\t\t\t\tline += ` ${val.timestamp}`;\n\t\t\t}\n\t\t\tvalues += `${line.trim()}\\n`;\n\t\t}\n\n\t\treturn `${help}\\n${type}\\n${values}`.trim();\n\t}\n\n\tmetrics(opts) {\n\t\tlet metrics = '';\n\n\t\tfor (const metric of this.getMetricsAsArray()) {\n\t\t\tmetrics += `${this.getMetricAsPrometheusString(metric, opts)}\\n\\n`;\n\t\t}\n\n\t\treturn metrics.substring(0, metrics.length - 1);\n\t}\n\n\tregisterMetric(metricFn) {\n\t\tif (\n\t\t\tthis._metrics[metricFn.name] &&\n\t\t\tthis._metrics[metricFn.name] !== metricFn\n\t\t) {\n\t\t\tthrow new Error(\n\t\t\t\t`A metric with the name ${metricFn.name} has already been registered.`\n\t\t\t);\n\t\t}\n\n\t\tthis._metrics[metricFn.name] = metricFn;\n\t}\n\n\tclear() {\n\t\tthis._metrics = {};\n\t\tthis._defaultLabels = {};\n\t}\n\n\tgetMetricsAsJSON() {\n\t\tconst metrics = [];\n\t\tconst defaultLabelNames = Object.keys(this._defaultLabels);\n\n\t\tfor (const metric of this.getMetricsAsArray()) {\n\t\t\tconst item = metric.get();\n\n\t\t\tif (item.values) {\n\t\t\t\tfor (const val of item.values) {\n\t\t\t\t\tfor (const labelName of defaultLabelNames) {\n\t\t\t\t\t\tval.labels[labelName] =\n\t\t\t\t\t\t\tval.labels[labelName] || this._defaultLabels[labelName];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmetrics.push(item);\n\t\t}\n\n\t\treturn metrics;\n\t}\n\n\tremoveSingleMetric(name) {\n\t\tdelete this._metrics[name];\n\t}\n\n\tgetSingleMetricAsString(name) {\n\t\treturn this.getMetricAsPrometheusString(this._metrics[name]);\n\t}\n\n\tgetSingleMetric(name) {\n\t\treturn this._metrics[name];\n\t}\n\n\tsetDefaultLabels(labels) {\n\t\tthis._defaultLabels = labels;\n\t}\n\n\tresetMetrics() {\n\t\tfor (const metric in this._metrics) {\n\t\t\tthis._metrics[metric].reset();\n\t\t}\n\t}\n\n\tget contentType() {\n\t\treturn 'text/plain; version=0.0.4; charset=utf-8';\n\t}\n\n\tstatic merge(registers) {\n\t\tconst mergedRegistry = new Registry();\n\n\t\tconst metricsToMerge = registers.reduce(\n\t\t\t(acc, reg) => acc.concat(reg.getMetricsAsArray()),\n\t\t\t[]\n\t\t);\n\n\t\tmetricsToMerge.forEach(mergedRegistry.registerMetric, mergedRegistry);\n\t\treturn mergedRegistry;\n\t}\n}\n\nmodule.exports = Registry;\nmodule.exports.globalRegistry = new Registry();\n","'use strict';\n\nconst deprecationsEmitted = {};\n\nexports.isDate = isDate;\n\nexports.getPropertiesFromObj = function(hashMap) {\n\tconst obj = Object.keys(hashMap).map(x => hashMap[x]);\n\treturn obj;\n};\n\nexports.getValueAsString = function getValueString(value) {\n\tif (Number.isNaN(value)) {\n\t\treturn 'Nan';\n\t} else if (!Number.isFinite(value)) {\n\t\tif (value < 0) {\n\t\t\treturn '-Inf';\n\t\t} else {\n\t\t\treturn '+Inf';\n\t\t}\n\t} else {\n\t\treturn `${value}`;\n\t}\n};\n\nexports.removeLabels = function removeLabels(hashMap, labels) {\n\tconst hash = hashObject(labels);\n\tdelete hashMap[hash];\n};\n\nexports.setValue = function setValue(hashMap, value, labels, timestamp) {\n\tconst hash = hashObject(labels);\n\thashMap[hash] = {\n\t\tvalue: typeof value === 'number' ? value : 0,\n\t\tlabels: labels || {},\n\t\ttimestamp: isDate(timestamp)\n\t\t\t? timestamp.valueOf()\n\t\t\t: Number.isFinite(timestamp)\n\t\t\t? timestamp\n\t\t\t: undefined\n\t};\n\treturn hashMap;\n};\n\n// TODO: For node 6, use rest params\nexports.getLabels = function(labelNames, args) {\n\tif (labelNames.length !== args.length) {\n\t\tthrow new Error('Invalid number of arguments');\n\t}\n\n\tconst argsAsArray = Array.prototype.slice.call(args);\n\treturn labelNames.reduce((acc, label, index) => {\n\t\tacc[label] = argsAsArray[index];\n\t\treturn acc;\n\t}, {});\n};\n\nfunction hashObject(labels) {\n\t// We don't actually need a hash here. We just need a string that\n\t// is unique for each possible labels object and consistent across\n\t// calls with equivalent labels objects.\n\tlet keys = Object.keys(labels);\n\tif (keys.length === 0) {\n\t\treturn '';\n\t}\n\t// else\n\tif (keys.length > 1) {\n\t\tkeys = keys.sort(); // need consistency across calls\n\t}\n\n\tlet hash = '';\n\tlet i = 0;\n\tconst size = keys.length;\n\tfor (; i < size - 1; i++) {\n\t\thash += `${keys[i]}:${labels[keys[i]]},`;\n\t}\n\thash += `${keys[i]}:${labels[keys[i]]}`;\n\treturn hash;\n}\nexports.hashObject = hashObject;\n\nfunction isDate(obj) {\n\treturn obj instanceof Date && !isNaN(obj.valueOf());\n}\nexports.isObject = function isObject(obj) {\n\treturn obj === Object(obj);\n};\n\nfunction printDeprecation(msg) {\n\tif (deprecationsEmitted[msg]) {\n\t\treturn;\n\t}\n\n\tdeprecationsEmitted[msg] = true;\n\n\tif (process.emitWarning) {\n\t\tprocess.emitWarning(msg, 'DeprecationWarning');\n\t} else {\n\t\t// Check can be removed when we only support node@>=6\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.warn(new Error(msg));\n\t}\n}\n\nexports.printDeprecationObjectConstructor = () => {\n\tprintDeprecation(\n\t\t'prom-client - Passing a non-object to metrics constructor is deprecated'\n\t);\n};\n\nexports.printDeprecationCollectDefaultMetricsNumber = timeout => {\n\tprintDeprecation(\n\t\t`prom-client - A number to defaultMetrics is deprecated, please use \\`collectDefaultMetrics({ timeout: ${timeout} })\\`.`\n\t);\n};\n\nclass Grouper extends Map {\n\t/**\n\t * Adds the `value` to the `key`'s array of values.\n\t * @param {*} key Key to set.\n\t * @param {*} value Value to add to `key`'s array.\n\t * @returns {undefined} undefined.\n\t */\n\tadd(key, value) {\n\t\tif (this.has(key)) {\n\t\t\tthis.get(key).push(value);\n\t\t} else {\n\t\t\tthis.set(key, [value]);\n\t\t}\n\t}\n}\n\nexports.Grouper = Grouper;\n","module.exports = require(\"util\");","'use strict';\n\nconst util = require('util');\n\n// These are from https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels\nconst metricRegexp = /^[a-zA-Z_:][a-zA-Z0-9_:]*$/;\nconst labelRegexp = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\n\nexports.validateMetricName = function(name) {\n\treturn metricRegexp.test(name);\n};\n\nexports.validateLabelName = function(names) {\n\tlet valid = true;\n\t(names || []).forEach(name => {\n\t\tif (!labelRegexp.test(name)) {\n\t\t\tvalid = false;\n\t\t}\n\t});\n\treturn valid;\n};\n\nexports.validateLabel = function validateLabel(savedLabels, labels) {\n\tObject.keys(labels).forEach(label => {\n\t\tif (savedLabels.indexOf(label) === -1) {\n\t\t\tthrow new Error(\n\t\t\t\t`Added label \"${label}\" is not included in initial labelset: ${util.inspect(\n\t\t\t\t\tsavedLabels\n\t\t\t\t)}`\n\t\t\t);\n\t\t}\n\t});\n};\n","module.exports = require(\"fs\");","module.exports = require(\"events\");","'use strict';\n\nconst { Transform, Readable } = require('stream');\nconst formatter = require('./hystrix-formatter');\n\n// use a single hystrix stream for all circuits\nconst hystrixStream = new Transform({\n  objectMode: true,\n  transform (stats, encoding, cb) {\n    return cb(null, `data: ${JSON.stringify(formatter(stats))}\\n\\n`);\n  }\n});\n\nhystrixStream.resume();\n\n/**\n * Stream Hystrix Metrics for a given {@link CircuitBreaker}.\n * A HystrixStats instance is created for every {@link CircuitBreaker}\n * and does not typically need to be created by a user.\n *\n * A HystrixStats instance will listen for all events on the\n * {@link Status#snapshot}\n * and format the data to the proper Hystrix format.\n * Making it easy to construct an Event Stream for a client\n *\n * @class HystrixStats\n * @example\n * const circuit = circuitBreaker(fs.readFile, {});\n *\n * circuit.hystrixStats.getHystrixStream().pipe(response);\n * @param {CircuitBreaker} the circuit breaker\n * @see CircuitBreaker#hystrixStats\n */\nclass HystrixStats {\n  constructor (circuit) {\n    this._readableStream = new Readable({\n      objectMode: true,\n      read () {}\n    });\n\n    // Listen for the stats's snapshot event\n    circuit.status.on('snapshot', function snapshotListener (stats) {\n      // when we get a snapshot push it onto the stream\n      this._readableStream.push(\n        Object.assign({},\n          {\n            name: circuit.name,\n            closed: circuit.closed,\n            group: circuit.group,\n            options: circuit.options\n          }, stats));\n    }.bind(this));\n\n    this._readableStream.resume();\n    this._readableStream.pipe(hystrixStream);\n  }\n\n  /**\n    A convenience function that returns the hystrixStream\n    @returns {ReadableStream} the statistics stream\n  */\n  getHystrixStream () {\n    return hystrixStream;\n  }\n\n  /**\n   * Shuts down this instance, freeing memory.\n   * When a circuit is shutdown, it should call shutdown() on\n   * its HystrixStats instance to avoid memory leaks.\n   * @returns {void}\n   */\n  shutdown () {\n    this._readableStream.unpipe(hystrixStream);\n  }\n}\n\nHystrixStats.stream = hystrixStream;\n\nmodule.exports = exports = HystrixStats;\n","/**\n * Counter metric\n */\n'use strict';\n\nconst util = require('util');\nconst { globalRegistry } = require('./registry');\nconst type = 'counter';\nconst {\n\tisDate,\n\tgetPropertiesFromObj,\n\thashObject,\n\tisObject,\n\tprintDeprecationObjectConstructor,\n\tgetLabels,\n\tremoveLabels\n} = require('./util');\n\nconst {\n\tvalidateLabel,\n\tvalidateMetricName,\n\tvalidateLabelName\n} = require('./validation');\n\nclass Counter {\n\t/**\n\t * Counter\n\t * @param {string} name - Name of the metric\n\t * @param {string} help - Help description for the metric\n\t * @param {Array.<string>} labels - Labels\n\t */\n\tconstructor(name, help, labels) {\n\t\tlet config;\n\t\tif (isObject(name)) {\n\t\t\tconfig = Object.assign(\n\t\t\t\t{\n\t\t\t\t\tlabelNames: []\n\t\t\t\t},\n\t\t\t\tname\n\t\t\t);\n\n\t\t\tif (!config.registers) {\n\t\t\t\tconfig.registers = [globalRegistry];\n\t\t\t}\n\t\t} else {\n\t\t\tprintDeprecationObjectConstructor();\n\n\t\t\tconfig = {\n\t\t\t\tname,\n\t\t\t\thelp,\n\t\t\t\tlabelNames: labels,\n\t\t\t\tregisters: [globalRegistry]\n\t\t\t};\n\t\t}\n\n\t\tif (!config.help) {\n\t\t\tthrow new Error('Missing mandatory help parameter');\n\t\t}\n\t\tif (!config.name) {\n\t\t\tthrow new Error('Missing mandatory name parameter');\n\t\t}\n\t\tif (!validateMetricName(config.name)) {\n\t\t\tthrow new Error('Invalid metric name');\n\t\t}\n\n\t\tif (!validateLabelName(config.labelNames)) {\n\t\t\tthrow new Error('Invalid label name');\n\t\t}\n\n\t\tthis.name = config.name;\n\n\t\tthis.labelNames = config.labelNames || [];\n\n\t\tthis.reset();\n\n\t\tthis.help = config.help;\n\t\tthis.aggregator = config.aggregator || 'sum';\n\n\t\tconfig.registers.forEach(registryInstance =>\n\t\t\tregistryInstance.registerMetric(this)\n\t\t);\n\t}\n\n\t/**\n\t * Increment counter\n\t * @param {object} labels - What label you want to be incremented\n\t * @param {Number} value - Value to increment, if omitted increment with 1\n\t * @param {(Number|Date)} timestamp - Timestamp to set the counter to\n\t * @returns {void}\n\t */\n\tinc(labels, value, timestamp) {\n\t\tif (!isObject(labels)) {\n\t\t\treturn inc.call(this, null)(labels, value);\n\t\t}\n\n\t\tconst hash = hashObject(labels);\n\t\treturn inc.call(this, labels, hash)(value, timestamp);\n\t}\n\n\t/**\n\t * Reset counter\n\t * @returns {void}\n\t */\n\treset() {\n\t\treturn reset.call(this);\n\t}\n\n\tget() {\n\t\treturn {\n\t\t\thelp: this.help,\n\t\t\tname: this.name,\n\t\t\ttype,\n\t\t\tvalues: getPropertiesFromObj(this.hashMap),\n\t\t\taggregator: this.aggregator\n\t\t};\n\t}\n\n\tlabels() {\n\t\tconst labels = getLabels(this.labelNames, arguments) || {};\n\t\tconst hash = hashObject(labels);\n\t\tvalidateLabel(this.labelNames, labels);\n\t\treturn {\n\t\t\tinc: inc.call(this, labels, hash)\n\t\t};\n\t}\n\n\tremove() {\n\t\tconst labels = getLabels(this.labelNames, arguments) || {};\n\t\treturn removeLabels.call(this, this.hashMap, labels);\n\t}\n}\n\nconst reset = function() {\n\tthis.hashMap = {};\n\n\tif (this.labelNames.length === 0) {\n\t\tthis.hashMap = setValue({}, 0);\n\t}\n};\n\nconst inc = function(labels, hash) {\n\treturn (value, timestamp) => {\n\t\tif (value && !Number.isFinite(value)) {\n\t\t\tthrow new TypeError(`Value is not a valid number: ${util.format(value)}`);\n\t\t}\n\t\tif (timestamp && !isDate(timestamp) && !Number.isFinite(timestamp)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t`Timestamp is not a valid date or number: ${util.format(timestamp)}`\n\t\t\t);\n\t\t}\n\t\tif (value < 0) {\n\t\t\tthrow new Error('It is not possible to decrease a counter');\n\t\t}\n\n\t\tlabels = labels || {};\n\t\tvalidateLabel(this.labelNames, labels);\n\n\t\tconst incValue = value === null || value === undefined ? 1 : value;\n\n\t\tthis.hashMap = setValue(this.hashMap, incValue, timestamp, labels, hash);\n\t};\n};\n\nfunction setValue(hashMap, value, timestamp, labels, hash) {\n\thash = hash || '';\n\ttimestamp = isDate(timestamp)\n\t\t? timestamp.valueOf()\n\t\t: Number.isFinite(timestamp)\n\t\t? timestamp\n\t\t: undefined;\n\tif (hashMap[hash]) {\n\t\thashMap[hash].value += value;\n\t\thashMap[hash].timestamp = timestamp;\n\t} else {\n\t\thashMap[hash] = { value, labels: labels || {}, timestamp };\n\t}\n\treturn hashMap;\n}\n\nmodule.exports = Counter;\n","\nfunction TreeBase() {}\n\n// removes all nodes from the tree\nTreeBase.prototype.clear = function() {\n    this._root = null;\n    this.size = 0;\n};\n\n// returns node data if found, null otherwise\nTreeBase.prototype.find = function(data) {\n    var res = this._root;\n\n    while(res !== null) {\n        var c = this._comparator(data, res.data);\n        if(c === 0) {\n            return res.data;\n        }\n        else {\n            res = res.get_child(c > 0);\n        }\n    }\n\n    return null;\n};\n\n// returns iterator to node if found, null otherwise\nTreeBase.prototype.findIter = function(data) {\n    var res = this._root;\n    var iter = this.iterator();\n\n    while(res !== null) {\n        var c = this._comparator(data, res.data);\n        if(c === 0) {\n            iter._cursor = res;\n            return iter;\n        }\n        else {\n            iter._ancestors.push(res);\n            res = res.get_child(c > 0);\n        }\n    }\n\n    return null;\n};\n\n// Returns an iterator to the tree node at or immediately after the item\nTreeBase.prototype.lowerBound = function(item) {\n    var cur = this._root;\n    var iter = this.iterator();\n    var cmp = this._comparator;\n\n    while(cur !== null) {\n        var c = cmp(item, cur.data);\n        if(c === 0) {\n            iter._cursor = cur;\n            return iter;\n        }\n        iter._ancestors.push(cur);\n        cur = cur.get_child(c > 0);\n    }\n\n    for(var i=iter._ancestors.length - 1; i >= 0; --i) {\n        cur = iter._ancestors[i];\n        if(cmp(item, cur.data) < 0) {\n            iter._cursor = cur;\n            iter._ancestors.length = i;\n            return iter;\n        }\n    }\n\n    iter._ancestors.length = 0;\n    return iter;\n};\n\n// Returns an iterator to the tree node immediately after the item\nTreeBase.prototype.upperBound = function(item) {\n    var iter = this.lowerBound(item);\n    var cmp = this._comparator;\n\n    while(iter.data() !== null && cmp(iter.data(), item) === 0) {\n        iter.next();\n    }\n\n    return iter;\n};\n\n// returns null if tree is empty\nTreeBase.prototype.min = function() {\n    var res = this._root;\n    if(res === null) {\n        return null;\n    }\n\n    while(res.left !== null) {\n        res = res.left;\n    }\n\n    return res.data;\n};\n\n// returns null if tree is empty\nTreeBase.prototype.max = function() {\n    var res = this._root;\n    if(res === null) {\n        return null;\n    }\n\n    while(res.right !== null) {\n        res = res.right;\n    }\n\n    return res.data;\n};\n\n// returns a null iterator\n// call next() or prev() to point to an element\nTreeBase.prototype.iterator = function() {\n    return new Iterator(this);\n};\n\n// calls cb on each node's data, in order\nTreeBase.prototype.each = function(cb) {\n    var it=this.iterator(), data;\n    while((data = it.next()) !== null) {\n        cb(data);\n    }\n};\n\n// calls cb on each node's data, in reverse order\nTreeBase.prototype.reach = function(cb) {\n    var it=this.iterator(), data;\n    while((data = it.prev()) !== null) {\n        cb(data);\n    }\n};\n\n\nfunction Iterator(tree) {\n    this._tree = tree;\n    this._ancestors = [];\n    this._cursor = null;\n}\n\nIterator.prototype.data = function() {\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\n// if null-iterator, returns first node\n// otherwise, returns next node\nIterator.prototype.next = function() {\n    if(this._cursor === null) {\n        var root = this._tree._root;\n        if(root !== null) {\n            this._minNode(root);\n        }\n    }\n    else {\n        if(this._cursor.right === null) {\n            // no greater node in subtree, go up to parent\n            // if coming from a right child, continue up the stack\n            var save;\n            do {\n                save = this._cursor;\n                if(this._ancestors.length) {\n                    this._cursor = this._ancestors.pop();\n                }\n                else {\n                    this._cursor = null;\n                    break;\n                }\n            } while(this._cursor.right === save);\n        }\n        else {\n            // get the next node from the subtree\n            this._ancestors.push(this._cursor);\n            this._minNode(this._cursor.right);\n        }\n    }\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\n// if null-iterator, returns last node\n// otherwise, returns previous node\nIterator.prototype.prev = function() {\n    if(this._cursor === null) {\n        var root = this._tree._root;\n        if(root !== null) {\n            this._maxNode(root);\n        }\n    }\n    else {\n        if(this._cursor.left === null) {\n            var save;\n            do {\n                save = this._cursor;\n                if(this._ancestors.length) {\n                    this._cursor = this._ancestors.pop();\n                }\n                else {\n                    this._cursor = null;\n                    break;\n                }\n            } while(this._cursor.left === save);\n        }\n        else {\n            this._ancestors.push(this._cursor);\n            this._maxNode(this._cursor.left);\n        }\n    }\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\nIterator.prototype._minNode = function(start) {\n    while(start.left !== null) {\n        this._ancestors.push(start);\n        start = start.left;\n    }\n    this._cursor = start;\n};\n\nIterator.prototype._maxNode = function(start) {\n    while(start.right !== null) {\n        this._ancestors.push(start);\n        start = start.right;\n    }\n    this._cursor = start;\n};\n\nmodule.exports = TreeBase;\n\n","'use strict';\n\nexports.linearBuckets = (start, width, count) => {\n\tif (count < 1) {\n\t\tthrow new Error('Linear buckets needs a positive count');\n\t}\n\n\tconst buckets = new Array(count);\n\tfor (let i = 0; i < count; i++) {\n\t\tbuckets[i] = start;\n\t\tstart += width;\n\t}\n\treturn buckets;\n};\n\nexports.exponentialBuckets = (start, factor, count) => {\n\tif (start <= 0) {\n\t\tthrow new Error('Exponential buckets needs a positive start');\n\t}\n\tif (count < 1) {\n\t\tthrow new Error('Exponential buckets needs a positive count');\n\t}\n\tif (factor <= 1) {\n\t\tthrow new Error('Exponential buckets needs a factor greater than 1');\n\t}\n\tconst buckets = new Array(count);\n\tfor (let i = 0; i < count; i++) {\n\t\tbuckets[i] = start;\n\t\tstart *= factor;\n\t}\n\treturn buckets;\n};\n","'use strict';\n\nfunction safeMemoryUsage() {\n\tlet memoryUsage;\n\ttry {\n\t\tmemoryUsage = process.memoryUsage();\n\t} catch (ex) {\n\t\t// empty\n\t}\n\n\treturn memoryUsage;\n}\n\nmodule.exports = safeMemoryUsage;\n","'use strict';\n\nconst { Grouper, hashObject } = require('./util');\n\n/**\n * Returns a new function that applies the `aggregatorFn` to the values.\n * @param {Function} aggregatorFn function to apply to values.\n * @return {Function} aggregator function\n */\nfunction AggregatorFactory(aggregatorFn) {\n\treturn metrics => {\n\t\tif (metrics.length === 0) return;\n\t\tconst result = {\n\t\t\thelp: metrics[0].help,\n\t\t\tname: metrics[0].name,\n\t\t\ttype: metrics[0].type,\n\t\t\tvalues: [],\n\t\t\taggregator: metrics[0].aggregator\n\t\t};\n\t\t// Gather metrics by metricName and labels.\n\t\tconst byLabels = new Grouper();\n\t\tmetrics.forEach(metric => {\n\t\t\tmetric.values.forEach(value => {\n\t\t\t\tconst key = hashObject(value.labels);\n\t\t\t\tbyLabels.add(`${value.metricName}_${key}`, value);\n\t\t\t});\n\t\t});\n\t\t// Apply aggregator function to gathered metrics.\n\t\tbyLabels.forEach(values => {\n\t\t\tif (values.length === 0) return;\n\t\t\tconst valObj = {\n\t\t\t\tvalue: aggregatorFn(values),\n\t\t\t\tlabels: values[0].labels\n\t\t\t};\n\t\t\tif (values[0].metricName) {\n\t\t\t\tvalObj.metricName = values[0].metricName;\n\t\t\t}\n\t\t\t// NB: Timestamps are omitted.\n\t\t\tresult.values.push(valObj);\n\t\t});\n\t\treturn result;\n\t};\n}\n// Export for users to define their own aggregation methods.\nexports.AggregatorFactory = AggregatorFactory;\n\n/**\n * Functions that can be used to aggregate metrics from multiple registries.\n */\nexports.aggregators = {\n\t/**\n\t * @return The sum of values.\n\t */\n\tsum: AggregatorFactory(v => v.reduce((p, c) => p + c.value, 0)),\n\t/**\n\t * @return The first value.\n\t */\n\tfirst: AggregatorFactory(v => v[0].value),\n\t/**\n\t * @return {undefined} Undefined; omits the metric.\n\t */\n\tomit: () => {},\n\t/**\n\t * @return The arithmetic mean of the values.\n\t */\n\taverage: AggregatorFactory(\n\t\tv => v.reduce((p, c) => p + c.value, 0) / v.length\n\t),\n\t/**\n\t * @return The minimum of the values.\n\t */\n\tmin: AggregatorFactory(v =>\n\t\tv.reduce((p, c) => Math.min(p, c.value), Infinity)\n\t),\n\t/**\n\t * @return The maximum of the values.\n\t */\n\tmax: AggregatorFactory(v =>\n\t\tv.reduce((p, c) => Math.max(p, c.value), -Infinity)\n\t)\n};\n","'use strict';\n\nconst CircuitBreaker = require('./lib/circuit');\nconst circuits = [];\n\nconst defaults = {\n  timeout: 10000, // 10 seconds\n  errorThresholdPercentage: 50,\n  resetTimeout: 30000 // 30 seconds\n};\n\n/**\n * Creates a {@link CircuitBreaker} instance capable of executing `action`.\n *\n * @param {Function} action The action to fire for this {@link CircuitBreaker}\n * @param {Object} options Options for the {@link CircuitBreaker}\n * @param {Number} options.timeout The time in milliseconds that action should\n * be allowed to execute before timing out. Default 10000 (10 seconds)\n * @param {Number} options.maxFailures (Deprecated) The number of times the\n * circuit can fail before opening. Default 10.\n * @param {Number} options.resetTimeout The time in milliseconds to wait before\n * setting the breaker to `halfOpen` state, and trying the action again.\n * Default: 30000 (30 seconds)\n * @param {Number} options.rollingCountTimeout Sets the duration of the\n * statistical rolling window, in milliseconds. This is how long Opossum keeps\n * metrics for the circuit breaker to use and for publishing. Default: 10000\n * @param {Number} options.rollingCountBuckets Sets the number of buckets the\n * rolling statistical window is divided into. So, if\n * options.rollingCountTimeout is 10000, and options.rollingCountBuckets is 10,\n * then the statistical window will be 1000 1 second snapshots in the\n * statistical window. Default: 10\n * @param {String} options.name the circuit name to use when reporting stats.\n * Default: the name of the function this circuit controls.\n * @param {boolean} options.rollingPercentilesEnabled This property indicates\n * whether execution latencies should be tracked and calculated as percentiles.\n * If they are disabled, all summary statistics (mean, percentiles) are\n * returned as -1. Default: false\n * @param {Number} options.capacity the number of concurrent requests allowed.\n * If the number currently executing function calls is equal to\n * options.capacity, further calls to `fire()` are rejected until at least one\n * of the current requests completes. Default: `Number.MAX_SAFE_INTEGER`.\n * @param {Number} options.errorThresholdPercentage the error percentage at\n * which to open the circuit and start short-circuiting requests to fallback.\n * Default: 50\n * @param {boolean} options.enabled whether this circuit is enabled upon\n * construction. Default: true\n * @param {boolean} options.allowWarmUp determines whether to allow failures\n * without opening the circuit during a brief warmup period (this is the\n * `rollingCountDuration` property). Default: false\n * allow before enabling the circuit. This can help in situations where no\n * matter what your `errorThresholdPercentage` is, if the first execution\n * times out or fails, the circuit immediately opens. Default: 0\n * @param {Number} options.volumeThreshold the minimum number of requests within\n * the rolling statistical window that must exist before the circuit breaker\n * can open. This is similar to `options.allowWarmUp` in that no matter how many\n * failures there are, if the number of requests within the statistical window\n * does not exceed this threshold, the circuit will remain closed. Default: 0\n * @param {Function} options.errorFilter an optional function that will be\n * called when the circuit's function fails (returns a rejected Promise). If\n * this function returns truthy, the circuit's failure statistics will not be\n * incremented. This is useful, for example, when you don't want HTTP 404 to\n * trip the circuit, but still want to handle it as a failure case.\n\n * @return {CircuitBreaker} a newly created {@link CircuitBreaker} instance\n */\nfunction factory (action, options) {\n  const circuit = new CircuitBreaker(action,\n    Object.assign({}, defaults, options));\n  circuits.push(circuit);\n  return circuit;\n}\n\n/**\n * Given a function that receives a callback as its last argument,\n * and which executes that function, passing as parameters `err` and `result`,\n * creates an action that returns a promise which resolves when the function's\n * callback is executed.\n * @function factory.promisify\n *\n * @param {Function} action A Node.js-like asynchronous function\n * @example\n *     const fs = require('fs');\n *     const readFilePromised = circuitBreaker.promisify(fs.readFile);\n *     const breaker = circuitBreaker(readFilePromised);\n */\nfactory.promisify = require('./lib/promisify');\n\n/**\n * Get the Prometheus metrics for all circuits.\n * @function factory.metrics\n * @return {String} the metrics for all circuits\n */\nfactory.metrics = function metrics() {\n  // Just get the metrics for the last circuit that was created\n  // since prom-client is additive\n  const lastCircuit = circuits[circuits.length - 1];\n  if (lastCircuit && lastCircuit.metrics)\n    return lastCircuit.metrics.metrics;\n}\n\nlet warningIssued = false;\nObject.defineProperty(factory, 'stats', {\n  get: _ => {\n    if (!warningIssued) {\n      warningIssued = true;\n      console.warn(`WARNING: Hystrics stats are deprecated\n      See: https://github.com/Netflix/Hystrix#dashboard`)\n    }\n    return require('./lib/hystrix-stats').stream;\n  }\n});\n\nmodule.exports = exports = factory;\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = factory;\n","'use strict';\n\nconst EventEmitter = require('events');\nconst Status = require('./status');\nconst HystrixStats = require('./hystrix-stats');\nconst Semaphore = require('./semaphore');\nlet PrometheusMetrics;\nif (!process.env.WEB) {\n  PrometheusMetrics = require('./prometheus-metrics');\n}\n\nconst STATE = Symbol('state');\nconst OPEN = Symbol('open');\nconst CLOSED = Symbol('closed');\nconst HALF_OPEN = Symbol('half-open');\nconst PENDING_CLOSE = Symbol('pending-close');\nconst SHUTDOWN = Symbol('shutdown');\nconst FALLBACK_FUNCTION = Symbol('fallback');\nconst STATUS = Symbol('status');\nconst NAME = Symbol('name');\nconst GROUP = Symbol('group');\nconst HYSTRIX_STATS = Symbol('hystrix-stats');\nconst PROMETHEUS_METRICS = Symbol('prometheus-metrics');\nconst CACHE = new WeakMap();\nconst ENABLED = Symbol('Enabled');\nconst WARMING_UP = Symbol('warming-up');\nconst VOLUME_THRESHOLD = Symbol('volume-threshold');\nconst deprecation = `options.maxFailures is deprecated. \\\nPlease use options.errorThresholdPercentage`;\n\nlet warningIssued = false;\n\n\n/**\n * Constructs a {@link CircuitBreaker}.\n *\n * @class CircuitBreaker\n * @extends EventEmitter\n * @param {Function} action The action to fire for this {@link CircuitBreaker}\n * @param {Object} options Options for the {@link CircuitBreaker}\n * @param {Number} options.timeout The time in milliseconds that action should\n * be allowed to execute before timing out. Default 10000 (10 seconds)\n * @param {Number} options.maxFailures (Deprecated) The number of times the\n * circuit can fail before opening. Default 10.\n * @param {Number} options.resetTimeout The time in milliseconds to wait before\n * setting the breaker to `halfOpen` state, and trying the action again.\n * Default: 30000 (30 seconds)\n * @param {Number} options.rollingCountTimeout Sets the duration of the\n * statistical rolling window, in milliseconds. This is how long Opossum keeps\n * metrics for the circuit breaker to use and for publishing. Default: 10000\n * @param {Number} options.rollingCountBuckets Sets the number of buckets the\n * rolling statistical window is divided into. So, if\n * options.rollingCountTimeout is 10000, and options.rollingCountBuckets is 10,\n * then the statistical window will be 1000 1 second snapshots in the\n * statistical window. Default: 10\n * @param {String} options.name the circuit name to use when reporting stats.\n * Default: the name of the function this circuit controls.\n * @param {boolean} options.rollingPercentilesEnabled This property indicates\n * whether execution latencies should be tracked and calculated as percentiles.\n * If they are disabled, all summary statistics (mean, percentiles) are\n * returned as -1. Default: false\n * @param {Number} options.capacity the number of concurrent requests allowed.\n * If the number currently executing function calls is equal to\n * options.capacity, further calls to `fire()` are rejected until at least one\n * of the current requests completes. Default: `Number.MAX_SAFE_INTEGER`.\n * @param {Number} options.errorThresholdPercentage the error percentage at\n * which to open the circuit and start short-circuiting requests to fallback.\n * Default: 50\n * @param {boolean} options.enabled whether this circuit is enabled upon\n * construction. Default: true\n * @param {boolean} options.allowWarmUp determines whether to allow failures\n * without opening the circuit during a brief warmup period (this is the\n * `rollingCountDuration` property). Default: false\n * allow before enabling the circuit. This can help in situations where no\n * matter what your `errorThresholdPercentage` is, if the first execution\n * times out or fails, the circuit immediately opens. Default: 0\n * @param {Number} options.volumeThreshold the minimum number of requests within\n * the rolling statistical window that must exist before the circuit breaker\n * can open. This is similar to `options.allowWarmUp` in that no matter how many\n * failures there are, if the number of requests within the statistical window\n * does not exceed this threshold, the circuit will remain closed. Default: 0\n * @param {Function} options.errorFilter an optional function that will be\n * called when the circuit's function fails (returns a rejected Promise). If\n * this function returns truthy, the circuit's failure statistics will not be\n * incremented. This is useful, for example, when you don't want HTTP 404 to\n * trip the circuit, but still want to handle it as a failure case.\n *\n * @fires CircuitBreaker#halfOpen\n * @fires CircuitBreaker#close\n * @fires CircuitBreaker#open\n * @fires CircuitBreaker#fire\n * @fires CircuitBreaker#cacheHit\n * @fires CircuitBreaker#cacheMiss\n * @fires CircuitBreaker#reject\n * @fires CircuitBreaker#timeout\n * @fires CircuitBreaker#success\n * @fires CircuitBreaker#semaphore-locked\n * @fires CircuitBreaker#health-check-failed\n * @fires CircuitBreaker#fallback\n * @fires CircuitBreaker#failure\n */\nclass CircuitBreaker extends EventEmitter {\n  constructor (action, options) {\n    super();\n    this.options = options;\n    this.options.rollingCountTimeout = options.rollingCountTimeout || 10000;\n    this.options.rollingCountBuckets = options.rollingCountBuckets || 10;\n    this.options.rollingPercentilesEnabled =\n      options.rollingPercentilesEnabled !== false;\n    this.options.capacity = Number.isInteger(options.capacity)\n      ? options.capacity : Number.MAX_SAFE_INTEGER;\n    this.options.errorFilter = options.errorFilter || (_ => false);\n\n    this.semaphore = new Semaphore(this.options.capacity);\n\n    this[VOLUME_THRESHOLD] = Number.isInteger(options.volumeThreshold)\n      ? options.volumeThreshold : 0;\n    this[WARMING_UP] = options.allowWarmUp === true;\n    this[STATUS] = new Status(this.options);\n    this[STATE] = CLOSED;\n    this[FALLBACK_FUNCTION] = null;\n    this[PENDING_CLOSE] = false;\n    this[NAME] = options.name || action.name || nextName();\n    this[GROUP] = options.group || this[NAME];\n    this[ENABLED] = options.enabled !== false;\n\n    if (this[WARMING_UP]) {\n      const timer = setTimeout(_ => (this[WARMING_UP] = false),\n        this.options.rollingCountTimeout);\n      if (typeof timer.unref === 'function') {\n        timer.unref();\n      }\n    }\n\n    if (typeof action !== 'function') {\n      this.action = _ => Promise.resolve(action);\n    } else this.action = action;\n\n    if (options.maxFailures) console.error(deprecation);\n\n    const increment = property =>\n      (result, runTime) => this[STATUS].increment(property, runTime);\n\n    this.on('success', increment('successes'));\n    this.on('failure', increment('failures'));\n    this.on('fallback', increment('fallbacks'));\n    this.on('timeout', increment('timeouts'));\n    this.on('fire', increment('fires'));\n    this.on('reject', increment('rejects'));\n    this.on('cacheHit', increment('cacheHits'));\n    this.on('cacheMiss', increment('cacheMisses'));\n    this.on('open', _ => this[STATUS].open());\n    this.on('close', _ => this[STATUS].close());\n    this.on('semaphoreLocked', increment('semaphoreRejections'));\n\n    /**\n     * Emitted after `options.resetTimeout` has elapsed, allowing for\n     * a single attempt to call the service again. If that attempt is\n     * successful, the circuit will be closed. Otherwise it remains open.\n     *\n     * @event CircuitBreaker#halfOpen\n     * @type {Number} how long the circuit remained open\n     */\n\n    function _startTimer (circuit) {\n      return _ => {\n        const timer = setTimeout(() => {\n          circuit[STATE] = HALF_OPEN;\n          circuit[PENDING_CLOSE] = true;\n          circuit.emit('halfOpen', circuit.options.resetTimeout);\n        }, circuit.options.resetTimeout);\n        if (typeof timer.unref === 'function') {\n          timer.unref();\n        }\n      };\n    }\n\n    this.on('open', _startTimer(this));\n    this.on('success', _ => this.close());\n    if (this.options.cache) {\n      CACHE.set(this, undefined);\n    }\n\n    // Register with the hystrix stats listener\n    this[HYSTRIX_STATS] = new HystrixStats(this);\n\n    // Add Prometheus metrics if not running in a web env\n    if (PrometheusMetrics && options.usePrometheus) {\n      this[PROMETHEUS_METRICS] = new PrometheusMetrics(this);\n    }\n  }\n\n  /**\n   * Closes the breaker, allowing the action to execute again\n   * @fires CircuitBreaker#close\n   * @returns {void}\n   */\n  close () {\n    this[PENDING_CLOSE] = false;\n    if (this[STATE] !== CLOSED) {\n      this[STATE] = CLOSED;\n      /**\n       * Emitted when the breaker is reset allowing the action to execute again\n       * @event CircuitBreaker#close\n       */\n      this.emit('close');\n    }\n  }\n\n  /**\n   * Opens the breaker. Each time the breaker is fired while the circuit is\n   * opened, a failed Promise is returned, or if any fallback function\n   * has been provided, it is invoked.\n   * @fires CircuitBreaker#open\n   * @returns {void}\n   */\n  open () {\n    this[PENDING_CLOSE] = false;\n    if (this[STATE] !== OPEN) {\n      this[STATE] = OPEN;\n      /**\n       * Emitted when the breaker opens because the action has\n       * failed more than `options.maxFailures` number of times.\n       * @event CircuitBreaker#open\n       */\n      this.emit('open');\n    }\n  }\n\n  /**\n   * Shuts down this circuit breaker. All subsequent calls to the\n   * circuit will fail, returning a rejected promise.\n   * @returns {void}\n   */\n  shutdown () {\n    this.disable();\n    this.removeAllListeners();\n    this.status.shutdown();\n    this.hystrixStats.shutdown();\n    this.metrics && this.metrics.clear();\n    this[STATE] = SHUTDOWN;\n  }\n\n  /**\n   * Determines if the circuit has been shutdown.\n   * @type {Boolean}\n   */\n  get isShutdown () {\n    return this[STATE] === SHUTDOWN;\n  }\n\n  /**\n   * Gets the name of this circuit\n   * @type {String}\n   */\n  get name () {\n    return this[NAME];\n  }\n\n  /**\n   * Gets the name of this circuit group\n   * @type {String}\n   */\n  get group () {\n    return this[GROUP];\n  }\n\n  /**\n   * Gets whether this cicruit is in the `pendingClosed` state\n   * @type {Boolean}\n   */\n  get pendingClose () {\n    return this[PENDING_CLOSE];\n  }\n\n  /**\n   * True if the circuit is currently closed. False otherwise.\n   * @type {Boolean}\n   */\n  get closed () {\n    return this[STATE] === CLOSED;\n  }\n\n  /**\n   * True if the circuit is currently opened. False otherwise.\n   * @type {Boolean}\n   */\n  get opened () {\n    return this[STATE] === OPEN;\n  }\n\n  /**\n   * True if the circuit is currently half opened. False otherwise.\n   * @type {Boolean}\n   */\n  get halfOpen () {\n    return this[STATE] === HALF_OPEN;\n  }\n\n  /**\n   * The current {@link Status} of this {@link CircuitBreaker}\n   * @type {Status}\n   */\n  get status () {\n    return this[STATUS];\n  }\n\n  /**\n   * Get the current stats for the circuit.\n   * @see Status#stats\n   * @type {Object}\n   */\n  get stats () {\n    return this[STATUS].stats;\n  }\n\n  /**\n   * Get the hystrixStats.\n   * @type {HystrixStats}\n   */\n  get hystrixStats () {\n    if (!warningIssued) {\n      warningIssued = true;\n      console.warn(`WARNING: Hystrics stats are deprecated\n      See: https://github.com/Netflix/Hystrix#dashboard`)\n    }\n    return this[HYSTRIX_STATS];\n  }\n\n  /**\n   * Get the prometheus metrics for this circuit\n   * @type {PrometheusMetrics}\n   */\n  get metrics () {\n    return this[PROMETHEUS_METRICS];\n  }\n\n  /**\n   * Gets whether the circuit is enabled or not\n   * @type {Boolean}\n   */\n  get enabled () {\n    return this[ENABLED];\n  }\n\n  /**\n   * Gets whether the circuit is currently in warm up phase\n   * @type {Boolean}\n   */\n  get warmUp () {\n    return this[WARMING_UP];\n  }\n\n  /**\n   * Gets the volume threshold for this circuit\n   * @type {Boolean}\n   */\n  get volumeThreshold () {\n    return this[VOLUME_THRESHOLD];\n  }\n\n  /**\n   * Provide a fallback function for this {@link CircuitBreaker}. This\n   * function will be executed when the circuit is `fire`d and fails.\n   * It will always be preceded by a `failure` event, and `breaker.fire` returns\n   * a rejected Promise.\n   * @param {Function | CircuitBreaker} func the fallback function to execute\n   * when the breaker has opened or when a timeout or error occurs.\n   * @return {CircuitBreaker} this\n   */\n  fallback (func) {\n    let fb = func;\n    if (func instanceof CircuitBreaker) {\n      fb = function () {\n        return func.fire.apply(func, arguments);\n      };\n    }\n    this[FALLBACK_FUNCTION] = fb;\n    return this;\n  }\n\n  /**\n   * Execute the action for this circuit. If the action fails or times out, the\n   * returned promise will be rejected. If the action succeeds, the promise will\n   * resolve with the resolved value from action. If a fallback function was\n   * provided, it will be invoked in the event of any failure or timeout.\n   *\n   * @return {Promise<any>} promise resolves with the circuit function's return\n   * value on success or is rejected on failure of the action.\n   *\n   * @fires CircuitBreaker#failure\n   * @fires CircuitBreaker#fallback\n   * @fires CircuitBreaker#fire\n   * @fires CircuitBreaker#reject\n   * @fires CircuitBreaker#success\n   * @fires CircuitBreaker#timeout\n   * @fires CircuitBreaker#semaphoreLocked\n   */\n  fire () {\n    if (this.isShutdown) {\n      const err = new Error('The circuit has been shutdown.');\n      err.code = 'ESHUTDOWN';\n      return Promise.reject(err);\n    }\n    const args = Array.prototype.slice.call(arguments);\n\n    /**\n     * Emitted when the circuit breaker action is executed\n     * @event CircuitBreaker#fire\n     * @type {any} the arguments passed to the fired fuction\n     */\n    this.emit('fire', args);\n\n    if (CACHE.get(this) !== undefined) {\n      /**\n       * Emitted when the circuit breaker is using the cache\n       * and finds a value.\n       * @event CircuitBreaker#cacheHit\n       */\n      this.emit('cacheHit');\n      return CACHE.get(this);\n    } else if (this.options.cache) {\n      /**\n       * Emitted when the circuit breaker does not find a value in\n       * the cache, but the cache option is enabled.\n       * @event CircuitBreaker#cacheMiss\n       */\n      this.emit('cacheMiss');\n    }\n\n    if (!this[ENABLED]) {\n      const result = this.action.apply(this.action, args);\n      return (typeof result.then === 'function')\n        ? result\n        : Promise.resolve(result);\n    }\n\n    if (!this.closed && !this.pendingClose) {\n      /**\n       * Emitted when the circuit breaker is open and failing fast\n       * @event CircuitBreaker#reject\n       * @type {Error}\n       */\n      const error = new Error('Breaker is open');\n      error.code = 'EOPENBREAKER';\n\n      this.emit('reject', error);\n\n      return fallback(this, error, args) ||\n        Promise.reject(error);\n    }\n    this[PENDING_CLOSE] = false;\n\n    let timeout;\n    let timeoutError = false;\n    return new Promise((resolve, reject) => {\n      const latencyStartTime = Date.now();\n      if (this.semaphore.test()) {\n        if (this.options.timeout) {\n          timeout = setTimeout(\n            () => {\n              timeoutError = true;\n              const error =\n                new Error(`Timed out after ${this.options.timeout}ms`);\n              error.code = 'ETIMEDOUT';\n              /**\n               * Emitted when the circuit breaker action takes longer than\n               * `options.timeout`\n               * @event CircuitBreaker#timeout\n               * @type {Error}\n               */\n              const latency = Date.now() - latencyStartTime;\n              this.semaphore.release();\n              this.emit('timeout', error, latency, args);\n              resolve(handleError(\n                error, this, timeout, args, latency, resolve, reject));\n            }, this.options.timeout);\n        }\n\n        try {\n          const result = this.action.apply(this.action, args);\n          const promise = (typeof result.then === 'function')\n            ? result\n            : Promise.resolve(result);\n\n          promise.then(result => {\n            if (!timeoutError) {\n              clearTimeout(timeout);\n              /**\n               * Emitted when the circuit breaker action succeeds\n               * @event CircuitBreaker#success\n               * @type {any} the return value from the circuit\n               */\n              this.emit('success', result, (Date.now() - latencyStartTime));\n              this.semaphore.release();\n              resolve(result);\n              if (this.options.cache) {\n                CACHE.set(this, promise);\n              }\n            }\n          })\n            .catch(error => {\n              if (!timeoutError) {\n                this.semaphore.release();\n                const latencyEndTime = Date.now() - latencyStartTime;\n                handleError(\n                  error, this, timeout, args, latencyEndTime, resolve, reject);\n              }\n            });\n        } catch (error) {\n          this.semaphore.release();\n          const latency = Date.now() - latencyStartTime;\n          handleError(error, this, timeout, args, latency, resolve, reject);\n        }\n      } else {\n        const latency = Date.now() - latencyStartTime;\n        const err = new Error('Semaphore locked');\n        err.code = 'ESEMLOCKED';\n        /**\n         * Emitted when the rate limit has been reached and there\n         * are no more locks to be obtained.\n         * @event CircuitBreaker#semaphoreLocked\n         * @type {Error}\n         */\n        this.emit('semaphoreLocked', err, latency);\n        handleError(err, this, timeout, args, latency, resolve, reject);\n      }\n    });\n  }\n\n  /**\n   * Clears the cache of this {@link CircuitBreaker}\n   * @returns {void}\n   */\n  clearCache () {\n    CACHE.set(this, undefined);\n  }\n\n  /**\n   * Provide a health check function to be called periodically. The function\n   * should return a Promise. If the promise is rejected the circuit will open.\n   * This is in addition to the existing circuit behavior as defined by\n   * `options.errorThresholdPercentage` in the constructor. For example, if the\n   * health check function provided here always returns a resolved promise, the\n   * circuit can still trip and open if there are failures exceeding the\n   * configured threshold. The health check function is executed within the\n   * circuit breaker's execution context, so `this` within the function is the\n   * circuit breaker itself.\n   *\n   * @param {Function} func a health check function which returns a promise.\n   * @param {Number} [interval] the amount of time between calls to the health\n   * check function. Default: 5000 (5 seconds)\n   *\n   * @returns {void}\n   *\n   * @fires CircuitBreaker#healthCheckFailed\n   * @throws {TypeError} if `interval` is supplied but not a number\n   */\n  healthCheck (func, interval) {\n    interval = interval || 5000;\n    if (typeof func !== 'function') {\n      throw new TypeError('Health check function must be a function');\n    }\n    if (isNaN(interval)) {\n      throw new TypeError('Health check interval must be a number');\n    }\n\n    const check = _ => {\n      func.apply(this).catch(e => {\n        /**\n         * Emitted with the user-supplied health check function\n         * returns a rejected promise.\n         * @event CircuitBreaker#healthCheckFailed\n         * @type {Error}\n         */\n        this.emit('healthCheckFailed', e);\n        this.open();\n      });\n    };\n\n    const timer = setInterval(check, interval);\n    if (typeof timer.unref === 'function') {\n      timer.unref();\n    }\n\n    check();\n  }\n\n  /**\n   * Enables this circuit. If the circuit is the  disabled\n   * state, it will be re-enabled. If not, this is essentially\n   * a noop.\n   * @returns {void}\n   */\n  enable () {\n    this[ENABLED] = true;\n  }\n\n  /**\n   * Disables this circuit, causing all calls to the circuit's function\n   * to be executed without circuit or fallback protection.\n   * @returns {void}\n   */\n  disable () {\n    this[ENABLED] = false;\n  }\n}\n\nfunction handleError (error, circuit, timeout, args, latency, resolve, reject) {\n  clearTimeout(timeout);\n  fail(circuit, error, args, latency);\n  const fb = fallback(circuit, error, args);\n  if (fb) resolve(fb);\n  else reject(error);\n}\n\nfunction fallback (circuit, err, args) {\n  if (circuit[FALLBACK_FUNCTION]) {\n    const result =\n      circuit[FALLBACK_FUNCTION]\n        .apply(circuit[FALLBACK_FUNCTION], [...args, err]);\n    /**\n     * Emitted when the circuit breaker executes a fallback function\n     * @event CircuitBreaker#fallback\n     * @type {any} the return value of the fallback function\n     */\n    circuit.emit('fallback', result, err);\n    if (result instanceof Promise) return result;\n    return Promise.resolve(result);\n  }\n}\n\nfunction fail (circuit, err, args, latency) {\n  if (circuit.options.errorFilter(err)) return;\n\n  /**\n   * Emitted when the circuit breaker action fails\n   * @event CircuitBreaker#failure\n   * @type {Error}\n   */\n  circuit.emit('failure', err, latency, args);\n  if (circuit.warmUp) return;\n\n  // check stats to see if the circuit should be opened\n  const stats = circuit.stats;\n  if ((stats.fires < circuit.volumeThreshold) && !circuit.halfOpen) return;\n  const errorRate = stats.failures / stats.fires * 100;\n  if (errorRate > circuit.options.errorThresholdPercentage ||\n    stats.failures >= circuit.options.maxFailures ||\n    circuit.halfOpen) {\n    circuit.open();\n  }\n}\n\n// http://stackoverflow.com/a/2117523\nconst nextName = () =>\n  'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n\nmodule.exports = exports = CircuitBreaker;\n","'use strict';\n\nconst WINDOW = Symbol('window');\nconst BUCKETS = Symbol('buckets');\nconst TIMEOUT = Symbol('timeout');\nconst PERCENTILES = Symbol('percentiles');\n\nconst EventEmitter = require('events').EventEmitter;\n\n/**\n * Tracks execution status for a given {@link CircuitBreaker}.\n * A Status instance is created for every {@link CircuitBreaker}\n * and does not typically need to be created by a user.\n *\n * A Status instance will listen for all events on the {@link CircuitBreaker}\n * and track them in a rolling statistical window. The window duration is\n * determined by the `rollingCountTimeout` option provided to the\n * {@link CircuitBreaker}. The window consists of an array of Objects,\n * each representing the counts for a {@link CircuitBreaker}'s events.\n *\n * The array's length is determined by the {@link CircuitBreaker}'s\n * `rollingCountBuckets` option. The duration of each slice of the window\n * is determined by dividing the `rollingCountTimeout` by\n * `rollingCountBuckets`.\n *\n * @class Status\n * @extends EventEmitter\n * @param {Object} options for the status window\n * @param {Number} options.rollingCountBuckets number of buckets in the window\n * @param {Number} options.rollingCountTimeout the duration of the window\n * @param {Boolean} options.rollingPercentilesEnabled whether to calculate\n * percentiles\n * @example\n * // Creates a 1 second window consisting of ten time slices,\n * // each 100ms long.\n * const circuit = circuitBreaker(fs.readFile,\n *  { rollingCountBuckets: 10, rollingCountTimeout: 1000});\n *\n * // get the cumulative statistics for the last second\n * circuit.status.stats;\n *\n * // get the array of 10, 1 second time slices for the last second\n * circuit.status.window;\n * @fires Status#snapshot\n * @see CircuitBreaker#status\n */\nclass Status extends EventEmitter {\n  constructor (options) {\n    super();\n\n    // Set up our statistical rolling window\n    this[BUCKETS] = options.rollingCountBuckets;\n    this[TIMEOUT] = options.rollingCountTimeout;\n    this[WINDOW] = new Array(this[BUCKETS]);\n    this[PERCENTILES] = [0.0, 0.25, 0.5, 0.75, 0.9, 0.95, 0.99, 0.995, 1];\n\n    // Default this value to true\n    this.rollingPercentilesEnabled = options.rollingPercentilesEnabled;\n\n    // prime the window with buckets\n    for (let i = 0; i < this[BUCKETS]; i++) this[WINDOW][i] = bucket();\n\n    // rotate the buckets periodically\n    const bucketInterval = Math.floor(this[TIMEOUT] / this[BUCKETS]);\n    let interval = setInterval(nextBucket(this[WINDOW]), bucketInterval);\n\n    // No unref() in the browser\n    if (typeof interval.unref === 'function') interval.unref();\n\n    /**\n     * Emitted at each time-slice. Listeners for this\n     * event will receive a cumulative snapshot of the current status window.\n     * @event Status#snapshot\n     * @type {Object}\n     */\n    interval = setInterval(_ => this.emit('snapshot', this.stats),\n      bucketInterval);\n    if (typeof interval.unref === 'function') interval.unref();\n  }\n\n  /**\n   * Get the cumulative stats for the current window\n   * @type {Object}\n   */\n  get stats () {\n    const totals = this[WINDOW].reduce((acc, val) => {\n      if (!val) { return acc; }\n      Object.keys(acc).forEach(key => {\n        if (key !== 'latencyTimes' && key !== 'percentiles') {\n          (acc[key] += val[key] || 0);\n        }\n      });\n\n      if (this.rollingPercentilesEnabled) {\n        acc.latencyTimes.push.apply(acc.latencyTimes, val.latencyTimes || []);\n      }\n      return acc;\n    }, bucket());\n\n    if (this.rollingPercentilesEnabled) {\n      // Sort the latencyTimes\n      totals.latencyTimes.sort((a, b) => a - b);\n\n      // Get the mean latency\n      // Mean = sum of all values in the array/length of array\n      if (totals.latencyTimes.length) {\n        totals.latencyMean =\n          (totals\n            .latencyTimes\n            .reduce((a, b) => a + b, 0)) / totals.latencyTimes.length;\n      } else {\n        totals.latencyMean = 0;\n      }\n\n      // Calculate Percentiles\n      this[PERCENTILES].forEach(percentile => {\n        totals.percentiles[percentile] =\n          calculatePercentile(percentile, totals.latencyTimes);\n      });\n    } else {\n      totals.latencyMean = -1;\n      this[PERCENTILES].forEach(percentile => {\n        totals.percentiles[percentile] = -1;\n      });\n    }\n\n    return totals;\n  }\n\n  /**\n   * Gets the stats window as an array of time-sliced objects.\n   * @type {Array}\n   */\n  get window () {\n    return this[WINDOW].slice();\n  }\n\n  increment (property, latencyRunTime) {\n    this[WINDOW][0][property]++;\n    if (property === 'successes' ||\n        property === 'failures' ||\n        property === 'timeouts') {\n      this[WINDOW][0].latencyTimes.push(latencyRunTime || 0);\n    }\n  }\n\n  open () {\n    this[WINDOW][0].isCircuitBreakerOpen = true;\n  }\n\n  close () {\n    this[WINDOW][0].isCircuitBreakerOpen = false;\n  }\n\n  shutdown () {\n    this.removeAllListeners();\n  }\n}\n\nconst nextBucket = window => _ => {\n  window.pop();\n  window.unshift(bucket());\n};\n\nconst bucket = _ => ({\n  failures: 0,\n  fallbacks: 0,\n  successes: 0,\n  rejects: 0,\n  fires: 0,\n  timeouts: 0,\n  cacheHits: 0,\n  cacheMisses: 0,\n  semaphoreRejections: 0,\n  percentiles: {},\n  latencyTimes: []\n});\n\nfunction calculatePercentile (percentile, arr) {\n  if (percentile === 0) {\n    return arr[0] || 0;\n  }\n  const idx = Math.ceil(percentile * arr.length);\n  return arr[idx - 1] || 0;\n}\n\nmodule.exports = exports = Status;\n","module.exports = require(\"stream\");","'use strict';\n\n/* eslint max-len: [\"error\", { \"ignoreUrls\": true }] */\n\n// Data reference:\n// https://github.com/Netflix/Hystrix/wiki/Metrics-and-Monitoring#metrics-publisher\n// A function to map our stats data to the hystrix format\n// returns JSON\nfunction hystrixFormatter (stats) {\n  return {\n    type: 'HystrixCommand',\n    name: stats.name,\n    group: stats.group,\n    currentTime: Date.now(),\n    isCircuitBreakerOpen: !stats.closed,\n    errorPercentage:\n      stats.fires === 0 ? 0 : (stats.failures / stats.fires) * 100,\n    errorCount: stats.failures,\n    requestCount: stats.fires,\n    rollingCountBadRequests: stats.failures,\n    rollingCountCollapsedRequests: 0,\n    rollingCountEmit: stats.fires,\n    rollingCountExceptionsThrown: 0,\n    rollingCountFailure: stats.failures,\n    rollingCountFallbackEmit: stats.fallbacks,\n    rollingCountFallbackFailure: 0,\n    rollingCountFallbackMissing: 0,\n    rollingCountFallbackRejection: 0,\n    rollingCountFallbackSuccess: 0,\n    rollingCountResponsesFromCache: stats.cacheHits,\n    rollingCountSemaphoreRejected: stats.semaphoreRejections,\n    rollingCountShortCircuited: stats.rejects,\n    rollingCountSuccess: stats.successes,\n    rollingCountThreadPoolRejected: 0,\n    rollingCountTimeout: stats.timeouts,\n    currentConcurrentExecutionCount: 0,\n    rollingMaxConcurrentExecutionCount: 0,\n    // TODO: calculate these latency values\n    latencyExecute_mean: stats.latencyMean || 0,\n    latencyExecute: percentiles(stats),\n    // Whats the difference between execute and total?\n    latencyTotal_mean: stats.latencyMean,\n    latencyTotal: percentiles(stats),\n    propertyValue_circuitBreakerRequestVolumeThreshold: 5,\n    propertyValue_circuitBreakerSleepWindowInMilliseconds:\n      stats.options.resetTimeout,\n    propertyValue_circuitBreakerErrorThresholdPercentage:\n      stats.options.errorThresholdPercentage,\n    propertyValue_circuitBreakerForceOpen: false,\n    propertyValue_circuitBreakerForceClosed: false,\n    propertyValue_circuitBreakerEnabled: true,\n    propertyValue_executionIsolationStrategy: 'THREAD',\n    propertyValue_executionIsolationThreadTimeoutInMilliseconds: 300,\n    propertyValue_executionTimeoutInMilliseconds: stats.options.timeout,\n    propertyValue_executionIsolationThreadInterruptOnTimeout: true,\n    propertyValue_executionIsolationThreadPoolKeyOverride: null,\n    propertyValue_executionIsolationSemaphoreMaxConcurrentRequests:\n      stats.options.capacity,\n    propertyValue_fallbackIsolationSemaphoreMaxConcurrentRequests:\n      stats.options.capacity,\n    propertyValue_metricsRollingStatisticalWindowInMilliseconds: 10000,\n    propertyValue_requestCacheEnabled: stats.options.cache || false,\n    propertyValue_requestLogEnabled: true,\n    reportingHosts: 1\n  };\n}\n\nfunction percentiles (stats) {\n  return {\n    0: stats.percentiles['0'],\n    25: stats.percentiles['0.25'],\n    50: stats.percentiles['0.5'],\n    75: stats.percentiles['0.75'],\n    90: stats.percentiles['0.9'],\n    95: stats.percentiles['0.95'],\n    99: stats.percentiles['0.99'],\n    99.5: stats.percentiles['0.995'],\n    100: stats.percentiles['1']\n  };\n}\n\nmodule.exports = exports = hystrixFormatter;\n","'use strict';\n\nmodule.exports = exports = semaphore;\n\nfunction semaphore (count) {\n  const resolvers = [];\n  let counter = count;\n\n  let sem = {\n    take,\n    release,\n    test\n  };\n\n  Object.defineProperty(sem, 'count', {\n    get: _ => counter,\n    enumerable: true\n  });\n\n  return sem;\n\n  function take (timeout) {\n    if (counter > 0) {\n      --counter;\n      return Promise.resolve(release);\n    }\n    return new Promise((resolve, reject) => {\n      resolvers.push(_ => {\n        --counter;\n        resolve(release);\n      });\n      if (timeout) {\n        setTimeout(_ => {\n          resolvers.shift();\n          const err = new Error(`Timed out after ${timeout}ms`);\n          err.code = 'ETIMEDOUT';\n          reject(err);\n        }, timeout);\n      }\n    });\n  }\n\n  function release () {\n    counter++;\n    if (resolvers.length > 0) {\n      resolvers.shift()();\n    }\n  }\n\n  function test () {\n    if (counter < 1) return false;\n    return take() && true;\n  }\n}\n","'use strict';\n\nconst client = require('prom-client');\n\n// The current tests has circuit names like:\n// 'circuit one' (with blank space) and others like\n// 3beb8f49-62c0-46e0-b458-dcd4a62d0f48.\n// So to avoid \"Error: Invalid metric name\" we are changing the\n// circuit name to pass the tests.\n// More details:\n// https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels\nfunction normalizePrefix(prefixName) {\n  return `circuit_${prefixName.replace(/[ |-]/g, '_')}_`;\n}\n\nclass PrometheusMetrics {\n  constructor (circuit) {\n    this.circuit = circuit;\n    this._client = client;\n    this.counters = [];\n    const prefix = normalizePrefix(this.circuit.name);\n\n    this.interval = this._client\n      .collectDefaultMetrics({ prefix, timeout: 5000 });\n\n    for (let eventName of this.circuit.eventNames()) {\n      const counter = new this._client.Counter({\n        name: `${prefix}${eventName}`,\n        help: `A count of the ${circuit.name} circuit's ${eventName} event`\n      });\n      this.circuit.on(eventName, _ => {\n        counter.inc();\n      });\n      this.counters.push(counter);\n    }\n  }\n\n  clear () {\n    clearInterval(this.interval);\n    this._client.register.clear();\n  }\n\n  get metrics () {\n    return this._client.register.metrics();\n  }\n\n  get client () {\n    return this._client;\n  }\n}\n\nmodule.exports = PrometheusMetrics;\n","/**\n * Prometheus client\n * @module Prometheus client\n */\n\n'use strict';\n\nexports.register = require('./lib/registry').globalRegistry;\nexports.Registry = require('./lib/registry');\nexports.contentType = require('./lib/registry').globalRegistry.contentType;\n\nexports.Counter = require('./lib/counter');\nexports.Gauge = require('./lib/gauge');\nexports.Histogram = require('./lib/histogram');\nexports.Summary = require('./lib/summary');\nexports.Pushgateway = require('./lib/pushgateway');\n\nexports.linearBuckets = require('./lib/bucketGenerators').linearBuckets;\nexports.exponentialBuckets = require('./lib/bucketGenerators').exponentialBuckets;\n\nexports.collectDefaultMetrics = require('./lib/defaultMetrics');\n\nexports.aggregators = require('./lib/metricAggregators').aggregators;\nexports.AggregatorRegistry = require('./lib/cluster');\n","/**\n * Histogram\n */\n'use strict';\n\nconst util = require('util');\nconst globalRegistry = require('./registry').globalRegistry;\nconst type = 'histogram';\nconst {\n\tgetPropertiesFromObj,\n\tgetLabels,\n\thashObject,\n\tisObject,\n\tprintDeprecationObjectConstructor,\n\tremoveLabels\n} = require('./util');\nconst {\n\tvalidateMetricName,\n\tvalidateLabel,\n\tvalidateLabelName\n} = require('./validation');\n\nclass Histogram {\n\t/**\n\t * Histogram\n\t * @param {string} name - Name of the metric\n\t * @param {string} help - Help for the metric\n\t * @param {object|Array.<string>} labelsOrConf - Either array of label names or config object as a key-value object\n\t * @param {object} conf - Configuration object\n\t */\n\tconstructor(name, help, labelsOrConf, conf) {\n\t\tlet config;\n\n\t\tif (isObject(name)) {\n\t\t\tconfig = Object.assign(\n\t\t\t\t{\n\t\t\t\t\tbuckets: [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10],\n\t\t\t\t\tlabelNames: []\n\t\t\t\t},\n\t\t\t\tname\n\t\t\t);\n\n\t\t\tif (!config.registers) {\n\t\t\t\tconfig.registers = [globalRegistry];\n\t\t\t}\n\t\t} else {\n\t\t\tlet obj;\n\t\t\tlet labels = [];\n\n\t\t\tif (Array.isArray(labelsOrConf)) {\n\t\t\t\tobj = conf || {};\n\t\t\t\tlabels = labelsOrConf;\n\t\t\t} else {\n\t\t\t\tobj = labelsOrConf || {};\n\t\t\t}\n\n\t\t\tprintDeprecationObjectConstructor();\n\n\t\t\tconfig = {\n\t\t\t\tname,\n\t\t\t\tlabelNames: labels,\n\t\t\t\thelp,\n\t\t\t\tbuckets: configureUpperbounds(obj.buckets),\n\t\t\t\tregisters: [globalRegistry]\n\t\t\t};\n\t\t}\n\t\tvalidateInput(config.name, config.help, config.labelNames);\n\n\t\tthis.name = config.name;\n\t\tthis.help = config.help;\n\t\tthis.aggregator = config.aggregator || 'sum';\n\n\t\tthis.upperBounds = config.buckets;\n\t\tthis.bucketValues = this.upperBounds.reduce((acc, upperBound) => {\n\t\t\tacc[upperBound] = 0;\n\t\t\treturn acc;\n\t\t}, {});\n\n\t\tObject.freeze(this.bucketValues);\n\t\tObject.freeze(this.upperBounds);\n\t\tthis.sum = 0;\n\t\tthis.count = 0;\n\n\t\tthis.hashMap = {};\n\t\tthis.labelNames = config.labelNames || [];\n\n\t\tif (this.labelNames.length === 0) {\n\t\t\tthis.hashMap = {\n\t\t\t\t[hashObject({})]: createBaseValues(\n\t\t\t\t\t{},\n\t\t\t\t\tObject.assign({}, this.bucketValues)\n\t\t\t\t)\n\t\t\t};\n\t\t}\n\n\t\tconfig.registers.forEach(registryInstance =>\n\t\t\tregistryInstance.registerMetric(this)\n\t\t);\n\t}\n\n\t/**\n\t * Observe a value in histogram\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @param {Number} value - Value to observe in the histogram\n\t * @returns {void}\n\t */\n\tobserve(labels, value) {\n\t\tobserve.call(this, labels === 0 ? 0 : labels || {})(value);\n\t}\n\n\tget() {\n\t\tconst data = getPropertiesFromObj(this.hashMap);\n\t\tconst values = data\n\t\t\t.map(extractBucketValuesForExport(this))\n\t\t\t.reduce(addSumAndCountForExport(this), []);\n\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\thelp: this.help,\n\t\t\ttype,\n\t\t\tvalues,\n\t\t\taggregator: this.aggregator\n\t\t};\n\t}\n\n\treset() {\n\t\tthis.sum = 0;\n\t\tthis.count = 0;\n\t\tthis.hashMap = {};\n\t}\n\n\t/**\n\t * Start a timer that could be used to logging durations\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @returns {function} - Function to invoke when you want to stop the timer and observe the duration in seconds\n\t * @example\n\t * var end = histogram.startTimer();\n\t * makeExpensiveXHRRequest(function(err, res) {\n\t *\tend(); //Observe the duration of expensiveXHRRequest\n\t * });\n\t */\n\tstartTimer(labels) {\n\t\treturn startTimer.call(this, labels)();\n\t}\n\n\tlabels() {\n\t\tconst labels = getLabels(this.labelNames, arguments);\n\t\treturn {\n\t\t\tobserve: observe.call(this, labels),\n\t\t\tstartTimer: startTimer.call(this, labels)\n\t\t};\n\t}\n\n\tremove() {\n\t\tconst labels = getLabels(this.labelNames, arguments);\n\t\tremoveLabels.call(this, this.hashMap, labels);\n\t}\n}\n\nfunction startTimer(startLabels) {\n\treturn () => {\n\t\tconst start = process.hrtime();\n\t\treturn endLabels => {\n\t\t\tconst delta = process.hrtime(start);\n\t\t\tthis.observe(\n\t\t\t\tObject.assign({}, startLabels, endLabels),\n\t\t\t\tdelta[0] + delta[1] / 1e9\n\t\t\t);\n\t\t};\n\t};\n}\nfunction validateInput(name, help, labels) {\n\tif (!help) {\n\t\tthrow new Error('Missing mandatory help parameter');\n\t}\n\tif (!name) {\n\t\tthrow new Error('Missing mandatory name parameter');\n\t}\n\n\tif (!validateMetricName(name)) {\n\t\tthrow new Error('Invalid metric name');\n\t}\n\n\tif (!validateLabelName(labels)) {\n\t\tthrow new Error('Invalid label name');\n\t}\n\n\tlabels.forEach(label => {\n\t\tif (label === 'le') {\n\t\t\tthrow new Error('le is a reserved label keyword');\n\t\t}\n\t});\n}\n\nfunction configureUpperbounds(configuredBuckets) {\n\tconst defaultBuckets = [\n\t\t0.005,\n\t\t0.01,\n\t\t0.025,\n\t\t0.05,\n\t\t0.1,\n\t\t0.25,\n\t\t0.5,\n\t\t1,\n\t\t2.5,\n\t\t5,\n\t\t10\n\t];\n\treturn [].concat(configuredBuckets || defaultBuckets).sort(sortAscending);\n}\n\nfunction sortAscending(x, y) {\n\treturn x - y;\n}\n\nfunction setValuePair(labels, value, metricName) {\n\treturn {\n\t\tlabels,\n\t\tvalue,\n\t\tmetricName\n\t};\n}\n\nfunction findBound(upperBounds, value) {\n\tfor (let i = 0; i < upperBounds.length; i++) {\n\t\tconst bound = upperBounds[i];\n\t\tif (value <= bound) {\n\t\t\treturn bound;\n\t\t}\n\t}\n\treturn -1;\n}\n\nfunction observe(labels) {\n\treturn value => {\n\t\tconst labelValuePair = convertLabelsAndValues(labels, value);\n\n\t\tvalidateLabel(this.labelNames, labelValuePair.labels);\n\t\tif (!Number.isFinite(labelValuePair.value)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t`Value is not a valid number: ${util.format(labelValuePair.value)}`\n\t\t\t);\n\t\t}\n\n\t\tconst hash = hashObject(labelValuePair.labels);\n\t\tlet valueFromMap = this.hashMap[hash];\n\t\tif (!valueFromMap) {\n\t\t\tvalueFromMap = createBaseValues(\n\t\t\t\tlabelValuePair.labels,\n\t\t\t\tObject.assign({}, this.bucketValues)\n\t\t\t);\n\t\t}\n\n\t\tconst b = findBound(this.upperBounds, labelValuePair.value);\n\n\t\tvalueFromMap.sum += labelValuePair.value;\n\t\tvalueFromMap.count += 1;\n\n\t\tif (valueFromMap.bucketValues.hasOwnProperty(b)) {\n\t\t\tvalueFromMap.bucketValues[b] += 1;\n\t\t}\n\n\t\tthis.hashMap[hash] = valueFromMap;\n\t};\n}\n\nfunction createBaseValues(labels, bucketValues) {\n\treturn {\n\t\tlabels,\n\t\tbucketValues,\n\t\tsum: 0,\n\t\tcount: 0\n\t};\n}\n\nfunction convertLabelsAndValues(labels, value) {\n\tif (!isObject(labels)) {\n\t\treturn {\n\t\t\tvalue: labels,\n\t\t\tlabels: {}\n\t\t};\n\t}\n\treturn {\n\t\tlabels,\n\t\tvalue\n\t};\n}\n\nfunction extractBucketValuesForExport(histogram) {\n\treturn bucketData => {\n\t\tconst buckets = [];\n\t\tconst bucketLabelNames = Object.keys(bucketData.labels);\n\t\tlet acc = 0;\n\t\tfor (const upperBound of histogram.upperBounds) {\n\t\t\tacc += bucketData.bucketValues[upperBound];\n\t\t\tconst lbls = { le: upperBound };\n\t\t\tfor (const labelName of bucketLabelNames) {\n\t\t\t\tlbls[labelName] = bucketData.labels[labelName];\n\t\t\t}\n\t\t\tbuckets.push(setValuePair(lbls, acc, `${histogram.name}_bucket`));\n\t\t}\n\t\treturn { buckets, data: bucketData };\n\t};\n}\n\nfunction addSumAndCountForExport(histogram) {\n\treturn (acc, d) => {\n\t\tacc.push(...d.buckets);\n\n\t\tconst infLabel = { le: '+Inf' };\n\t\tfor (const label of Object.keys(d.data.labels)) {\n\t\t\tinfLabel[label] = d.data.labels[label];\n\t\t}\n\t\tacc.push(\n\t\t\tsetValuePair(infLabel, d.data.count, `${histogram.name}_bucket`),\n\t\t\tsetValuePair(d.data.labels, d.data.sum, `${histogram.name}_sum`),\n\t\t\tsetValuePair(d.data.labels, d.data.count, `${histogram.name}_count`)\n\t\t);\n\t\treturn acc;\n\t};\n}\n\nmodule.exports = Histogram;\n","/**\n * Summary\n */\n'use strict';\n\nconst util = require('util');\nconst { globalRegistry } = require('./registry');\nconst type = 'summary';\nconst {\n\tgetPropertiesFromObj,\n\tgetLabels,\n\thashObject,\n\tisObject,\n\tprintDeprecationObjectConstructor,\n\tremoveLabels\n} = require('./util');\nconst {\n\tvalidateLabel,\n\tvalidateMetricName,\n\tvalidateLabelName\n} = require('./validation');\nconst timeWindowQuantiles = require('./timeWindowQuantiles');\n\nclass Summary {\n\t/**\n\t * Summary\n\t * @param {string} name - Name of the metric\n\t * @param {string} help - Help for the metric\n\t * @param {object|Array.<string>} labelsOrConf - Either array of label names or config object as a key-value object\n\t * @param {object} conf - Configuration object\n\t */\n\tconstructor(name, help, labelsOrConf, conf) {\n\t\tlet config;\n\t\tif (isObject(name)) {\n\t\t\tconfig = Object.assign(\n\t\t\t\t{\n\t\t\t\t\tpercentiles: [0.01, 0.05, 0.5, 0.9, 0.95, 0.99, 0.999],\n\t\t\t\t\tlabelNames: []\n\t\t\t\t},\n\t\t\t\tname\n\t\t\t);\n\n\t\t\tif (!config.registers) {\n\t\t\t\tconfig.registers = [globalRegistry];\n\t\t\t}\n\t\t} else {\n\t\t\tlet obj;\n\t\t\tlet labels = [];\n\n\t\t\tif (Array.isArray(labelsOrConf)) {\n\t\t\t\tobj = conf || {};\n\t\t\t\tlabels = labelsOrConf;\n\t\t\t} else {\n\t\t\t\tobj = labelsOrConf || {};\n\t\t\t}\n\n\t\t\tprintDeprecationObjectConstructor();\n\n\t\t\tconfig = {\n\t\t\t\tname,\n\t\t\t\thelp,\n\t\t\t\tlabelNames: labels,\n\t\t\t\tpercentiles: configurePercentiles(obj.percentiles),\n\t\t\t\tregisters: [globalRegistry],\n\t\t\t\tmaxAgeSeconds: obj.maxAgeSeconds,\n\t\t\t\tageBuckets: obj.ageBuckets\n\t\t\t};\n\t\t}\n\n\t\tvalidateInput(config.name, config.help, config.labelNames);\n\n\t\tthis.maxAgeSeconds = config.maxAgeSeconds;\n\t\tthis.ageBuckets = config.ageBuckets;\n\n\t\tthis.name = config.name;\n\t\tthis.help = config.help;\n\t\tthis.aggregator = config.aggregator || 'sum';\n\n\t\tthis.percentiles = config.percentiles;\n\t\tthis.hashMap = {};\n\t\tthis.labelNames = config.labelNames || [];\n\n\t\tif (this.labelNames.length === 0) {\n\t\t\tthis.hashMap = {\n\t\t\t\t[hashObject({})]: {\n\t\t\t\t\tlabels: {},\n\t\t\t\t\ttd: new timeWindowQuantiles(this.maxAgeSeconds, this.ageBuckets),\n\t\t\t\t\tcount: 0,\n\t\t\t\t\tsum: 0\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tconfig.registers.forEach(registryInstance =>\n\t\t\tregistryInstance.registerMetric(this)\n\t\t);\n\t}\n\n\t/**\n\t * Observe a value\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @param {Number} value - Value to observe\n\t * @returns {void}\n\t */\n\tobserve(labels, value) {\n\t\tobserve.call(this, labels === 0 ? 0 : labels || {})(value);\n\t}\n\n\tget() {\n\t\tconst data = getPropertiesFromObj(this.hashMap);\n\t\tconst values = [];\n\t\tdata.forEach(s => {\n\t\t\textractSummariesForExport(s, this.percentiles).forEach(v => {\n\t\t\t\tvalues.push(v);\n\t\t\t});\n\t\t\tvalues.push(getSumForExport(s, this));\n\t\t\tvalues.push(getCountForExport(s, this));\n\t\t});\n\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\thelp: this.help,\n\t\t\ttype,\n\t\t\tvalues,\n\t\t\taggregator: this.aggregator\n\t\t};\n\t}\n\n\treset() {\n\t\tconst data = getPropertiesFromObj(this.hashMap);\n\t\tdata.forEach(s => {\n\t\t\ts.td.reset();\n\t\t\ts.count = 0;\n\t\t\ts.sum = 0;\n\t\t});\n\t}\n\n\t/**\n\t * Start a timer that could be used to logging durations\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @returns {function} - Function to invoke when you want to stop the timer and observe the duration in seconds\n\t * @example\n\t * var end = summary.startTimer();\n\t * makeExpensiveXHRRequest(function(err, res) {\n\t *\tend(); //Observe the duration of expensiveXHRRequest\n\t * });\n\t */\n\tstartTimer(labels) {\n\t\treturn startTimer.call(this, labels)();\n\t}\n\n\tlabels() {\n\t\tconst labels = getLabels(this.labelNames, arguments);\n\t\treturn {\n\t\t\tobserve: observe.call(this, labels),\n\t\t\tstartTimer: startTimer.call(this, labels)\n\t\t};\n\t}\n\n\tremove() {\n\t\tconst labels = getLabels(this.labelNames, arguments);\n\t\tremoveLabels.call(this, this.hashMap, labels);\n\t}\n}\n\nfunction extractSummariesForExport(summaryOfLabels, percentiles) {\n\tsummaryOfLabels.td.compress();\n\n\treturn percentiles.map(percentile => {\n\t\tconst percentileValue = summaryOfLabels.td.percentile(percentile);\n\t\treturn {\n\t\t\tlabels: Object.assign({ quantile: percentile }, summaryOfLabels.labels),\n\t\t\tvalue: percentileValue ? percentileValue : 0\n\t\t};\n\t});\n}\n\nfunction getCountForExport(value, summary) {\n\treturn {\n\t\tmetricName: `${summary.name}_count`,\n\t\tlabels: value.labels,\n\t\tvalue: value.count\n\t};\n}\n\nfunction getSumForExport(value, summary) {\n\treturn {\n\t\tmetricName: `${summary.name}_sum`,\n\t\tlabels: value.labels,\n\t\tvalue: value.sum\n\t};\n}\n\nfunction startTimer(startLabels) {\n\treturn () => {\n\t\tconst start = process.hrtime();\n\t\treturn endLabels => {\n\t\t\tconst delta = process.hrtime(start);\n\t\t\tthis.observe(\n\t\t\t\tObject.assign({}, startLabels, endLabels),\n\t\t\t\tdelta[0] + delta[1] / 1e9\n\t\t\t);\n\t\t};\n\t};\n}\n\nfunction validateInput(name, help, labels) {\n\tif (!help) {\n\t\tthrow new Error('Missing mandatory help parameter');\n\t}\n\tif (!name) {\n\t\tthrow new Error('Missing mandatory name parameter');\n\t}\n\n\tif (!validateMetricName(name)) {\n\t\tthrow new Error('Invalid metric name');\n\t}\n\n\tif (!validateLabelName(labels)) {\n\t\tthrow new Error('Invalid label name');\n\t}\n\n\tlabels.forEach(label => {\n\t\tif (label === 'quantile') {\n\t\t\tthrow new Error('quantile is a reserved label keyword');\n\t\t}\n\t});\n}\n\nfunction configurePercentiles(configuredPercentiles) {\n\tconst defaultPercentiles = [0.01, 0.05, 0.5, 0.9, 0.95, 0.99, 0.999];\n\treturn []\n\t\t.concat(configuredPercentiles || defaultPercentiles)\n\t\t.sort(sortAscending);\n}\n\nfunction sortAscending(x, y) {\n\treturn x - y;\n}\n\nfunction observe(labels) {\n\treturn value => {\n\t\tconst labelValuePair = convertLabelsAndValues(labels, value);\n\n\t\tvalidateLabel(this.labelNames, this.labels);\n\t\tif (!Number.isFinite(labelValuePair.value)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t`Value is not a valid number: ${util.format(labelValuePair.value)}`\n\t\t\t);\n\t\t}\n\n\t\tconst hash = hashObject(labelValuePair.labels);\n\t\tlet summaryOfLabel = this.hashMap[hash];\n\t\tif (!summaryOfLabel) {\n\t\t\tsummaryOfLabel = {\n\t\t\t\tlabels: labelValuePair.labels,\n\t\t\t\ttd: new timeWindowQuantiles(this.maxAgeSeconds, this.ageBuckets),\n\t\t\t\tcount: 0,\n\t\t\t\tsum: 0\n\t\t\t};\n\t\t}\n\n\t\tsummaryOfLabel.td.push(labelValuePair.value);\n\t\tsummaryOfLabel.count++;\n\t\tsummaryOfLabel.sum += labelValuePair.value;\n\t\tthis.hashMap[hash] = summaryOfLabel;\n\t};\n}\n\nfunction convertLabelsAndValues(labels, value) {\n\tif (value === undefined) {\n\t\treturn {\n\t\t\tvalue: labels,\n\t\t\tlabels: {}\n\t\t};\n\t}\n\n\treturn {\n\t\tlabels,\n\t\tvalue\n\t};\n}\n\nmodule.exports = Summary;\n","'use strict';\n\nconst { TDigest } = require('tdigest');\n\nclass TimeWindowQuantiles {\n\tconstructor(maxAgeSeconds, ageBuckets) {\n\t\tthis.maxAgeSeconds = maxAgeSeconds || 0;\n\t\tthis.ageBuckets = ageBuckets || 0;\n\n\t\tthis.shouldRotate = maxAgeSeconds && ageBuckets;\n\n\t\tthis.ringBuffer = Array(ageBuckets).fill(new TDigest());\n\t\tthis.currentBuffer = 0;\n\n\t\tthis.lastRotateTimestampMillis = Date.now();\n\t\tthis.durationBetweenRotatesMillis =\n\t\t\t(maxAgeSeconds * 1000) / ageBuckets || Infinity;\n\t}\n\n\tpercentile(quantile) {\n\t\tconst bucket = rotate.call(this);\n\t\treturn bucket.percentile(quantile);\n\t}\n\n\tpush(value) {\n\t\trotate.call(this);\n\t\tthis.ringBuffer.forEach(bucket => {\n\t\t\tbucket.push(value);\n\t\t});\n\t}\n\n\treset() {\n\t\tthis.ringBuffer.forEach(bucket => {\n\t\t\tbucket.reset();\n\t\t});\n\t}\n\n\tcompress() {\n\t\tthis.ringBuffer.forEach(bucket => {\n\t\t\tbucket.compress();\n\t\t});\n\t}\n}\n\nfunction rotate() {\n\tlet timeSinceLastRotateMillis = Date.now() - this.lastRotateTimestampMillis;\n\twhile (\n\t\ttimeSinceLastRotateMillis > this.durationBetweenRotatesMillis &&\n\t\tthis.shouldRotate\n\t) {\n\t\tthis.ringBuffer[this.currentBuffer] = new TDigest();\n\n\t\tif (++this.currentBuffer >= this.ringBuffer.length) {\n\t\t\tthis.currentBuffer = 0;\n\t\t}\n\t\ttimeSinceLastRotateMillis -= this.durationBetweenRotatesMillis;\n\t\tthis.lastRotateTimestampMillis += this.durationBetweenRotatesMillis;\n\t}\n\treturn this.ringBuffer[this.currentBuffer];\n}\n\nmodule.exports = TimeWindowQuantiles;\n","//\n// TDigest:\n//\n// approximate distribution percentiles from a stream of reals\n//\nvar RBTree = require('bintrees').RBTree;\n\nfunction TDigest(delta, K, CX) {\n    // allocate a TDigest structure.\n    //\n    // delta is the compression factor, the max fraction of mass that\n    // can be owned by one centroid (bigger, up to 1.0, means more\n    // compression). delta=false switches off TDigest behavior and treats\n    // the distribution as discrete, with no merging and exact values\n    // reported.\n    //\n    // K is a size threshold that triggers recompression as the TDigest\n    // grows during input.  (Set it to 0 to disable automatic recompression)\n    //\n    // CX specifies how often to update cached cumulative totals used\n    // for quantile estimation during ingest (see cumulate()).  Set to\n    // 0 to use exact quantiles for each new point.\n    //\n    this.discrete = (delta === false);\n    this.delta = delta || 0.01;\n    this.K = (K === undefined) ? 25 : K;\n    this.CX = (CX === undefined) ? 1.1 : CX;\n    this.centroids = new RBTree(compare_centroid_means);\n    this.nreset = 0;\n    this.reset();\n}\n\nTDigest.prototype.reset = function() {\n    // prepare to digest new points.\n    //\n    this.centroids.clear();\n    this.n = 0;\n    this.nreset += 1;\n    this.last_cumulate = 0;\n};\n\nTDigest.prototype.size = function() {\n    return this.centroids.size;\n};\n\nTDigest.prototype.toArray = function(everything) {\n    // return {mean,n} of centroids as an array ordered by mean.\n    //\n    var result = [];\n    if (everything) {\n        this._cumulate(true); // be sure cumns are exact\n        this.centroids.each(function(c) { result.push(c); });\n    } else {\n        this.centroids.each(function(c) { result.push({mean:c.mean, n:c.n}); });\n    }\n    return result;\n};\n\nTDigest.prototype.summary = function() {\n    var approx = (this.discrete) ? \"exact \" : \"approximating \";\n    var s = [approx + this.n + \" samples using \" + this.size() + \" centroids\",\n             \"min = \"+this.percentile(0),\n             \"Q1  = \"+this.percentile(0.25),\n             \"Q2  = \"+this.percentile(0.5),\n             \"Q3  = \"+this.percentile(0.75),\n             \"max = \"+this.percentile(1.0)];\n    return s.join('\\n');\n};\n\nfunction compare_centroid_means(a, b) {\n    // order two centroids by mean.\n    //\n    return (a.mean > b.mean) ? 1 : (a.mean < b.mean) ? -1 : 0;\n}\n\nfunction compare_centroid_mean_cumns(a, b) {\n    // order two centroids by mean_cumn.\n    //\n    return (a.mean_cumn - b.mean_cumn);\n}\n\nTDigest.prototype.push = function(x, n) {\n    // incorporate value or array of values x, having count n into the\n    // TDigest. n defaults to 1.\n    //\n    n = n || 1;\n    x = Array.isArray(x) ? x : [x];\n    for (var i = 0 ; i < x.length ; i++) {\n        this._digest(x[i], n);\n    }\n};\n\nTDigest.prototype.push_centroid = function(c) {\n    // incorporate centroid or array of centroids c\n    //\n    c = Array.isArray(c) ? c : [c];\n    for (var i = 0 ; i < c.length ; i++) {\n        this._digest(c[i].mean, c[i].n);\n    }\n};\n\nTDigest.prototype._cumulate = function(exact) {\n    // update cumulative counts for each centroid\n    //\n    // exact: falsey means only cumulate after sufficient\n    // growth. During ingest, these counts are used as quantile\n    // estimates, and they work well even when somewhat out of\n    // date. (this is a departure from the publication, you may set CX\n    // to 0 to disable).\n    //\n    if (this.n === this.last_cumulate ||\n        !exact && this.CX && this.CX > (this.n / this.last_cumulate)) {\n        return;\n    }\n    var cumn = 0;\n    var self = this;\n    this.centroids.each(function(c) {\n        c.mean_cumn = cumn + c.n / 2; // half of n at the mean\n        cumn = c.cumn = cumn + c.n;\n    });\n    this.n = this.last_cumulate = cumn;\n};\n\nTDigest.prototype.find_nearest = function(x) {\n    // find the centroid closest to x. The assumption of\n    // unique means and a unique nearest centroid departs from the\n    // paper, see _digest() below\n    //\n    if (this.size() === 0) {\n        return null;\n    }\n    var iter = this.centroids.lowerBound({mean:x}); // x <= iter || iter==null\n    var c = (iter.data() === null) ? iter.prev() : iter.data();\n    if (c.mean === x || this.discrete) {\n        return c; // c is either x or a neighbor (discrete: no distance func)\n    }\n    var prev = iter.prev();\n    if (prev && Math.abs(prev.mean - x) < Math.abs(c.mean - x)) {\n        return prev;\n    } else {\n        return c;\n    }\n};\n\nTDigest.prototype._new_centroid = function(x, n, cumn) {\n    // create and insert a new centroid into the digest (don't update\n    // cumulatives).\n    //\n    var c = {mean:x, n:n, cumn:cumn};\n    this.centroids.insert(c);\n    this.n += n;\n    return c;\n};\n\nTDigest.prototype._addweight = function(nearest, x, n) {\n    // add weight at location x to nearest centroid.  adding x to\n    // nearest will not shift its relative position in the tree and\n    // require reinsertion.\n    //\n    if (x !== nearest.mean) {\n        nearest.mean += n * (x - nearest.mean) / (nearest.n + n);\n    }\n    nearest.cumn += n;\n    nearest.mean_cumn += n / 2;\n    nearest.n += n;\n    this.n += n;\n};\n\nTDigest.prototype._digest = function(x, n) {\n    // incorporate value x, having count n into the TDigest.\n    //\n    var min = this.centroids.min();\n    var max = this.centroids.max();\n    var nearest = this.find_nearest(x);\n    if (nearest && nearest.mean === x) {\n        // accumulate exact matches into the centroid without\n        // limit. this is a departure from the paper, made so\n        // centroids remain unique and code can be simple.\n        this._addweight(nearest, x, n);\n    } else if (nearest === min) {\n        this._new_centroid(x, n, 0); // new point around min boundary\n    } else if (nearest === max ) {\n        this._new_centroid(x, n, this.n); // new point around max boundary\n    } else if (this.discrete) {\n        this._new_centroid(x, n, nearest.cumn); // never merge\n    } else {\n        // conider a merge based on nearest centroid's capacity. if\n        // there's not room for all of n, don't bother merging any of\n        // it into nearest, as we'll have to make a new centroid\n        // anyway for the remainder (departure from the paper).\n        var p = nearest.mean_cumn / this.n;\n        var max_n = Math.floor(4 * this.n * this.delta * p * (1 - p));\n        if (max_n - nearest.n >= n) {\n            this._addweight(nearest, x, n);\n        } else {\n            this._new_centroid(x, n, nearest.cumn);\n        }\n    }\n    this._cumulate(false);\n    if (!this.discrete && this.K && this.size() > this.K / this.delta) {\n        // re-process the centroids and hope for some compression.\n        this.compress();\n    }\n};\n\nTDigest.prototype.bound_mean = function(x) {\n    // find centroids lower and upper such that lower.mean < x <\n    // upper.mean or lower.mean === x === upper.mean. Don't call\n    // this for x out of bounds.\n    //\n    var iter = this.centroids.upperBound({mean:x}); // x < iter\n    var lower = iter.prev();      // lower <= x\n    var upper = (lower.mean === x) ? lower : iter.next();\n    return [lower, upper];\n};\n\nTDigest.prototype.p_rank = function(x_or_xlist) {\n    // return approximate percentile-ranks (0..1) for data value x.\n    // or list of x.  calculated according to\n    // https://en.wikipedia.org/wiki/Percentile_rank\n    //\n    // (Note that in continuous mode, boundary sample values will\n    // report half their centroid weight inward from 0/1 as the\n    // percentile-rank. X values outside the observed range return\n    // 0/1)\n    //\n    // this triggers cumulate() if cumn's are out of date.\n    //\n    var xs = Array.isArray(x_or_xlist) ? x_or_xlist : [x_or_xlist];\n    var ps = xs.map(this._p_rank, this);\n    return Array.isArray(x_or_xlist) ? ps : ps[0];\n};\n\nTDigest.prototype._p_rank = function(x) {\n    if (this.size() === 0) {\n        return undefined;\n    } else if (x < this.centroids.min().mean) {\n        return 0.0;\n    } else if (x > this.centroids.max().mean) {\n        return 1.0;\n    }\n    // find centroids that bracket x and interpolate x's cumn from\n    // their cumn's.\n    this._cumulate(true); // be sure cumns are exact\n    var bound = this.bound_mean(x);\n    var lower = bound[0], upper = bound[1];\n    if (this.discrete) {\n        return lower.cumn / this.n;\n    } else {\n        var cumn = lower.mean_cumn;\n        if (lower !== upper) {\n            cumn += (x - lower.mean) * (upper.mean_cumn - lower.mean_cumn) / (upper.mean - lower.mean);\n        }\n        return cumn / this.n;\n    }\n};\n\nTDigest.prototype.bound_mean_cumn = function(cumn) {\n    // find centroids lower and upper such that lower.mean_cumn < x <\n    // upper.mean_cumn or lower.mean_cumn === x === upper.mean_cumn. Don't call\n    // this for cumn out of bounds.\n    //\n    // XXX because mean and mean_cumn give rise to the same sort order\n    // (up to identical means), use the mean rbtree for our search.\n    this.centroids._comparator = compare_centroid_mean_cumns;\n    var iter = this.centroids.upperBound({mean_cumn:cumn}); // cumn < iter\n    this.centroids._comparator = compare_centroid_means;\n    var lower = iter.prev();      // lower <= cumn\n    var upper = (lower && lower.mean_cumn === cumn) ? lower : iter.next();\n    return [lower, upper];\n};\n\nTDigest.prototype.percentile = function(p_or_plist) {\n    // for percentage p (0..1), or for each p in a list of ps, return\n    // the smallest data value q at which at least p percent of the\n    // observations <= q.\n    //\n    // for discrete distributions, this selects q using the Nearest\n    // Rank Method\n    // (https://en.wikipedia.org/wiki/Percentile#The_Nearest_Rank_method)\n    // (in scipy, same as percentile(...., interpolation='higher')\n    //\n    // for continuous distributions, interpolates data values between\n    // count-weighted bracketing means.\n    //\n    // this triggers cumulate() if cumn's are out of date.\n    //\n    var ps = Array.isArray(p_or_plist) ? p_or_plist : [p_or_plist];\n    var qs = ps.map(this._percentile, this);\n    return Array.isArray(p_or_plist) ? qs : qs[0];\n};\n\nTDigest.prototype._percentile = function(p) {\n    if (this.size() === 0) {\n        return undefined;\n    }\n    this._cumulate(true); // be sure cumns are exact\n    var min = this.centroids.min();\n    var max = this.centroids.max();\n    var h = this.n * p;\n    var bound = this.bound_mean_cumn(h);\n    var lower = bound[0], upper = bound[1];\n\n    if (upper === lower || lower === null || upper === null) {\n        return (lower || upper).mean;\n    } else if (!this.discrete) {\n        return lower.mean + (h - lower.mean_cumn) * (upper.mean - lower.mean) / (upper.mean_cumn - lower.mean_cumn);\n    } else if (h <= lower.cumn) {\n        return lower.mean;\n    } else {\n        return upper.mean;\n    }\n};\n\nfunction pop_random(choices) {\n    // remove and return an item randomly chosen from the array of choices\n    // (mutates choices)\n    //\n    var idx = Math.floor(Math.random() * choices.length);\n    return choices.splice(idx, 1)[0];\n}\n\nTDigest.prototype.compress = function() {\n    // TDigests experience worst case compression (none) when input\n    // increases monotonically.  Improve on any bad luck by\n    // reconsuming digest centroids as if they were weighted points\n    // while shuffling their order (and hope for the best).\n    //\n    if (this.compressing) {\n        return;\n    }\n    var points = this.toArray();\n    this.reset();\n    this.compressing = true;\n    while (points.length > 0) {\n        this.push_centroid(pop_random(points));\n    }\n    this._cumulate(true);\n    this.compressing = false;\n};\n\nfunction Digest(config) {\n    // allocate a distribution digest structure. This is an extension\n    // of a TDigest structure that starts in exact histogram (discrete)\n    // mode, and automatically switches to TDigest mode for large\n    // samples that appear to be from a continuous distribution.\n    //\n    this.config = config || {};\n    this.mode = this.config.mode || 'auto'; // disc, cont, auto\n    TDigest.call(this, this.mode === 'cont' ? config.delta : false);\n    this.digest_ratio = this.config.ratio || 0.9;\n    this.digest_thresh = this.config.thresh || 1000;\n    this.n_unique = 0;\n}\nDigest.prototype = Object.create(TDigest.prototype);\nDigest.prototype.constructor = Digest;\n\nDigest.prototype.push = function(x_or_xlist) {\n    TDigest.prototype.push.call(this, x_or_xlist);\n    this.check_continuous();\n};\n\nDigest.prototype._new_centroid = function(x, n, cumn) {\n    this.n_unique += 1;\n    TDigest.prototype._new_centroid.call(this, x, n, cumn);\n};\n\nDigest.prototype._addweight = function(nearest, x, n) {\n    if (nearest.n === 1) {\n        this.n_unique -= 1;\n    }\n    TDigest.prototype._addweight.call(this, nearest, x, n);\n};\n\nDigest.prototype.check_continuous = function() {\n    // while in 'auto' mode, if there are many unique elements, assume\n    // they are from a continuous distribution and switch to 'cont'\n    // mode (tdigest behavior). Return true on transition from\n    // disctete to continuous.\n    if (this.mode !== 'auto' || this.size() < this.digest_thresh) {\n        return false;\n    }\n    if (this.n_unique / this.size() > this.digest_ratio) {\n        this.mode = 'cont';\n        this.discrete = false;\n        this.delta = this.config.delta || 0.01;\n        this.compress();\n        return true;\n    }\n    return false;\n};\n\nmodule.exports = {\n    'TDigest': TDigest,\n    'Digest': Digest\n};\n","module.exports = {\n    RBTree: require('./lib/rbtree'),\n    BinTree: require('./lib/bintree')\n};\n","\nvar TreeBase = require('./treebase');\n\nfunction Node(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n    this.red = true;\n}\n\nNode.prototype.get_child = function(dir) {\n    return dir ? this.right : this.left;\n};\n\nNode.prototype.set_child = function(dir, val) {\n    if(dir) {\n        this.right = val;\n    }\n    else {\n        this.left = val;\n    }\n};\n\nfunction RBTree(comparator) {\n    this._root = null;\n    this._comparator = comparator;\n    this.size = 0;\n}\n\nRBTree.prototype = new TreeBase();\n\n// returns true if inserted, false if duplicate\nRBTree.prototype.insert = function(data) {\n    var ret = false;\n\n    if(this._root === null) {\n        // empty tree\n        this._root = new Node(data);\n        ret = true;\n        this.size++;\n    }\n    else {\n        var head = new Node(undefined); // fake tree root\n\n        var dir = 0;\n        var last = 0;\n\n        // setup\n        var gp = null; // grandparent\n        var ggp = head; // grand-grand-parent\n        var p = null; // parent\n        var node = this._root;\n        ggp.right = this._root;\n\n        // search down\n        while(true) {\n            if(node === null) {\n                // insert new node at the bottom\n                node = new Node(data);\n                p.set_child(dir, node);\n                ret = true;\n                this.size++;\n            }\n            else if(is_red(node.left) && is_red(node.right)) {\n                // color flip\n                node.red = true;\n                node.left.red = false;\n                node.right.red = false;\n            }\n\n            // fix red violation\n            if(is_red(node) && is_red(p)) {\n                var dir2 = ggp.right === gp;\n\n                if(node === p.get_child(last)) {\n                    ggp.set_child(dir2, single_rotate(gp, !last));\n                }\n                else {\n                    ggp.set_child(dir2, double_rotate(gp, !last));\n                }\n            }\n\n            var cmp = this._comparator(node.data, data);\n\n            // stop if found\n            if(cmp === 0) {\n                break;\n            }\n\n            last = dir;\n            dir = cmp < 0;\n\n            // update helpers\n            if(gp !== null) {\n                ggp = gp;\n            }\n            gp = p;\n            p = node;\n            node = node.get_child(dir);\n        }\n\n        // update root\n        this._root = head.right;\n    }\n\n    // make root black\n    this._root.red = false;\n\n    return ret;\n};\n\n// returns true if removed, false if not found\nRBTree.prototype.remove = function(data) {\n    if(this._root === null) {\n        return false;\n    }\n\n    var head = new Node(undefined); // fake tree root\n    var node = head;\n    node.right = this._root;\n    var p = null; // parent\n    var gp = null; // grand parent\n    var found = null; // found item\n    var dir = 1;\n\n    while(node.get_child(dir) !== null) {\n        var last = dir;\n\n        // update helpers\n        gp = p;\n        p = node;\n        node = node.get_child(dir);\n\n        var cmp = this._comparator(data, node.data);\n\n        dir = cmp > 0;\n\n        // save found node\n        if(cmp === 0) {\n            found = node;\n        }\n\n        // push the red node down\n        if(!is_red(node) && !is_red(node.get_child(dir))) {\n            if(is_red(node.get_child(!dir))) {\n                var sr = single_rotate(node, dir);\n                p.set_child(last, sr);\n                p = sr;\n            }\n            else if(!is_red(node.get_child(!dir))) {\n                var sibling = p.get_child(!last);\n                if(sibling !== null) {\n                    if(!is_red(sibling.get_child(!last)) && !is_red(sibling.get_child(last))) {\n                        // color flip\n                        p.red = false;\n                        sibling.red = true;\n                        node.red = true;\n                    }\n                    else {\n                        var dir2 = gp.right === p;\n\n                        if(is_red(sibling.get_child(last))) {\n                            gp.set_child(dir2, double_rotate(p, last));\n                        }\n                        else if(is_red(sibling.get_child(!last))) {\n                            gp.set_child(dir2, single_rotate(p, last));\n                        }\n\n                        // ensure correct coloring\n                        var gpc = gp.get_child(dir2);\n                        gpc.red = true;\n                        node.red = true;\n                        gpc.left.red = false;\n                        gpc.right.red = false;\n                    }\n                }\n            }\n        }\n    }\n\n    // replace and remove if found\n    if(found !== null) {\n        found.data = node.data;\n        p.set_child(p.right === node, node.get_child(node.left === null));\n        this.size--;\n    }\n\n    // update root and make it black\n    this._root = head.right;\n    if(this._root !== null) {\n        this._root.red = false;\n    }\n\n    return found !== null;\n};\n\nfunction is_red(node) {\n    return node !== null && node.red;\n}\n\nfunction single_rotate(root, dir) {\n    var save = root.get_child(!dir);\n\n    root.set_child(!dir, save.get_child(dir));\n    save.set_child(dir, root);\n\n    root.red = true;\n    save.red = false;\n\n    return save;\n}\n\nfunction double_rotate(root, dir) {\n    root.set_child(!dir, single_rotate(root.get_child(!dir), !dir));\n    return single_rotate(root, dir);\n}\n\nmodule.exports = RBTree;\n","\nvar TreeBase = require('./treebase');\n\nfunction Node(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n}\n\nNode.prototype.get_child = function(dir) {\n    return dir ? this.right : this.left;\n};\n\nNode.prototype.set_child = function(dir, val) {\n    if(dir) {\n        this.right = val;\n    }\n    else {\n        this.left = val;\n    }\n};\n\nfunction BinTree(comparator) {\n    this._root = null;\n    this._comparator = comparator;\n    this.size = 0;\n}\n\nBinTree.prototype = new TreeBase();\n\n// returns true if inserted, false if duplicate\nBinTree.prototype.insert = function(data) {\n    if(this._root === null) {\n        // empty tree\n        this._root = new Node(data);\n        this.size++;\n        return true;\n    }\n\n    var dir = 0;\n\n    // setup\n    var p = null; // parent\n    var node = this._root;\n\n    // search down\n    while(true) {\n        if(node === null) {\n            // insert new node at the bottom\n            node = new Node(data);\n            p.set_child(dir, node);\n            ret = true;\n            this.size++;\n            return true;\n        }\n\n        // stop if found\n        if(this._comparator(node.data, data) === 0) {\n            return false;\n        }\n\n        dir = this._comparator(node.data, data) < 0;\n\n        // update helpers\n        p = node;\n        node = node.get_child(dir);\n    }\n};\n\n// returns true if removed, false if not found\nBinTree.prototype.remove = function(data) {\n    if(this._root === null) {\n        return false;\n    }\n\n    var head = new Node(undefined); // fake tree root\n    var node = head;\n    node.right = this._root;\n    var p = null; // parent\n    var found = null; // found item\n    var dir = 1;\n\n    while(node.get_child(dir) !== null) {\n        p = node;\n        node = node.get_child(dir);\n        var cmp = this._comparator(data, node.data);\n        dir = cmp > 0;\n\n        if(cmp === 0) {\n            found = node;\n        }\n    }\n\n    if(found !== null) {\n        found.data = node.data;\n        p.set_child(p.right === node, node.get_child(node.left === null));\n\n        this._root = head.right;\n        this.size--;\n        return true;\n    }\n    else {\n        return false;\n    }\n};\n\nmodule.exports = BinTree;\n\n","'use strict';\n\nconst url = require('url');\nconst http = require('http');\nconst https = require('https');\nconst { globalRegistry } = require('./registry');\n\nclass Pushgateway {\n\tconstructor(gatewayUrl, options, registry) {\n\t\tif (!registry) {\n\t\t\tregistry = globalRegistry;\n\t\t}\n\t\tthis.registry = registry;\n\t\tthis.gatewayUrl = gatewayUrl;\n\t\tthis.requestOptions = Object.assign({}, options);\n\t}\n\n\tpushAdd(params, callback) {\n\t\tif (!params || !params.jobName) {\n\t\t\tthrow new Error('Missing jobName parameter');\n\t\t}\n\n\t\tuseGateway.call(this, 'POST', params.jobName, params.groupings, callback);\n\t}\n\n\tpush(params, callback) {\n\t\tif (!params || !params.jobName) {\n\t\t\tthrow new Error('Missing jobName parameter');\n\t\t}\n\n\t\tuseGateway.call(this, 'PUT', params.jobName, params.groupings, callback);\n\t}\n\n\tdelete(params, callback) {\n\t\tif (!params || !params.jobName) {\n\t\t\tthrow new Error('Missing jobName parameter');\n\t\t}\n\n\t\tuseGateway.call(this, 'DELETE', params.jobName, params.groupings, callback);\n\t}\n}\nfunction useGateway(method, job, groupings, callback) {\n\t// `URL` first added in v6.13.0\n\t// eslint-disable-next-line node/no-deprecated-api\n\tconst gatewayUrlParsed = url.parse(this.gatewayUrl);\n\tconst gatewayUrlPath =\n\t\tgatewayUrlParsed.pathname && gatewayUrlParsed.pathname !== '/'\n\t\t\t? gatewayUrlParsed.pathname\n\t\t\t: '';\n\tconst path = `${gatewayUrlPath}/metrics/job/${encodeURIComponent(\n\t\tjob\n\t)}${generateGroupings(groupings)}`;\n\n\t// eslint-disable-next-line node/no-deprecated-api\n\tconst target = url.resolve(this.gatewayUrl, path);\n\t// eslint-disable-next-line node/no-deprecated-api\n\tconst requestParams = url.parse(target);\n\tconst httpModule = isHttps(requestParams.href) ? https : http;\n\tconst options = Object.assign(requestParams, this.requestOptions, {\n\t\tmethod\n\t});\n\n\tconst req = httpModule.request(options, res => {\n\t\tlet body = '';\n\t\tres.setEncoding('utf8');\n\t\tres.on('data', chunk => {\n\t\t\tbody += chunk;\n\t\t});\n\t\tres.on('end', () => {\n\t\t\tcallback(null, res, body);\n\t\t});\n\t});\n\treq.on('error', err => {\n\t\tcallback(err);\n\t});\n\n\tif (method !== 'DELETE') {\n\t\treq.write(this.registry.metrics({ timestamps: false }));\n\t}\n\treq.end();\n}\n\nfunction generateGroupings(groupings) {\n\tif (!groupings) {\n\t\treturn '';\n\t}\n\treturn Object.keys(groupings)\n\t\t.map(\n\t\t\tkey => `/${encodeURIComponent(key)}/${encodeURIComponent(groupings[key])}`\n\t\t)\n\t\t.join('');\n}\n\nfunction isHttps(href) {\n\treturn href.search(/^https/) !== -1;\n}\n\nmodule.exports = Pushgateway;\n","module.exports = require(\"url\");","module.exports = require(\"http\");","module.exports = require(\"https\");","'use strict';\n\nconst processCpuTotal = require('./metrics/processCpuTotal');\nconst processStartTime = require('./metrics/processStartTime');\nconst osMemoryHeap = require('./metrics/osMemoryHeap');\nconst processOpenFileDescriptors = require('./metrics/processOpenFileDescriptors');\nconst processMaxFileDescriptors = require('./metrics/processMaxFileDescriptors');\nconst eventLoopLag = require('./metrics/eventLoopLag');\nconst processHandles = require('./metrics/processHandles');\nconst processRequests = require('./metrics/processRequests');\nconst heapSizeAndUsed = require('./metrics/heapSizeAndUsed');\nconst heapSpacesSizeAndUsed = require('./metrics/heapSpacesSizeAndUsed');\nconst version = require('./metrics/version');\nconst { globalRegistry } = require('./registry');\nconst { printDeprecationCollectDefaultMetricsNumber } = require('./util');\n\nconst metrics = {\n\tprocessCpuTotal,\n\tprocessStartTime,\n\tosMemoryHeap,\n\tprocessOpenFileDescriptors,\n\tprocessMaxFileDescriptors,\n\teventLoopLag,\n\tprocessHandles,\n\tprocessRequests,\n\theapSizeAndUsed,\n\theapSpacesSizeAndUsed,\n\tversion\n};\nconst metricsList = Object.keys(metrics);\n\nlet existingInterval = null;\n// This is used to ensure the program throws on duplicate metrics during first run\n// We might want to consider not supporting running the default metrics function more than once\nlet init = true;\n\nmodule.exports = function startDefaultMetrics(config) {\n\tlet normalizedConfig = config;\n\tif (typeof config === 'number') {\n\t\tprintDeprecationCollectDefaultMetricsNumber(config);\n\n\t\tnormalizedConfig = { timeout: config };\n\t}\n\n\tnormalizedConfig = Object.assign({ timeout: 10000 }, normalizedConfig);\n\n\tif (existingInterval !== null) {\n\t\tclearInterval(existingInterval);\n\t}\n\n\tconst initialisedMetrics = metricsList.map(metric => {\n\t\tconst defaultMetric = metrics[metric];\n\t\tif (!init) {\n\t\t\tdefaultMetric.metricNames.map(\n\t\t\t\tglobalRegistry.removeSingleMetric,\n\t\t\t\tglobalRegistry\n\t\t\t);\n\t\t}\n\n\t\treturn defaultMetric(normalizedConfig.register, config);\n\t});\n\n\tfunction updateAllMetrics() {\n\t\tinitialisedMetrics.forEach(metric => metric.call());\n\t}\n\n\tupdateAllMetrics();\n\n\texistingInterval = setInterval(\n\t\tupdateAllMetrics,\n\t\tnormalizedConfig.timeout\n\t).unref();\n\n\tinit = false;\n\n\treturn existingInterval;\n};\n\nmodule.exports.metricsList = metricsList;\n","'use strict';\n\nconst Counter = require('../counter');\nconst PROCESS_CPU_USER_SECONDS = 'process_cpu_user_seconds_total';\nconst PROCESS_CPU_SYSTEM_SECONDS = 'process_cpu_system_seconds_total';\nconst PROCESS_CPU_SECONDS = 'process_cpu_seconds_total';\n\nmodule.exports = (registry, config = {}) => {\n\t// Don't do anything if the function doesn't exist (introduced in node@6.1.0)\n\tif (typeof process.cpuUsage !== 'function') {\n\t\treturn () => {};\n\t}\n\n\tconst registers = registry ? [registry] : undefined;\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst cpuUserUsageCounter = new Counter({\n\t\tname: namePrefix + PROCESS_CPU_USER_SECONDS,\n\t\thelp: 'Total user CPU time spent in seconds.',\n\t\tregisters\n\t});\n\tconst cpuSystemUsageCounter = new Counter({\n\t\tname: namePrefix + PROCESS_CPU_SYSTEM_SECONDS,\n\t\thelp: 'Total system CPU time spent in seconds.',\n\t\tregisters\n\t});\n\tconst cpuUsageCounter = new Counter({\n\t\tname: namePrefix + PROCESS_CPU_SECONDS,\n\t\thelp: 'Total user and system CPU time spent in seconds.',\n\t\tregisters\n\t});\n\n\tlet lastCpuUsage = process.cpuUsage();\n\n\treturn () => {\n\t\tconst cpuUsage = process.cpuUsage();\n\t\tconst now = Date.now();\n\n\t\tconst userUsageMicros = cpuUsage.user - lastCpuUsage.user;\n\t\tconst systemUsageMicros = cpuUsage.system - lastCpuUsage.system;\n\n\t\tlastCpuUsage = cpuUsage;\n\n\t\tcpuUserUsageCounter.inc(userUsageMicros / 1e6, now);\n\t\tcpuSystemUsageCounter.inc(systemUsageMicros / 1e6, now);\n\t\tcpuUsageCounter.inc((userUsageMicros + systemUsageMicros) / 1e6, now);\n\t};\n};\n\nmodule.exports.metricNames = [\n\tPROCESS_CPU_USER_SECONDS,\n\tPROCESS_CPU_SYSTEM_SECONDS,\n\tPROCESS_CPU_SECONDS\n];\n","'use strict';\n\nconst Gauge = require('../gauge');\nconst nowInSeconds = Math.round(Date.now() / 1000 - process.uptime());\n\nconst PROCESS_START_TIME = 'process_start_time_seconds';\n\nmodule.exports = (registry, config = {}) => {\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst cpuUserGauge = new Gauge({\n\t\tname: namePrefix + PROCESS_START_TIME,\n\t\thelp: 'Start time of the process since unix epoch in seconds.',\n\t\tregisters: registry ? [registry] : undefined,\n\t\taggregator: 'omit'\n\t});\n\tlet isSet = false;\n\n\treturn () => {\n\t\tif (isSet) {\n\t\t\treturn;\n\t\t}\n\t\tcpuUserGauge.set(nowInSeconds);\n\t\tisSet = true;\n\t};\n};\n\nmodule.exports.metricNames = [PROCESS_START_TIME];\n","'use strict';\n\nconst Gauge = require('../gauge');\nconst linuxVariant = require('./osMemoryHeapLinux');\nconst safeMemoryUsage = require('./helpers/safeMemoryUsage');\n\nconst PROCESS_RESIDENT_MEMORY = 'process_resident_memory_bytes';\n\nfunction notLinuxVariant(registry, config = {}) {\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst residentMemGauge = new Gauge({\n\t\tname: namePrefix + PROCESS_RESIDENT_MEMORY,\n\t\thelp: 'Resident memory size in bytes.',\n\t\tregisters: registry ? [registry] : undefined\n\t});\n\n\treturn () => {\n\t\tconst memUsage = safeMemoryUsage();\n\n\t\t// I don't think the other things returned from `process.memoryUsage()` is relevant to a standard export\n\t\tif (memUsage) {\n\t\t\tresidentMemGauge.set(memUsage.rss, Date.now());\n\t\t}\n\t};\n}\n\nmodule.exports = (registry, config) =>\n\tprocess.platform === 'linux'\n\t\t? linuxVariant(registry, config)\n\t\t: notLinuxVariant(registry, config);\n\nmodule.exports.metricNames =\n\tprocess.platform === 'linux'\n\t\t? linuxVariant.metricNames\n\t\t: [PROCESS_RESIDENT_MEMORY];\n","'use strict';\n\nconst Gauge = require('../gauge');\nconst fs = require('fs');\n\nconst values = ['VmSize', 'VmRSS', 'VmData'];\n\nconst PROCESS_RESIDENT_MEMORY = 'process_resident_memory_bytes';\nconst PROCESS_VIRTUAL_MEMORY = 'process_virtual_memory_bytes';\nconst PROCESS_HEAP = 'process_heap_bytes';\n\nfunction structureOutput(input) {\n\tconst returnValue = {};\n\n\tinput\n\t\t.split('\\n')\n\t\t.filter(s => values.some(value => s.indexOf(value) === 0))\n\t\t.forEach(string => {\n\t\t\tconst split = string.split(':');\n\n\t\t\t// Get the value\n\t\t\tlet value = split[1].trim();\n\t\t\t// Remove trailing ` kb`\n\t\t\tvalue = value.substr(0, value.length - 3);\n\t\t\t// Make it into a number in bytes bytes\n\t\t\tvalue = Number(value) * 1024;\n\n\t\t\treturnValue[split[0]] = value;\n\t\t});\n\n\treturn returnValue;\n}\n\nmodule.exports = (registry, config = {}) => {\n\tconst registers = registry ? [registry] : undefined;\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst residentMemGauge = new Gauge({\n\t\tname: namePrefix + PROCESS_RESIDENT_MEMORY,\n\t\thelp: 'Resident memory size in bytes.',\n\t\tregisters\n\t});\n\tconst virtualMemGauge = new Gauge({\n\t\tname: namePrefix + PROCESS_VIRTUAL_MEMORY,\n\t\thelp: 'Virtual memory size in bytes.',\n\t\tregisters\n\t});\n\tconst heapSizeMemGauge = new Gauge({\n\t\tname: namePrefix + PROCESS_HEAP,\n\t\thelp: 'Process heap size in bytes.',\n\t\tregisters\n\t});\n\n\treturn () => {\n\t\tfs.readFile('/proc/self/status', 'utf8', (err, status) => {\n\t\t\tif (err) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst now = Date.now();\n\t\t\tconst structuredOutput = structureOutput(status);\n\n\t\t\tresidentMemGauge.set(structuredOutput.VmRSS, now);\n\t\t\tvirtualMemGauge.set(structuredOutput.VmSize, now);\n\t\t\theapSizeMemGauge.set(structuredOutput.VmData, now);\n\t\t});\n\t};\n};\n\nmodule.exports.metricNames = [\n\tPROCESS_RESIDENT_MEMORY,\n\tPROCESS_VIRTUAL_MEMORY,\n\tPROCESS_HEAP\n];\n","'use strict';\n\nconst Gauge = require('../gauge');\nconst fs = require('fs');\nconst process = require('process');\n\nconst PROCESS_OPEN_FDS = 'process_open_fds';\n\nmodule.exports = (registry, config = {}) => {\n\tif (process.platform !== 'linux') {\n\t\treturn () => {};\n\t}\n\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst fileDescriptorsGauge = new Gauge({\n\t\tname: namePrefix + PROCESS_OPEN_FDS,\n\t\thelp: 'Number of open file descriptors.',\n\t\tregisters: registry ? [registry] : undefined\n\t});\n\n\treturn () => {\n\t\tfs.readdir('/proc/self/fd', (err, list) => {\n\t\t\tif (err) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Minus 1, as this invocation created one\n\t\t\tfileDescriptorsGauge.set(list.length - 1, Date.now());\n\t\t});\n\t};\n};\n\nmodule.exports.metricNames = [PROCESS_OPEN_FDS];\n","module.exports = require(\"process\");","'use strict';\n\nconst Gauge = require('../gauge');\nconst fs = require('fs');\n\nconst PROCESS_MAX_FDS = 'process_max_fds';\n\nmodule.exports = (registry, config = {}) => {\n\tlet isSet = false;\n\n\tif (process.platform !== 'linux') {\n\t\treturn () => {};\n\t}\n\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst fileDescriptorsGauge = new Gauge({\n\t\tname: namePrefix + PROCESS_MAX_FDS,\n\t\thelp: 'Maximum number of open file descriptors.',\n\t\tregisters: registry ? [registry] : undefined\n\t});\n\n\treturn () => {\n\t\tif (isSet) {\n\t\t\treturn;\n\t\t}\n\n\t\tfs.readFile('/proc/sys/fs/file-max', 'utf8', (err, maxFds) => {\n\t\t\tif (err) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tisSet = true;\n\n\t\t\tfileDescriptorsGauge.set(Number(maxFds));\n\t\t});\n\t};\n};\n\nmodule.exports.metricNames = [PROCESS_MAX_FDS];\n","'use strict';\n\nconst Gauge = require('../gauge');\n\nconst NODEJS_EVENTLOOP_LAG = 'nodejs_eventloop_lag_seconds';\n\nfunction reportEventloopLag(start, gauge) {\n\tconst delta = process.hrtime(start);\n\tconst nanosec = delta[0] * 1e9 + delta[1];\n\tconst seconds = nanosec / 1e9;\n\n\tgauge.set(seconds, Date.now());\n}\n\nmodule.exports = (registry, config = {}) => {\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst gauge = new Gauge({\n\t\tname: namePrefix + NODEJS_EVENTLOOP_LAG,\n\t\thelp: 'Lag of event loop in seconds.',\n\t\tregisters: registry ? [registry] : undefined,\n\t\taggregator: 'average'\n\t});\n\n\treturn () => {\n\t\tconst start = process.hrtime();\n\t\tsetImmediate(reportEventloopLag, start, gauge);\n\t};\n};\n\nmodule.exports.metricNames = [NODEJS_EVENTLOOP_LAG];\n","'use strict';\n\nconst Gauge = require('../gauge');\n\nconst NODEJS_ACTIVE_HANDLES = 'nodejs_active_handles_total';\n\nmodule.exports = (registry, config = {}) => {\n\t// Don't do anything if the function is removed in later nodes (exists in node@6)\n\tif (typeof process._getActiveHandles !== 'function') {\n\t\treturn () => {};\n\t}\n\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst gauge = new Gauge({\n\t\tname: namePrefix + NODEJS_ACTIVE_HANDLES,\n\t\thelp: 'Number of active handles.',\n\t\tregisters: registry ? [registry] : undefined\n\t});\n\n\treturn () => {\n\t\tgauge.set(process._getActiveHandles().length, Date.now());\n\t};\n};\n\nmodule.exports.metricNames = [NODEJS_ACTIVE_HANDLES];\n","'use strict';\n\nconst Gauge = require('../gauge');\n\nconst NODEJS_ACTIVE_REQUESTS = 'nodejs_active_requests_total';\n\nmodule.exports = (registry, config = {}) => {\n\t// Don't do anything if the function is removed in later nodes (exists in node@6)\n\tif (typeof process._getActiveRequests !== 'function') {\n\t\treturn () => {};\n\t}\n\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst gauge = new Gauge({\n\t\tname: namePrefix + NODEJS_ACTIVE_REQUESTS,\n\t\thelp: 'Number of active requests.',\n\t\tregisters: registry ? [registry] : undefined\n\t});\n\n\treturn () => {\n\t\tgauge.set(process._getActiveRequests().length, Date.now());\n\t};\n};\n\nmodule.exports.metricNames = [NODEJS_ACTIVE_REQUESTS];\n","'use strict';\n\nconst Gauge = require('../gauge');\nconst safeMemoryUsage = require('./helpers/safeMemoryUsage');\n\nconst NODEJS_HEAP_SIZE_TOTAL = 'nodejs_heap_size_total_bytes';\nconst NODEJS_HEAP_SIZE_USED = 'nodejs_heap_size_used_bytes';\nconst NODEJS_EXTERNAL_MEMORY = 'nodejs_external_memory_bytes';\n\nmodule.exports = (registry, config = {}) => {\n\tif (typeof process.memoryUsage !== 'function') {\n\t\treturn () => {};\n\t}\n\n\tconst registers = registry ? [registry] : undefined;\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst heapSizeTotal = new Gauge({\n\t\tname: namePrefix + NODEJS_HEAP_SIZE_TOTAL,\n\t\thelp: 'Process heap size from node.js in bytes.',\n\t\tregisters\n\t});\n\tconst heapSizeUsed = new Gauge({\n\t\tname: namePrefix + NODEJS_HEAP_SIZE_USED,\n\t\thelp: 'Process heap size used from node.js in bytes.',\n\t\tregisters\n\t});\n\tlet externalMemUsed;\n\n\tconst usage = safeMemoryUsage();\n\tif (usage && usage.external) {\n\t\texternalMemUsed = new Gauge({\n\t\t\tname: namePrefix + NODEJS_EXTERNAL_MEMORY,\n\t\t\thelp: 'Nodejs external memory size in bytes.',\n\t\t\tregisters\n\t\t});\n\t}\n\n\treturn () => {\n\t\t// process.memoryUsage() can throw EMFILE errors, see #67\n\t\tconst memUsage = safeMemoryUsage();\n\t\tif (memUsage) {\n\t\t\tconst now = Date.now();\n\t\t\theapSizeTotal.set(memUsage.heapTotal, now);\n\t\t\theapSizeUsed.set(memUsage.heapUsed, now);\n\t\t\tif (memUsage.external && externalMemUsed) {\n\t\t\t\texternalMemUsed.set(memUsage.external, now);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\ttotal: heapSizeTotal,\n\t\t\tused: heapSizeUsed,\n\t\t\texternal: externalMemUsed\n\t\t};\n\t};\n};\n\nmodule.exports.metricNames = [\n\tNODEJS_HEAP_SIZE_TOTAL,\n\tNODEJS_HEAP_SIZE_USED,\n\tNODEJS_EXTERNAL_MEMORY\n];\n","'use strict';\n\nconst Gauge = require('../gauge');\nlet v8;\n\ntry {\n\tv8 = require('v8');\n} catch (e) {\n\t// node version is too old\n\t// probably we can use v8-heap-space-statistics for >=node-4.0.0 and <node-6.0.0\n}\n\nconst METRICS = ['total', 'used', 'available'];\n\nconst NODEJS_HEAP_SIZE = {};\n\nMETRICS.forEach(metricType => {\n\tNODEJS_HEAP_SIZE[metricType] = `nodejs_heap_space_size_${metricType}_bytes`;\n});\n\nmodule.exports = (registry, config = {}) => {\n\tif (\n\t\ttypeof v8 === 'undefined' ||\n\t\ttypeof v8.getHeapSpaceStatistics !== 'function'\n\t) {\n\t\treturn () => {};\n\t}\n\n\tconst registers = registry ? [registry] : undefined;\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst gauges = {};\n\n\tMETRICS.forEach(metricType => {\n\t\tgauges[metricType] = new Gauge({\n\t\t\tname: namePrefix + NODEJS_HEAP_SIZE[metricType],\n\t\t\thelp: `Process heap space size ${metricType} from node.js in bytes.`,\n\t\t\tlabelNames: ['space'],\n\t\t\tregisters\n\t\t});\n\t});\n\n\treturn () => {\n\t\tconst data = {\n\t\t\ttotal: {},\n\t\t\tused: {},\n\t\t\tavailable: {}\n\t\t};\n\t\tconst now = Date.now();\n\n\t\tv8.getHeapSpaceStatistics().forEach(space => {\n\t\t\tconst spaceName = space.space_name.substr(\n\t\t\t\t0,\n\t\t\t\tspace.space_name.indexOf('_space')\n\t\t\t);\n\n\t\t\tdata.total[spaceName] = space.space_size;\n\t\t\tdata.used[spaceName] = space.space_used_size;\n\t\t\tdata.available[spaceName] = space.space_available_size;\n\n\t\t\tgauges.total.set({ space: spaceName }, space.space_size, now);\n\t\t\tgauges.used.set({ space: spaceName }, space.space_used_size, now);\n\t\t\tgauges.available.set(\n\t\t\t\t{ space: spaceName },\n\t\t\t\tspace.space_available_size,\n\t\t\t\tnow\n\t\t\t);\n\t\t});\n\n\t\treturn data;\n\t};\n};\n\nmodule.exports.metricNames = METRICS.map(\n\tmetricType => NODEJS_HEAP_SIZE[metricType]\n);\n","module.exports = require(\"v8\");","'use strict';\n\nconst Gauge = require('../gauge');\nconst version = process.version;\nconst versionSegments = version\n\t.slice(1)\n\t.split('.')\n\t.map(Number);\n\nconst NODE_VERSION_INFO = 'nodejs_version_info';\n\nmodule.exports = (registry, config = {}) => {\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst nodeVersionGauge = new Gauge({\n\t\tname: namePrefix + NODE_VERSION_INFO,\n\t\thelp: 'Node.js version info.',\n\t\tlabelNames: ['version', 'major', 'minor', 'patch'],\n\t\tregisters: registry ? [registry] : undefined,\n\t\taggregator: 'first'\n\t});\n\tlet isSet = false;\n\n\treturn () => {\n\t\tif (isSet) {\n\t\t\treturn;\n\t\t}\n\t\tnodeVersionGauge\n\t\t\t.labels(\n\t\t\t\tversion,\n\t\t\t\tversionSegments[0],\n\t\t\t\tversionSegments[1],\n\t\t\t\tversionSegments[2]\n\t\t\t)\n\t\t\t.set(1);\n\t\tisSet = true;\n\t};\n};\n\nmodule.exports.metricNames = [NODE_VERSION_INFO];\n","'use strict';\n\n/**\n * Extends the Registry class with a `clusterMetrics` method that returns\n * aggregated metrics for all workers.\n *\n * In cluster workers, listens for and responds to requests for metrics by the\n * cluster master.\n */\n\nconst cluster = require('cluster');\nconst Registry = require('./registry');\nconst { Grouper } = require('./util');\nconst { aggregators } = require('./metricAggregators');\n\nconst GET_METRICS_REQ = 'prom-client:getMetricsReq';\nconst GET_METRICS_RES = 'prom-client:getMetricsRes';\n\nlet registries = [Registry.globalRegistry];\nlet requestCtr = 0; // Concurrency control\nlet listenersAdded = false;\nconst requests = new Map(); // Pending requests for workers' local metrics.\n\nclass AggregatorRegistry extends Registry {\n\tconstructor() {\n\t\tsuper();\n\t\taddListeners();\n\t}\n\n\t/**\n\t * Gets aggregated metrics for all workers. The optional callback and\n\t * returned Promise resolve with the same value; either may be used.\n\t * @param {Function?} callback (err, metrics) => any\n\t * @return {Promise<string>} Promise that resolves with the aggregated\n\t *   metrics.\n\t */\n\tclusterMetrics(callback) {\n\t\tconst requestId = requestCtr++;\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tfunction done(err, result) {\n\t\t\t\t// Don't resolve/reject the promise if a callback is provided\n\t\t\t\tif (typeof callback === 'function') {\n\t\t\t\t\tcallback(err, result);\n\t\t\t\t} else {\n\t\t\t\t\tif (err) reject(err);\n\t\t\t\t\telse resolve(result);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst request = {\n\t\t\t\tresponses: [],\n\t\t\t\tpending: 0,\n\t\t\t\tdone,\n\t\t\t\terrorTimeout: setTimeout(() => {\n\t\t\t\t\trequest.failed = true;\n\t\t\t\t\tconst err = new Error('Operation timed out.');\n\t\t\t\t\trequest.done(err);\n\t\t\t\t}, 5000),\n\t\t\t\tfailed: false\n\t\t\t};\n\t\t\trequests.set(requestId, request);\n\n\t\t\tconst message = {\n\t\t\t\ttype: GET_METRICS_REQ,\n\t\t\t\trequestId\n\t\t\t};\n\n\t\t\tfor (const id in cluster.workers) {\n\t\t\t\t// If the worker exits abruptly, it may still be in the workers\n\t\t\t\t// list but not able to communicate.\n\t\t\t\tif (cluster.workers[id].isConnected()) {\n\t\t\t\t\tcluster.workers[id].send(message);\n\t\t\t\t\trequest.pending++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (request.pending === 0) {\n\t\t\t\t// No workers were up\n\t\t\t\tclearTimeout(request.errorTimeout);\n\t\t\t\tprocess.nextTick(() => done(null, ''));\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Creates a new Registry instance from an array of metrics that were\n\t * created by `registry.getMetricsAsJSON()`. Metrics are aggregated using\n\t * the method specified by their `aggregator` property, or by summation if\n\t * `aggregator` is undefined.\n\t * @param {Array} metricsArr Array of metrics, each of which created by\n\t *   `registry.getMetricsAsJSON()`.\n\t * @return {Registry} aggregated registry.\n\t */\n\tstatic aggregate(metricsArr) {\n\t\tconst aggregatedRegistry = new Registry();\n\t\tconst metricsByName = new Grouper();\n\n\t\t// Gather by name\n\t\tmetricsArr.forEach(metrics => {\n\t\t\tmetrics.forEach(metric => {\n\t\t\t\tmetricsByName.add(metric.name, metric);\n\t\t\t});\n\t\t});\n\n\t\t// Aggregate gathered metrics.\n\t\tmetricsByName.forEach(metrics => {\n\t\t\tconst aggregatorName = metrics[0].aggregator;\n\t\t\tconst aggregatorFn = aggregators[aggregatorName];\n\t\t\tif (typeof aggregatorFn !== 'function') {\n\t\t\t\tthrow new Error(`'${aggregatorName}' is not a defined aggregator.`);\n\t\t\t}\n\t\t\tconst aggregatedMetric = aggregatorFn(metrics);\n\t\t\t// NB: The 'omit' aggregator returns undefined.\n\t\t\tif (aggregatedMetric) {\n\t\t\t\tconst aggregatedMetricWrapper = Object.assign(\n\t\t\t\t\t{\n\t\t\t\t\t\tget: () => aggregatedMetric\n\t\t\t\t\t},\n\t\t\t\t\taggregatedMetric\n\t\t\t\t);\n\t\t\t\taggregatedRegistry.registerMetric(aggregatedMetricWrapper);\n\t\t\t}\n\t\t});\n\n\t\treturn aggregatedRegistry;\n\t}\n\n\t/**\n\t * Sets the registry or registries to be aggregated. Call from workers to\n\t * use a registry/registries other than the default global registry.\n\t * @param {Array<Registry>|Registry} regs Registry or registries to be\n\t *   aggregated.\n\t * @return {void}\n\t */\n\tstatic setRegistries(regs) {\n\t\tif (!Array.isArray(regs)) regs = [regs];\n\t\tregs.forEach(reg => {\n\t\t\tif (!(reg instanceof Registry)) {\n\t\t\t\tthrow new TypeError(`Expected Registry, got ${typeof reg}`);\n\t\t\t}\n\t\t});\n\t\tregistries = regs;\n\t}\n}\n\n/**\n * Adds event listeners for cluster aggregation. Idempotent (safe to call more\n * than once).\n * @return {void}\n */\nfunction addListeners() {\n\tif (listenersAdded) return;\n\tlistenersAdded = true;\n\n\tif (cluster.isMaster) {\n\t\t// Listen for worker responses to requests for local metrics\n\t\tcluster.on('message', (worker, message) => {\n\t\t\tif (message.type === GET_METRICS_RES) {\n\t\t\t\tconst request = requests.get(message.requestId);\n\t\t\t\tmessage.metrics.forEach(registry => request.responses.push(registry));\n\t\t\t\trequest.pending--;\n\n\t\t\t\tif (request.pending === 0) {\n\t\t\t\t\t// finalize\n\t\t\t\t\trequests.delete(message.requestId);\n\t\t\t\t\tclearTimeout(request.errorTimeout);\n\n\t\t\t\t\tif (request.failed) return; // Callback already run with Error.\n\n\t\t\t\t\tconst registry = AggregatorRegistry.aggregate(request.responses);\n\t\t\t\t\tconst promString = registry.metrics();\n\t\t\t\t\trequest.done(null, promString);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n\nif (cluster.isWorker) {\n\t// Respond to master's requests for worker's local metrics.\n\tprocess.on('message', message => {\n\t\tif (message.type === GET_METRICS_REQ) {\n\t\t\tprocess.send({\n\t\t\t\ttype: GET_METRICS_RES,\n\t\t\t\trequestId: message.requestId,\n\t\t\t\tmetrics: registries.map(r => r.getMetricsAsJSON())\n\t\t\t});\n\t\t}\n\t});\n}\n\nmodule.exports = AggregatorRegistry;\n","module.exports = require(\"cluster\");","'use strict';\n\nmodule.exports = exports = function promisify (func) {\n  return function promisifiedFunction () {\n    return new Promise((resolve, reject) => {\n      const cb = (err, result) => {\n        if (err) reject(err);\n        resolve(result);\n      };\n      const args = Array.prototype.slice.call(arguments);\n      args.push(cb);\n      func.apply(func, args);\n    });\n  };\n};\n"],"sourceRoot":""}